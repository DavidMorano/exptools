Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: Recalling Variables, Prev: Storing Variables, Up: Store and Recall, Next: Operations on Variables

Recalling Variables
===================

The most straightforward way to extract the stored value from a variable
is to use the `s r' (`calc-recall') command.  This command prompts
for a variable name (similarly to `calc-store'), looks up the value
of the specified variable, and pushes that value onto the stack.  It is
an error to try to recall a void variable.

It is also possible to recall the value from a variable by evaluating a
formula containing that variable.  For example, `' a RET =' is
the same as `s r a RET' except that if the variable is void, the
former will simply leave the formula `a' on the stack whereas the
latter will produce an error message.

The `r' prefix may be followed by a digit, so that `r 9' is
equivalent to `s r 9'.  (The `r' prefix is otherwise unused
in the current version of Calc.)


File: calc.info  Node: Operations on Variables, Prev: Recalling Variables, Up: Store and Recall, Next: Let Command

Other Operations on Variables
=============================

The `s e' (`calc-edit-variable') command edits the stored
value of a variable without ever putting that value on the stack
or simplifying or evaluating the value.  It prompts for the name of
the variable to edit.  If the variable has no stored value, the
editing buffer will start out empty.  If the editing buffer is
empty when you press M-# M-# to finish, the variable will
be made void.  *Note Editing Stack Entries::, for a general
description of editing.

The `s e' command is especially useful for creating and editing
rewrite rules which are stored in variables.  Sometimes these rules
contain formulas which must not be evaluated until the rules are
actually used.  (For example, they may refer to `variable(x)',
which tests if `x' is a variable; if you let Calc evaluate the
rule while you are defining it, Calc will replace `variable(x)'
with 1 (true) because `x' itself is a variable, but what you
really wanted was to test the thing that will replace `x' when
the rule is invoked.)  By contrast, recalling the variable, editing
with ``', and storing will evaluate the variable's value as a
side effect of putting the value on the stack.

There are several special-purpose variable-editing commands that
use the `s' prefix followed by a shifted letter:

`s A'
     Edit `AlgSimpRules'.  *Note Algebraic Simplifications::.
`s D'
     Edit `Decls'.  *Note Declarations::.
`s E'
     Edit `EvalRules'.  *Note Default Simplifications::.
`s F'
     Edit `FitRules'.  *Note Curve Fitting::.
`s G'
     Edit `GenCount'.  *Note Solving Equations::.
`s I'
     Edit `IntegLimit'.  *Note Calculus::.
`s P'
     Edit `PlotRejects'.  *Note Graphics::.
`s T'
     Edit `TimeZone'.  *Note Time Zones::.
`s U'
     Edit `UnitSimpRules'.  *Note Simplification of Units::.
`s X'
     Edit `ExtSimpRules'.  *Note Unsafe Simplifications::.

These commands are just versions of `s e' that use fixed variable
names rather than prompting for the variable name.

The `s p' (`calc-permanent-variable') command saves a
variable's value permanently in your `.emacs' file, so that its
value will still be available in future Emacs sessions.  You can
re-execute `s p' later on to update the saved value, but the
only way to remove a saved variable is to edit your `.emacs' file
by hand.  (*Note General Mode Commands::, for a way to tell Calc to
use a different file instead of `.emacs'.)

If you do not specify the name of a variable to save (i.e., `s p RET'),
all `var-' variables with defined values are saved except for the
special constants `pi', `e', `i', `phi', and `gamma'; the variables
`TimeZone' and `PlotRejects'; `FitRules', `DistribRules', and other
built-in rewrite rules; and `PlotDataN' variables generated by the
graphics commands.  (You can still save these variables by explicitly
naming them in an `s p' command.)

The `s i' (`calc-insert-variables') command writes
the values of all `var-' variables into a specified buffer.
The variables are written in the form of Lisp `setq' commands
which store the values in string form.  You can place these commands
in your `.emacs' buffer if you wish, though in this case it
would be easier to use `s p RET'.  (Note that `s i'
omits the same set of variables as `s p RET'; the difference
is that `s i' will store the variables in any buffer, and it also
stores in a more human-readable format.)


File: calc.info  Node: Let Command, Prev: Operations on Variables, Up: Store and Recall, Next: Evaluates-To Operator

The Let Command
===============

If you have an expression like `a+b^2' on the stack and you wish to
compute its value where `b=3', you can simply store 3 in `b' and
then press `=' to reevaluate the formula.  This has the side-effect
of leaving the stored value of 3 in `b' for future operations.

The `s l' (`calc-let') command evaluates a formula under a
*temporary* assignment of a variable.  It stores the value on the
top of the stack into the specified variable, then evaluates the
second-to-top stack entry, then restores the original value (or lack of
one) in the variable.  Thus after `' a+b^2 RET 3 s l b RET',
the stack will contain the formula `a + 9'.  The subsequent command
`5 s l a RET' will replace this formula with the number 14.  The
variables `a' and `b' are not permanently affected in any way
by these commands.

The value on the top of the stack may be an equation or assignment, or
vector of equations or assignments, in which case the default will be
analogous to the case of `s t RET'.  *Note Storing Variables::.

Also, you can answer the variable-name prompt with an equation or
assignment:  `s l b=3 RET' is the same as storing 3 on the stack
and typing `s l b RET'.

The `a b' (`calc-substitute') is another way to substitute
a variable with a value in a formula.  It does an actual substitution
rather than temporarily assigning the variable and evaluating.  For
example, letting `n=2' in `f(n pi)' with `a b' will
produce `f(2 pi)', whereas `s l' would give `f(6.28)'
since the evaluation step will also evaluate `pi'.


File: calc.info  Node: Evaluates-To Operator, Prev: Let Command, Up: Store and Recall

The Evaluates-To Operator
=========================

The special algebraic symbol `=>' is known as the "evaluates-to
operator".  (It will show up as an `evalto' function call in
other language modes like Pascal and TeX.)  This is a binary
operator, that is, it has a lefthand and a righthand argument,
although it can be entered with the righthand argument omitted.

A formula like `A => B' is evaluated by Calc as
follows:  First, A is not simplified or modified in any
way.  The previous value of argument B is thrown away; the
formula A is then copied and evaluated as if by the `='
command according to all current modes and stored variable values,
and the result is installed as the new value of B.

For example, suppose you enter the algebraic formula `2 + 3 => 17'.
The number 17 is ignored, and the lefthand argument is left in its
unevaluated form; the result is the formula `2 + 3 => 5'.

You can enter an `=>' formula either directly using algebraic
entry (in which case the righthand side may be omitted since it is
going to be replaced right away anyhow), or by using the `s ='
(`calc-evalto') command, which takes A from the stack
and replaces it with `A => B'.

Calc keeps track of all `=>' operators on the stack, and
recomputes them whenever anything changes that might affect their
values, i.e., a mode setting or variable value.  This occurs only
if the `=>' operator is at the top level of the formula, or
if it is part of a top-level vector.  In other words, pushing
`2 + (a => 17)' will change the 17 to the actual value of
`a' when you enter the formula, but the result will not be
dynamically updated when `a' is changed later because the
`=>' operator is buried inside a sum.  However, a vector
of `=>' operators will be recomputed, since it is convenient
to push a vector like `[a =>, b =>, c =>]' on the stack to
make a concise display of all the variables in your problem.
(Another way to do this would be to use `[a, b, c] =>',
which provides a slightly different format of display.  You
can use whichever you find easiest to read.)

The `m C' (`calc-auto-recompute') command allows you to
turn this automatic recomputation on or off.  If you turn
recomputation off, you must explicitly recompute an `=>'
operator on the stack in one of the usual ways, such as by
pressing `='.  Turning recomputation off temporarily can save
a lot of time if you will be changing several modes or variables
before you look at the `=>' entries again.

Most commands are not especially useful with `=>' operators
as arguments.  For example, given `x + 2 => 17', it won't
work to type `1 +' to get `x + 3 => 18'.  If you want
to operate on the lefthand side of the `=>' operator on
the top of the stack, type `j 1' (that's the digit "one")
to select the lefthand side, execute your commands, then type
`j u' to unselect.

All current modes apply when an `=>' operator is computed,
including the current simplification mode.  Recall that the
formula `x + y + x' is not handled by Calc's default
simplifications, but the `a s' command will reduce it to
the simpler form `y + 2 x'.  You can also type `m A'
to enable an algebraic-simplification mode in which the
equivalent of `a s' is used on all of Calc's results.
If you enter `x + y + x =>' normally, the result will
be `x + y + x => x + y + x'.  If you change to
algebraic-simplification mode, the result will be
`x + y + x => y + 2 x'.  However, just pressing `a s'
once will have no effect on `x + y + x => x + y + x',
because the righthand side depends only on the lefthand side
and the current mode settings, and the lefthand side is not
affected by commands like `a s'.

The "let" command (`s l') has an interesting interaction
with the `=>' operator.  The `s l' command evaluates the
second-to-top stack entry with the top stack entry supplying
a temporary value for a given variable.  As you might expect,
if that stack entry is an `=>' operator its righthand
side will temporarily show this value for the variable.  In
fact, all `=>'s on the stack will be updated if they refer
to that variable.  But this change is temporary in the sense
that the next command that causes Calc to look at those stack
entries will make them revert to the old variable value.

     2:  a => a             2:  a => 17         2:  a => a
     1:  a + 1 => a + 1     1:  a + 1 => 18     1:  a + 1 => a + 1
         .                      .                   .

                                17 s l a RET        p 8 RET

Here the `p 8' command changes the current precision,
thus causing the `=>' forms to be recomputed after the
influence of the "let" is gone.  The `d SPC' command
(`calc-refresh') is a handy way to force the `=>'
operators on the stack to be recomputed without any other
side effects.

Embedded Mode also uses `=>' operators.  In embedded mode,
the lefthand side of an `=>' operator can refer to variables
assigned elsewhere in the file by `:=' operators.  The
assignment operator `a := 17' does not actually do anything
by itself.  But Embedded Mode recognizes it and marks it as a sort
of file-local definition of the variable.  You can enter `:='
operators in algebraic mode, or by using the `s :'
(`calc-assign') [`assign'] command which takes a variable
and value from the stack and replaces them with an assignment.

*Note TeX Language Mode::, for the way `=>' appears in
TeX language output.  The "eqn" mode gives similar
treatment to `=>'.


File: calc.info  Node: Graphics, Prev: Store and Recall, Up: Top, Next: Kill and Yank

Graphics
********

The commands for graphing data begin with the `g' prefix key.  Calc
uses GNUPLOT 2.0 or 3.0 to do graphics.  These commands will only work
if GNUPLOT is available on your system.  (While GNUPLOT sounds like
a relative of GNU Emacs, it is actually completely unrelated.
However, it is free software and can be obtained from the Free
Software Foundation's machine `prep.ai.mit.edu'.)

If you have GNUPLOT installed on your system but Calc is unable to
find it, you may need to set the `calc-gnuplot-name' variable
in your `.emacs' file.  You may also need to set some Lisp
variables to show Calc how to run GNUPLOT on your system; these
are described under `g D' and `g O' below.  If you are
using the X window system, Calc will configure GNUPLOT for you
automatically.  If you have GNUPLOT 3.0 and you are not using X,
Calc will configure GNUPLOT to display graphs using simple character
graphics that will work on any terminal.

* Menu:

* Basic Graphics::
* Three Dimensional Graphics::
* Managing Curves::
* Graphics Options::
* Devices::


File: calc.info  Node: Basic Graphics, Prev: Graphics, Up: Graphics, Next: Three Dimensional Graphics

Basic Graphics
==============

The easiest graphics command is `g f' (`calc-graph-fast').
This command takes two vectors of equal length from the stack.
The vector at the top of the stack represents the "y" values of
the various data points.  The vector in the second-to-top position
represents the corresponding "x" values.  This command runs
GNUPLOT (if it has not already been started by previous graphing
commands) and displays the set of data points.  The points will
be connected by lines, and there will also be some kind of symbol
to indicate the points themselves.

The "x" entry may instead be an interval form, in which case suitable
"x" values are interpolated between the minimum and maximum values of
the interval (whether the interval is open or closed is ignored).

The "x" entry may also be a number, in which case Calc uses the
sequence of "x" values `x', `x+1', `x+2', etc.
(Generally the number 0 or 1 would be used for `x' in this case.)

The "y" entry may be any formula instead of a vector.  Calc effectively
uses `N' (`calc-eval-num') to evaluate variables in the formula;
the result of this must be a formula in a single (unassigned) variable.
The formula is plotted with this variable taking on the various "x"
values.  Graphs of formulas by default use lines without symbols at the
computed data points.  Note that if neither "x" nor "y" is a vector,
Calc guesses at a reasonable number of data points to use.  See the
`g N' command below.  (The "x" values must be either a vector
or an interval if "y" is a formula.)

If "y" is (or evaluates to) a formula of the form `xy(X, Y)' then the
result is a parametric plot.  The two arguments of the fictitious `xy'
function are used as the "x" and "y" coordinates of the curve,
respectively.  In this case the "x" vector or interval you specified is
not directly visible in the graph.  For example, if "x" is the interval
`[0..360]' and "y" is the formula `xy(sin(t), cos(t))', the resulting
graph will be a circle.

Also, "x" and "y" may each be variable names, in which case Calc
looks for suitable vectors, intervals, or formulas stored in those
variables.

The "x" and "y" values for the data points (as pulled from the vectors,
calculated from the formulas, or interpolated from the intervals) should
be real numbers (integers, fractions, or floats).  If either the "x"
value or the "y" value of a given data point is not a real number, that
data point will be omitted from the graph.  The points on either side
of the invalid point will *not* be connected by a line.

See the documentation for `g a' below for a description of the way
numeric prefix arguments affect `g f'.

If you store an empty vector in the variable `PlotRejects'
(i.e., `[ ] s t PlotRejects'), Calc will append information to
this vector for every data point which was rejected because its
"x" or "y" values were not real numbers.  The result will be
a matrix where each row holds the curve number, data point number,
"x" value, and "y" value for a rejected data point.
*Note Evaluates-To Operator::, for a handy way to keep tabs on the
current value of `PlotRejects'.  *Note Operations on Variables::,
for the `s R' command which is another easy way to examine
`PlotRejects'.

To clear the graphics display, type `g c' (`calc-graph-clear').
If the GNUPLOT output device is an X window, the window will go away.
Effects on other kinds of output devices will vary.  You don't need
to use `g c' if you don't want to---if you give another `g f'
or `g p' command later on, it will reuse the existing graphics
window if there is one.


File: calc.info  Node: Three Dimensional Graphics, Prev: Basic Graphics, Up: Graphics, Next: Managing Curves

Three Dimensional Graphics
==========================

The `g F' (`calc-graph-fast-3d') command makes a three-dimensional
graph.  It works only if you have GNUPLOT 3.0 or later; with GNUPLOT 2.0,
you will see a GNUPLOT error message if you try this command.

The `g F' command takes three values from the stack, called "x",
"y", and "z", respectively.  As was the case for 2D graphs, there
are several options for these values.

In the first case, "x" and "y" are each vectors (not necessarily of
the same length); either or both may instead be interval forms.  The
"z" value must be a matrix with the same number of rows as elements
in "x", and the same number of columns as elements in "y".  The
result is a surface plot where `z_ij' is the height of the point
at coordinate `(x_i, y_j)' on the surface.  The 3D graph will
be displayed from a certain default viewpoint; you can change this
viewpoint by adding a `set view' to the `*Gnuplot Commands*'
buffer as described later.  See the GNUPLOT documentation for a
description of the `set view' command.

Each point in the matrix will be displayed as a dot in the graph,
and these points will be connected by a grid of lines ("isolines").

In the second case, "x", "y", and "z" are all vectors of equal
length.  The resulting graph displays a 3D line instead of a surface,
where the coordinates of points along the line are successive triplets
of values from the input vectors.

In the third case, "x" and "y" are vectors or interval forms, and
"z" is any formula involving two variables (not counting variables
with assigned values).  These variables are sorted into alphabetical
order; the first takes on values from "x" and the second takes on
values from "y" to form a matrix of results that are graphed as a
3D surface.

If the "z" formula evaluates to a call to the fictitious function
`xyz(X, Y, Z)', then the result is a
"parametric surface."  In this case, the axes of the graph are
taken from the X and Y values in these calls, and the
"x" and "y" values from the input vectors or intervals are used
only to generate inputs to the formula.  For example, plotting
`[0..360], [0..180], xyz(sin(x)*sin(y), cos(x)*sin(y), cos(y))'
will draw a sphere.  (Since the default resolution for 3D plots is
5 steps in each of "x" and "y", this will draw a very crude
sphere.  You could use the `g N' command, described below, to
increase this resolution, or specify the "x" and "y" values as
vectors with more than 5 components.)

It is also possible to have a function in a regular `g f' plot
evaluate to an `xyz' call.  Since `g f' plots a line, not
a surface, the result will be 3D parametric line.  For example,
`[[0..720], xyz(sin(x), cos(x), x)]' will plot two turns of a
helix (a three-dimensional spiral).

As for `g f', each of "x", "y", and "z" may instead be
variables containing the relevant data.


File: calc.info  Node: Managing Curves, Prev: Three Dimensional Graphics, Up: Graphics, Next: Graphics Options

Managing Curves
===============

The `g f' command is really shorthand for the following commands:
`C-u g d  g a  g p'.  Likewise, `g F' is shorthand for
`C-u g d  g A  g p'.  You can gain more control over your graph
by using these commands directly.

The `g a' (`calc-graph-add') command adds the "curve"
represented by the two values on the top of the stack to the current
graph.  You can have any number of curves in the same graph.  When
you give the `g p' command, all the curves will be drawn superimposed
on the same axes.

The `g a' command (and many others that affect the current graph)
will cause a special buffer, `*Gnuplot Commands*', to be displayed
in another window.  This buffer is a template of the commands that will
be sent to GNUPLOT when it is time to draw the graph.  The first
`g a' command adds a `plot' command to this buffer.  Succeeding
`g a' commands add extra curves onto that `plot' command.
Other graph-related commands put other GNUPLOT commands into this
buffer.  In normal usage you never need to work with this buffer
directly, but you can if you wish.  The only constraint is that there
must be only one `plot' command, and it must be the last command
in the buffer.  If you want to save and later restore a complete graph
configuration, you can use regular Emacs commands to save and restore
the contents of the `*Gnuplot Commands*' buffer.

If the values on the stack are not variable names, `g a' will invent
variable names for them (of the form `PlotDataN') and store
the values in those variables.  The "x" and "y" variables are what
go into the `plot' command in the template.  If you add a curve
that uses a certain variable and then later change that variable, you
can replot the graph without having to delete and re-add the curve.
That's because the variable name, not the vector, interval or formula
itself, is what was added by `g a'.

A numeric prefix argument on `g a' or `g f' changes the way
stack entries are interpreted as curves.  With a positive prefix
argument `n', the top `n' stack entries are "y" values
for `n' different curves which share a common "x" value in
the `n+1'st stack entry.  (Thus `g a' with no prefix
argument is equivalent to `C-u 1 g a'.)

A prefix of zero or plain `C-u' means to take two stack entries,
"x" and "y" as usual, but to interpret "y" as a vector of
"y" values for several curves that share a common "x".

A negative prefix argument tells Calc to read `n' vectors from
the stack; each vector `[x, y]' describes an independent curve.
This is the only form of `g a' that creates several curves at once
that don't have common "x" values.  (Of course, the range of "x"
values covered by all the curves ought to be roughly the same if
they are to look nice on the same graph.)

For example, to plot `sin(n x)' for integers `n'
from 1 to 5, you could use `v x' to create a vector of integers
(`n'), then `V M '' or `V M $' to map `sin(n x)'
across this vector.  The resulting vector of formulas is suitable
for use as the "y" argument to a `C-u g a' or `C-u g f'
command.

The `g A' (`calc-graph-add-3d') command adds a 3D curve
to the graph.  It is not legal to intermix 2D and 3D curves in a
single graph.  This command takes three arguments, "x", "y",
and "z", from the stack.  With a positive prefix `n', it
takes `n+2' arguments (common "x" and "y", plus `n'
separate "z"s).  With a zero prefix, it takes three stack entries
but the "z" entry is a vector of curve values.  With a negative
prefix `-n', it takes `n' vectors of the form `[x, y, z]'.
The `g A' command works by adding a `splot' (surface-plot)
command to the `*Gnuplot Commands*' buffer.

(Although `g a' adds a 2D `plot' command to the
`*Gnuplot Commands*' buffer, Calc changes this to `splot'
before sending it to GNUPLOT if it notices that the data points are
evaluating to `xyz' calls.  It will not work to mix 2D and 3D
`g a' curves in a single graph, although Calc does not currently
check for this.)

The `g d' (`calc-graph-delete') command deletes the most
recently added curve from the graph.  It has no effect if there are
no curves in the graph.  With a numeric prefix argument of any kind,
it deletes all of the curves from the graph.

The `g H' (`calc-graph-hide') command "hides" or "unhides"
the most recently added curve.  A hidden curve will not appear in
the actual plot, but information about it such its name and line and
point styles will be retained.

The `g j' (`calc-graph-juggle') command moves the curve
at the end of the list (the "most recently added curve") to the
front of the list.  The next-most-recent curve is thus exposed for
`g d' or similar commands to use.  With `g j' you can work
with any curve in the graph even though curve-related commands only
affect the last curve in the list.

The `g p' (`calc-graph-plot') command uses GNUPLOT to draw
the graph described in the `*Gnuplot Commands*' buffer.  Any
GNUPLOT parameters which are not defined by commands in this buffer
are reset to their default values.  The variables named in the `plot'
command are written to a temporary data file and the variable names
are then replaced by the file name in the template.  The resulting
plotting commands are fed to the GNUPLOT program.  See the documentation
for the GNUPLOT program for more specific information.  All temporary
files are removed when Emacs or GNUPLOT exits.

If you give a formula for "y", Calc will remember all the values that
it calculates for the formula so that later plots can reuse these values.
Calc throws out these saved values when you change any circumstances
that may affect the data, such as switching from Degrees to Radians
mode, or changing the value of a parameter in the formula.  You can
force Calc to recompute the data from scratch by giving a negative
numeric prefix argument to `g p'.

Calc uses a fairly rough step size when graphing formulas over intervals.
This is to ensure quick response.  You can "refine" a plot by giving
a positive numeric prefix argument to `g p'.  Calc goes through
the data points it has computed and saved from previous plots of the
function, and computes and inserts a new data point midway between
each of the existing points.  You can refine a plot any number of times,
but beware that amount of calculation involved doubles each time.

Calc does not remember computed values for 3D graphs.  This means the
numerix prefix argument, if any, to `g p' is effectively ignored if
the current graph is three-dimensional.

The `g P' (`calc-graph-print') command is like `g p',
except that it sends the output to a printer instead of to the
screen.  More precisely, `g p' looks for `set terminal'
or `set output' commands in the `*Gnuplot Commands*' buffer;
lacking these it uses the default settings.  However, `g P'
ignores `set terminal' and `set output' commands and
uses a different set of default values.  All of these values are
controlled by the `g D' and `g O' commands discussed below.
Provided everything is set up properly, `g p' will plot to
the screen unless you have specified otherwise and `g P' will
always plot to the printer.


File: calc.info  Node: Graphics Options, Prev: Managing Curves, Up: Graphics, Next: Devices

Graphics Options
================

The `g g' (`calc-graph-grid') command turns the "grid"
on and off.  It is off by default; tick marks appear only at the
edges of the graph.  With the grid turned on, dotted lines appear
across the graph at each tick mark.  Note that this command only
changes the setting in `*Gnuplot Commands*'; to see the effects
of the change you must give another `g p' command.

The `g b' (`calc-graph-border') command turns the border
(the box that surrounds the graph) on and off.  It is on by default.
This command will only work with GNUPLOT 3.0 and later versions.

The `g k' (`calc-graph-key') command turns the "key"
on and off.  The key is a chart in the corner of the graph that
shows the correspondence between curves and line styles.  It is
off by default, and is only really useful if you have several
curves on the same graph.

The `g N' (`calc-graph-num-points') command allows you
to select the number of data points in the graph.  This only affects
curves where neither "x" nor "y" is specified as a vector.
Enter a blank line to revert to the default value (initially 15).
With a positive prefix argument this command changes or, if you enter
a blank line, displays the default number of points used for all
graphs created by `g a' that don't specify the resolution explicitly.
With a negative prefix argument, this command changes or displays
the default value (initially 5) used for 3D graphs created by `g A'.
Note that a 3D setting of 5 means that a total of `5^2 = 25' points
will be computed for the surface.

Data points in the graph of a function are normally computed to a
precision of five digits, regardless of the current precision at the
time. This is usually more than adequate, but there are cases where
it will not be.  For example, plotting `1 + x' for `x' in the
interval `[0 .. 1e-6]' will round all the data points down
to 1.0!  Putting the command `set precision N' in the
`*Gnuplot Commands*' buffer will cause the data to be computed
at precision N instead of 5.  Since this is such a rare case,
there is no keystroke-based command to set the precision.

The `g h' (`calc-graph-header') command sets the title
for the graph.  This will show up centered above the graph.
The default title is blank (no title).

The `g n' (`calc-graph-name') command sets the title of an
individual curve.  Like the other curve-manipulating commands, it
affects the most recently added curve, i.e., the last curve on the
list in the `*Gnuplot Commands*' buffer.  To set the title of
the other curves you must first juggle them to the end of the list
with `g j', or edit the `*Gnuplot Commands*' buffer by hand.
Curve titles appear in the key; if the key is turned off they are
not used.

The `g t' (`calc-graph-title-x') and `g T'
(`calc-graph-title-y') commands set the titles on the "x"
and "y" axes, respectively.  These titles appear next to the
tick marks on the left and bottom edges of the graph, respectively.
Calc does not have commands to control the tick marks themselves,
but you can edit them into the `*Gnuplot Commands*' buffer if
you wish.  See the GNUPLOT documentation for details.

The `g r' (`calc-graph-range-x') and `g R'
(`calc-graph-range-y') commands set the range of values on the
"x" and "y" axes, respectively.  You are prompted to enter a
suitable range.  This should be either a pair of numbers of the
form, `MIN:MAX', or a blank line to revert to the
default behavior of setting the range based on the range of values
in the data, or `$' to take the range from the top of the stack.
Ranges on the stack can be represented as either interval forms or
vectors:  `[MIN .. MAX]' or `[MIN, MAX]'.

The `g l' (`calc-graph-log-x') and `g L' (`calc-graph-log-y')
commands allow you to set either or both of the axes of the graph to
be logarithmic instead of linear.

For 3D plots, `g C-t', `g C-r', and `g C-l' (those are
letters with the Control key held down) are the corresponding commands
for the Z axis.

The `g z' (`calc-graph-zero-x') and `g Z'
(`calc-graph-zero-y') commands control whether a dotted line is
drawn to indicate the "x" and/or "y" zero axes.  (These are the same
dotted lines that would be drawn there anyway if you used `g g' to
turn the "grid" feature on.)  Zero-axis lines are on by default, and
may be turned off only in GNUPLOT 3.0 and later versions.  They are
not available for 3D plots.

The `g s' (`calc-graph-line-style') command turns the connecting
lines on or off for the most recently added curve, and optionally selects
the style of lines to be used for that curve.  Plain `g s' simply
toggles the lines on and off.  With a numeric prefix argument, `g s'
turns lines on and sets a particular line style.  Line style numbers
start at one and their meanings vary depending on the output device.
GNUPLOT guarantees that there will be at least six different line styles
available for any device.

The `g S' (`calc-graph-point-style') command similarly turns
the symbols at the data points on or off, or sets the point style.
If you turn both lines and points off, the data points will show as
tiny dots.

Another way to specify curve styles is with the `LineStyles' and
`PointStyles' variables.  These variables initially have no stored
values, but if you store a vector of integers in one of these variables,
the `g a' and `g f' commands will use those style numbers
instead of the defaults for new curves that are added to the graph.
An entry should be a positive integer for a specific style, or 0 to
let the style be chosen automatically, or -1 to turn off lines or points
altogether.  If there are more curves than elements in the vector, the
last few curves will continue to have the default styles.  Of course,
you can later use `g s' and `g S' to change any of these styles.

For example, `'[2 -1 3] RET s t LineStyles' causes the first curve
to have lines in style number 2, the second curve to have no connecting
lines, and the third curve to have lines in style 3.  Point styles will
still be assigned automatically, but you could store another vector in
`PointStyles' to define them, too.


File: calc.info  Node: Devices, Prev: Graphics Options, Up: Graphics

Graphical Devices
=================

The `g D' (`calc-graph-device') command sets the device name
(or "terminal name" in GNUPLOT lingo) to be used by `g p' commands
on this graph.  It does not affect the permanent default device name.
If you enter a blank name, the device name reverts to the default.
Enter `?' to see a list of supported devices.

With a positive numeric prefix argument, `g D' instead sets
the default device name, used by all plots in the future which do
not override it with a plain `g D' command.  If you enter a
blank line this command shows you the current default.  The special
name `default' signifies that Calc should choose `x11' if
the X window system is in use (as indicated by the presence of a
`DISPLAY' environment variable), or otherwise `dumb' under
GNUPLOT 3.0 and later, or `postscript' under GNUPLOT 2.0.
This is the initial default value.

The `dumb' device is an interface to "dumb terminals," i.e.,
terminals with no special graphics facilities.  It writes a crude
picture of the graph composed of characters like `-' and `|'
to a buffer called `*Gnuplot Trail*', which Calc then displays.
The graph is made the same size as the Emacs screen, which on most
dumb terminals will be 80x24 characters.  The graph is displayed in
an Emacs "recursive edit"; type `q' or `M-# M-#' to exit
the recursive edit and return to Calc.  Note that the `dumb'
device is present only in GNUPLOT 3.0 and later versions.

The word `dumb' may be followed by two numbers separated by
spaces.  These are the desired width and height of the graph in
characters.  Also, the device name `big' is like `dumb'
but creates a graph four times the width and height of the Emacs
screen.  You will then have to scroll around to view the entire
graph.  In the `*Gnuplot Trail*' buffer, SPC, DEL,
`<', and `>' are defined to scroll by one screenful in each
of the four directions.

With a negative numeric prefix argument, `g P' sets or displays
the device name used by `g P' (`calc-graph-print').  This
is initially `postscript'.  If you don't have a PostScript
printer, you may decide once again to use `dumb' to create a
plot on any text-only printer.

The `g O' (`calc-graph-output') command sets the name of
the output file used by GNUPLOT.  For some devices, notably `x11',
there is no output file and this information is not used.  Many other
"devices" are really file formats like `postscript'; in these
cases the output in the desired format goes into the file you name
with `g O'.  Type `g O stdout RET' to set GNUPLOT to write
to its standard output stream, i.e., to `*Gnuplot Trail*'.
This is the default setting.

Another special output name is `tty', which means that GNUPLOT
is going to write graphics commands directly to its standard output,
which you wish Emacs to pass through to your terminal.  Tektronix
graphics terminals, among other devices, operate this way.  Calc does
this by telling GNUPLOT to write to a temporary file, then running a
sub-shell executing the command `cat tempfile >/dev/tty'.  On
typical Unix systems, this will copy the temporary file directly to
the terminal, bypassing Emacs entirely.  You will have to type `C-l'
to Emacs afterwards to refresh the screen.

Once again, `g O' with a positive or negative prefix argument
sets the default or printer output file names, respectively.  In each
case you can specify `auto', which causes Calc to invent a temporary
file name for each `g p' (or `g P') command.  This temporary file
will be deleted once it has been displayed or printed.  If the output file
name is not `auto', the file is not automatically deleted.

The default and printer devices and output files can be saved
permanently by the `m m' (`calc-save-modes') command.  The
default number of data points (see `g N') and the X geometry
(see `g X') are also saved.  Other graph information is *not*
saved; you can save a graph's configuration simply by saving the contents
of the `*Gnuplot Commands*' buffer.

If you are installing Calc you may wish to configure the default and
printer devices and output files for the whole system.  The relevant
Lisp variables are `calc-gnuplot-default-device' and `-output',
and `calc-gnuplot-print-device' and `-output'.  The output
file names must be either strings as described above, or Lisp
expressions which are evaluated on the fly to get the output file name.

Other important Lisp variables are `calc-gnuplot-plot-command' and
`calc-gnuplot-print-command', which give the system commands to
display or print the output of GNUPLOT, respectively.  These may be
`nil' if no command is necessary, or strings which can include
`%s' to signify the name of the file to be displayed or printed.
Or, these variables may contain Lisp expressions which are evaluated
to display or print the output.

The `g x' (`calc-graph-display') command lets you specify
on which X window system display your graphs should be drawn.  Enter
a blank line to see the current display name.  This command has no
effect unless the current device is `x11'.

The `g X' (`calc-graph-geometry') command is a similar
command for specifying the position and size of the X window.
The normal value is `default', which generally means your
window manager will let you place the window interactively.
Entering `800x500+0+0' would create an 800-by-500 pixel
window in the upper-left corner of the screen.

The buffer called `*Gnuplot Trail*' holds a transcript of the
session with GNUPLOT.  This shows the commands Calc has "typed" to
GNUPLOT and the responses it has received.  Calc tries to notice when an
error message has appeared here and display the buffer for you when
this happens.  You can check this buffer yourself if you suspect
something has gone wrong.

The `g C' (`calc-graph-command') command prompts you to
enter any line of text, then simply sends that line to the current
GNUPLOT process.  The `*Gnuplot Trail*' buffer looks deceptively
like a Shell buffer but you can't type commands in it yourself.
Instead, you must use `g C' for this purpose.

The `g v' (`calc-graph-view-commands') and `g V'
(`calc-graph-view-trail') commands display the `*Gnuplot Commands*'
and `*Gnuplot Trail*' buffers, respectively, in another window.
This happens automatically when Calc thinks there is something you
will want to see in either of these buffers.  If you type `g v'
or `g V' when the relevant buffer is already displayed, the
buffer is hidden again.

One reason to use `g v' is to add your own commands to the
`*Gnuplot Commands*' buffer.  Press `g v', then use
`C-x o' to switch into that window.  For example, GNUPLOT has
`set label' and `set arrow' commands that allow you to
annotate your plots.  Since Calc doesn't understand these commands,
you have to add them to the `*Gnuplot Commands*' buffer
yourself, then use `g p' to replot using these new commands.  Note
that your commands must appear *before* the `plot' command.
To get help on any GNUPLOT feature, type, e.g., `g C help set label'.
You may have to type `g C RET' a few times to clear the
"press return for more" or "subtopic of ..." requests.
Note that Calc always sends commands (like `set nolabel') to
reset all plotting parameters to the defaults before each plot, so
to delete a label all you need to do is delete the `set label'
line you added (or comment it out with `#') and then replot
with `g p'.

You can use `g q' (`calc-graph-quit') to kill the GNUPLOT
process that is running.  The next graphing command you give will
start a fresh GNUPLOT process.  The word `Graph' appears in
the Calc window's mode line whenever a GNUPLOT process is currently
running.  The GNUPLOT process is automatically killed when you
exit Emacs if you haven't killed it manually by then.

The `g K' (`calc-graph-kill') command is like `g q'
except that it also views the `*Gnuplot Trail*' buffer so that
you can see the process being killed.  This is better if you are
killing GNUPLOT because you think it has gotten stuck.


File: calc.info  Node: Kill and Yank, Prev: Graphics, Up: Top, Next: Keypad Mode

Kill and Yank Functions
***********************

The commands in this chapter move information between the Calculator and
other Emacs editing buffers.

In many cases Embedded Mode is an easier and more natural way to
work with Calc from a regular editing buffer.  *Note Embedded Mode::.

* Menu:

* Killing From Stack::
* Yanking Into Stack::
* Grabbing From Buffers::
* Yanking Into Buffers::
* X Cut and Paste::
* Editing Stack Entries::


File: calc.info  Node: Killing From Stack, Prev: Kill and Yank, Up: Kill and Yank, Next: Yanking Into Stack

Killing from the Stack
======================

"Kill" commands are Emacs commands that insert text into the
"kill ring," from which it can later be "yanked" by a `C-y'
command.  Three common kill commands in normal Emacs are `C-k', which
kills one line, `C-w', which kills the region between mark and point,
and `M-w', which puts the region into the kill ring without actually
deleting it.  All of these commands work in the Calculator, too.  Also,
`M-k' has been provided to complete the set; it puts the current line
into the kill ring without deleting anything.

The kill commands are unusual in that they pay attention to the location
of the cursor in the Calculator buffer.  If the cursor is on or below the
bottom line, the kill commands operate on the top of the stack.  Otherwise,
they operate on whatever stack element the cursor is on.  Calc's kill
commands always operate on whole stack entries.  (They act the same as their
standard Emacs cousins except they "round up" the specified region to
encompass full lines.)  The text is copied into the kill ring exactly as
it appears on the screen, including line numbers if they are enabled.

A numeric prefix argument to `C-k' or `M-k' affects the number
of lines killed.  A positive argument kills the current line and `n-1'
lines below it.  A negative argument kills the `-n' lines above the
current line.  Again this mirrors the behavior of the standard Emacs
`C-k' command.  Although a whole line is always deleted, `C-k'
with no argument copies only the number itself into the kill ring, whereas
`C-k' with a prefix argument of 1 copies the number with its trailing
newline.


File: calc.info  Node: Yanking Into Stack, Prev: Killing From Stack, Up: Kill and Yank, Next: Grabbing From Buffers

Yanking into the Stack
======================

The `C-y' command yanks the most recently killed text back into the
Calculator.  It pushes this value onto the top of the stack regardless of
the cursor position.  In general it re-parses the killed text as a number
or formula (or list of these separated by commas or newlines).  However if
the thing being yanked is something that was just killed from the Calculator
itself, its full internal structure is yanked.  For example, if you have
set the floating-point display mode to show only four significant digits,
then killing and re-yanking 3.14159 (which displays as 3.142) will yank the
full 3.14159, even though yanking it into any other buffer would yank the
number in its displayed form, 3.142.  (Since the default display modes
show all objects to their full precision, this feature normally makes no
difference.)


File: calc.info  Node: Grabbing From Buffers, Prev: Yanking Into Stack, Up: Kill and Yank, Next: Yanking Into Buffers

Grabbing from Other Buffers
===========================

The `M-# g' (`calc-grab-region') command takes the text between
point and mark in the current buffer and attempts to parse it as a
vector of values.  Basically, it wraps the text in vector brackets
`[ ]' unless the text already is enclosed in vector brackets,
then reads the text as if it were an algebraic entry.  The contents
of the vector may be numbers, formulas, or any other Calc objects.

A numeric prefix argument grabs the specified number of lines around
point, ignoring the mark.  A positive prefix grabs from point to the
`n'th following newline (so that `M-1 M-# g' grabs from point
to the end of the current line); a negative prefix grabs from points
back to the `n+1'st preceding newline.  In both cases, the text
that is grabbed is exactly the same as the text that `C-k' would
delete given that prefix argument.

A prefix of zero grabs the current line; point may be anywhere on the
line.

A plain `C-u' prefix interprets the region between point and mark
as a single number or formula rather than a vector.  For example,
`M-# g' on the text `2 a b' produces the vector of three
values `[2, a, b]', but `C-u M-# g' on the same region
reads a formula which is a product of three things:  `2 a b'.

If a different language has been specified (*Note Language Modes::),
the grabbed text will be interpreted according to that language.
If the `M-# g' command works successfully, it does an automatic
`M-# c' to enter the Calculator buffer.

The `M-# r' (`calc-grab-rectangle') command takes the text between
point and mark and attempts to parse it as a matrix.  If point and mark
are both in the leftmost column, the lines in between are parsed in their
entirety.  Otherwise, point and mark define the corners of a rectangle
whose contents are parsed.

Each line of the grabbed area becomes a row of the matrix.  The result
will actually be a vector of vectors, which Calc will treat as a matrix
only if every row contains the same number of values.

If a line contains a portion surrounded by square brackets (or curly
braces), that portion is interpreted as a vector which becomes a row
of the matrix.  Any text surrounding the bracketed portion on the line
is ignored.

Otherwise, the entire line is interpreted as a row vector as if it
were surrounded by square brackets.  Leading line numbers (in the
format used in the Calc stack buffer) are ignored.  If you wish to
force this interpretation (even if the line contains bracketed
portions), give a negative numeric prefix argument to the
`M-# r' command.

If you give a numeric prefix argument of zero or plain `C-u', each
line is instead interpreted as a single formula which is converted into
a one-element vector.  Thus the result of `C-u M-# r' will be a
one-column matrix.  For example, suppose one line of the data is the
expression `2 a'.  A plain `M-# r' will interpret this as
`[2 a]', which in turn is read as a two-element vector that forms
one row of the matrix.  But a `C-u M-# r' will interpret this row
as `[2*a]'.

If you give a positive numeric prefix argument N, then each line
will be split up into columns of width N; each column is parsed
separately as a matrix element.  If a line contained `2 +/- 3 4 +/- 5',
then grabbing with a prefix argument of 8 would correctly split the
line into two error forms.

*Note Matrix Functions::, to see how to pull the matrix apart into its
constituent rows and columns.  (If it is a 1x1 matrix, just hit `v u'
(`calc-unpack') twice.)

The `M-# :' (`calc-grab-sum-down') command is a handy way to
grab a rectangle of data and sum its columns.  It is equivalent to
typing `M-# r', followed by `V R : +' (the vector reduction
command that sums the columns of a matrix; *Note Reducing::).  The
result of the command will be a vector of numbers, one for each column
in the input data.  The `M-# _' (`calc-grab-sum-across') command
similarly grabs a rectangle and sums its rows by executing `V R _ +'.

For example, suppose we have a column of numbers in a file which we
wish to sum.  Go to one corner of the column and press `C-@' to
set the mark; go to the other corner and type `M-# :'.  Since there
is only one column, the result will be a vector of one number, the sum.
(You can type `v u' to unpack this vector into a plain number if
you want to do further arithmetic with it.)

To compute the product of the column of numbers, we would have to do
it "by hand" since there's no special grab-and-multiply command.
Use `M-# r' to grab the column of numbers into the calculator in
the form of a column matrix.  The statistics command `u *' is a
handy way to find the product of a vector or matrix of numbers.
*Note Statistical Operations::.  Another approach would be to use
general-purpose vector commands, like `v t' to transpose the data
into a row matrix, `v u' to unpack this into a simple vector
(recall, a one-row matrix is a vector of a single vector), and
`V R *' to compute the product of the vector.


File: calc.info  Node: Yanking Into Buffers, Prev: Grabbing From Buffers, Up: Kill and Yank, Next: X Cut and Paste

Yanking into Other Buffers
==========================

The plain `y' (`calc-copy-to-buffer') command inserts the number
at the top of the stack into the most recently used normal editing buffer.
(More specifically, this is the most recently used buffer which is displayed
in a window and whose name does not begin with `*'.  If there is no
such buffer, this is the most recently used buffer except for Calculator
and Calc Trail buffers.)  The number is inserted exactly as it appears and
without a newline.  (If line-numbering is enabled, the line number is
normally not included.)  The number is *not* removed from the stack.

With a prefix argument, `y' inserts several numbers, one per line.
A positive argument inserts the specified number of values from the top
of the stack.  A negative argument inserts the `n'th value from the
top of the stack.  An argument of zero inserts the entire stack.  Note
that `y' with an argument of 1 is slightly different from `y'
with no argument; the former always copies full lines, whereas the
latter strips off the trailing newline.

With a lone `C-u' as a prefix argument, `y' *replaces* the region in the
other buffer with the yanked text, then quits the Calculator, leaving
you in that buffer.  A typical use would be to use `M-# g' to read a
region of data into the Calculator, operate on the data to produce a new
matrix, then type `C-u y' to replace the original data with the new
data.  One might wish to alter the matrix display style (*Note Vector
and Matrix Formats::) or change the current display language (*Note
Language Modes::) before doing this.  Also, note that this command
replaces a linear region of text (as grabbed by `M-# g', not a rectangle
(as grabbed by `M-# r'.

If the editing buffer is in overwrite (as opposed to insert) mode,
and the `C-u' prefix was not used, then the yanked number will
overwrite the characters following point rather than being inserted
before those characters.  The usual conventions of overwrite mode
are observed; for example, characters will be inserted at the end of
a line rather than overflowing onto the next line.  Yanking a multi-line
object such as a matrix in overwrite mode overwrites the next N
lines in the buffer, lengthening or shortening each line as necessary.
Finally, if the thing being yanked is a simple integer or floating-point
number (like `-1.2345e-3') and the characters following point also
make up such a number, then Calc will replace that number with the new
number, lengthening or shortening as necessary.  The concept of
"overwrite mode" has thus been generalized from overwriting characters
to overwriting one complete number with another.

The `M-# y' key sequence is equivalent to `y' except that
it can be typed anywhere, not just in Calc.  This provides an easy
way to guarantee that Calc knows which editing buffer you want to use!


