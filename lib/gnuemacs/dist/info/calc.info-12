Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: Binary Functions, Prev: Financial Functions, Up: Arithmetic

Binary Number Functions
=======================

The commands in this chapter all use two-letter sequences beginning with
the `b' prefix.

The "binary" operations actually work regardless of the currently
displayed radix, although their results make the most sense in a radix
like 2, 8, or 16 (as obtained by the `d 2', `d 8', or `d 6'
commands, respectively).  You may also wish to enable display of leading
zeros with `d z'.  *Note Radix Modes::.

The Calculator maintains a current "word size" `w', an arbitrary
positive or negative integer.  For a positive word size, all of the
binary operations described here operate modulo `2^w'.  In particular,
negative arguments are converted to positive integers modulo `2^w' by
all binary functions.

If the word size is negative, binary operations produce 2's complement
integers from `-(2^(-w-1))' to `2^(-w-1)-1' inclusive.  Either
mode accepts inputs in any range; the sign of `w' affects only
the results produced.

The `b c' (`calc-clip') [`clip'] command can be used to clip a number by
reducing it modulo `2^w'.  The commands described in this chapter
automatically clip their results to the current word size.  Note that
other operations like addition do not use the current word size, since
integer addition generally is not "binary."  (However, *Note
Simplification Modes::, `calc-bin-simplify-mode'.)  For example, with a
word size of 8 bits `b c' converts a number to the range 0 to 255; with
a word size of -8 `b c' converts to the range -128 to 127.

The default word size is 32 bits.  All operations except the shifts and
rotates allow you to specify a different word size for that one
operation by giving a numeric prefix argument:  `C-u 8 b c' clips the
top of stack to the range 0 to 255 regardless of the current word size.
To set the word size permanently, use `b w' (`calc-word-size').
This command displays a prompt with the current word size; press RET
immediately to keep this word size, or type a new word size at the prompt.

When the binary operations are written in symbolic form, they take an
optional second (or third) word-size parameter.  When a formula like
`and(a,b)' is finally evaluated, the word size current at that time
will be used, but when `and(a,b,-8)' is evaluated, a word size of
-8 will always be used.  A symbolic binary function will be left
in symbolic form unless the all of its argument(s) are integers or
integer-valued floats.

If either or both arguments are modulo forms for which `M' is a
power of two, that power of two is taken as the word size unless a
numeric prefix argument overrides it.  The current word size is never
consulted when modulo-power-of-two forms are involved.

The `b a' (`calc-and') [`and'] command computes the bitwise
AND of the two numbers on the top of the stack.  In other words, for each
of the `w' binary digits of the two numbers (pairwise), the corresponding
bit of the result is 1 if and only if both input bits are 1:
`and(2#1100, 2#1010) = 2#1000'.

The `b o' (`calc-or') [`or'] command computes the bitwise
inclusive OR of two numbers.  A bit is 1 if either of the input bits, or
both, are 1:  `or(2#1100, 2#1010) = 2#1110'.

The `b x' (`calc-xor') [`xor'] command computes the bitwise
exclusive OR of two numbers.  A bit is 1 if exactly one of the input bits
is 1:  `xor(2#1100, 2#1010) = 2#0110'.

The `b d' (`calc-diff') [`diff'] command computes the bitwise
difference of two numbers; this is defined by `diff(a,b) = and(a,not(b))',
so that `diff(2#1100, 2#1010) = 2#0100'.

The `b n' (`calc-not') [`not'] command computes the bitwise
NOT of a number.  A bit is 1 if the input bit is 0 and vice-versa.

The `b l' (`calc-lshift-binary') [`lsh'] command shifts a
number left by one bit, or by the number of bits specified in the numeric
prefix argument.  A negative prefix argument performs a logical right shift,
in which zeros are shifted in on the left.  In symbolic form, `lsh(a)'
is short for `lsh(a,1)', which in turn is short for `lsh(a,n,w)'.
Bits shifted "off the end," according to the current word size, are lost.

The `H b l' command also does a left shift, but it takes two arguments
from the stack (the value to shift, and, at top-of-stack, the number of
bits to shift).  This version interprets the prefix argument just like
the regular binary operations, i.e., as a word size.  The Hyperbolic flag
has a similar effect on the rest of the binary shift and rotate commands.

The `b r' (`calc-rshift-binary') [`rsh'] command shifts a
number right by one bit, or by the number of bits specified in the numeric
prefix argument:  `rsh(a,n) = lsh(a,-n)'.

The `b L' (`calc-lshift-arith') [`ash'] command shifts a
number left.  It is analogous to `lsh', except that if the shift
is rightward (the prefix argument is negative), an arithmetic shift
is performed as described below.

The `b R' (`calc-rshift-arith') [`rash'] command performs
an "arithmetic" shift to the right, in which the leftmost bit (according
to the current word size) is duplicated rather than shifting in zeros.
This corresponds to dividing by a power of two where the input is interpreted
as a signed, twos-complement number.  (The distinction between the `rsh'
and `rash' operations is totally independent from whether the word
size is positive or negative.)  With a negative prefix argument, this
performs a standard left shift.

The `b t' (`calc-rotate-binary') [`rot'] command rotates a
number one bit to the left.  The leftmost bit (according to the current
word size) is dropped off the left and shifted in on the right.  With a
numeric prefix argument, the number is rotated that many bits to the left
or right.

*Note Set Operations::, for the `b p' and `b u' commands that
pack and unpack binary integers into sets.  (For example, `b u'
unpacks the number `2#11001' to the set of bit-numbers
`[0, 3, 4]'.)  Type `b u V #' to count the number of "1"
bits in a binary integer.

Another interesting use of the set representation of binary integers
is to reverse the bits in, say, a 32-bit integer.  Type `b u' to
unpack; type `31 TAB -' to replace each bit-number in the set
with 31 minus that bit-number; type `b p' to pack the set back
into a binary integer.


File: calc.info  Node: Scientific Functions, Prev: Arithmetic, Up: Top, Next: Matrix Functions

Scientific Functions
********************

The functions described here perform trigonometric and other transcendental
calculations.  They generally produce floating-point answers correct to the
full current precision.  The `H' (Hyperbolic) and `I' (Inverse)
flag keys must be used to get some of these functions from the keyboard.

One miscellanous command is shift-`P' (`calc-pi'), which pushes the
value of `pi' (at the current precision) onto the stack.  With the
Hyperbolic flag, it pushes the value `e', the base of natural
logarithms.  With the Inverse flag, it pushes Euler's constant `gamma'
(about 0.577).  With both Inverse and Hyperbolic, it pushes the "golden
ratio" `phi' (about 1.618).  (At present, Euler's constant is not
available to unlimited precision; Calc knows only the first 100 digits.)
In Symbolic mode, these commands push the actual variables `pi', `e',
`gamma', and `phi', respectively, instead of their values; *Note
Symbolic Mode::.

The `Q' (`calc-sqrt') [`sqrt'] function is described elsewhere;
*Note Basic Arithmetic::.  With the Inverse flag [`sqr'], this command
computes the square of the argument.

*Note Prefix Arguments::, for a discussion of the effect of numeric
prefix arguments on commands in this chapter which do not otherwise
interpret a prefix argument.

* Menu:

* Logarithmic Functions::
* Trigonometric and Hyperbolic Functions::
* Advanced Math Functions::
* Branch Cuts::
* Random Numbers::
* Combinatorial Functions::
* Probability Distribution Functions::


File: calc.info  Node: Logarithmic Functions, Prev: Scientific Functions, Up: Scientific Functions, Next: Trigonometric and Hyperbolic Functions

Logarithmic Functions
=====================

The shift-`L' (`calc-ln') [`ln'] command computes the natural
logarithm of the real or complex number on the top of the stack.  With
the Inverse flag it computes the exponential function instead, although
this is redundant with the `E' command.

The shift-`E' (`calc-exp') [`exp'] command computes the
exponential, i.e., `e' raised to the power of the number on the stack.
The meanings of the Inverse and Hyperbolic flags follow from those for
the `calc-ln' command.

The `H L' (`calc-log10') [`log10'] command computes the common
(base-10) logarithm of a number.  The meanings of the Inverse [`exp10']
and Hyperbolic flags follow from those for the `L' command.  Note
that the common logarithm of a complex number is computed by taking the
natural logarithm and dividing by `ln(10)'.

The `B' (`calc-log') [`log'] command computes a logarithm
to any base.  For example, `1024 RET 2 B' produces 10, since
`2^10 = 1024'.  In certain cases like `log(3,9)', the result
will be either `1:2' or `0.5' depending on the current Fraction
Mode setting.  With the Inverse flag [`alog'], this command is
similar to `^' except that the order of the arguments is reversed.

The `f I' (`calc-ilog') [`ilog'] command computes the
integer logarithm of a number to any base.  The number and the base must
themselves be positive integers.  This is the true logarithm, rounded
down to an integer.  Thus `ilog(x,10)' is 3 for all `x' in the
range from 1000 to 9999.  If both arguments are positive integers, exact
integer arithmetic is used; otherwise, this is equivalent to
`floor(log(x,b))'.

The `f E' (`calc-expm1') [`expm1'] command computes
`exp(x)-1', but using an algorithm that produces a more accurate
answer when the result is close to zero, i.e., when `exp(x)' is close
to one.

The `f L' (`calc-lnp1') [`lnp1'] command computes
`ln(x+1)', producing a more accurate answer when `x' is close
to zero.


File: calc.info  Node: Trigonometric and Hyperbolic Functions, Prev: Logarithmic Functions, Up: Scientific Functions, Next: Advanced Math Functions

Trigonometric/Hyperbolic Functions
==================================

The shift-`S' (`calc-sin') [`sin'] command computes the sine of an angle
or complex number.  If the input is an HMS form, it is interpreted as
degrees-minutes-seconds; otherwise, the input is interpreted according
to the current angular mode.  It is best to use Radians mode when
operating on complex numbers.

Calc's "units" mechanism includes angular units like `deg',
`rad', and `grad'.  While `sin(45 deg)' is not evaluated
all the time, the `u s' (`calc-simplify-units') command will
simplify `sin(45 deg)' by taking the sine of 45 degrees, regardless
of the current angular mode.  *Note Basic Operations on Units::.

Also, the symbolic variable `pi' is not ordinarily recognized in
arguments to trigonometric functions, as in `sin(3 pi / 4)', but the `a
s' (`calc-simplify') command recognizes many such formulas when the
current angular mode is radians *and* symbolic mode is enabled; this
example would be replaced by `sqrt(2) / 2'.  *Note Symbolic Mode::.
Beware, this simplification occurs even if you have stored a different
value in the variable `pi'; this is one reason why changing built-in
variables is a bad idea.  Arguments of the form `x' plus a multiple of
`pi/2' are also simplified.  Calc includes similar formulas for `cos'
and `tan'.

The `a s' command knows all angles which are integer multiples of
`pi/12', `pi/10', or `pi/8' radians.  In degrees mode,
analogous simplifications occur for integer multiples of 15 or 18
degrees, and for arguments plus multiples of 90 degrees.

With the Inverse flag, `calc-sin' computes an arcsine.  This is also
available as the `calc-arcsin' command or `arcsin' algebraic
function.  The returned argument is converted to degrees, radians, or HMS
notation depending on the current angular mode.

With the Hyperbolic flag, `calc-sin' computes the hyperbolic
sine, also available as `calc-sinh' [`sinh'].  With the
Hyperbolic and Inverse flags, it computes the hyperbolic arcsine
(`calc-arcsinh') [`arcsinh'].

The shift-`C' (`calc-cos') [`cos'] command computes the cosine
of an angle or complex number, and shift-`T' (`calc-tan') [`tan']
computes the tangent, along with all the various inverse and hyperbolic
variants of these functions.

The `f T' (`calc-arctan2') [`arctan2'] command takes two
numbers from the stack and computes the arc tangent of their ratio.  The
result is in the full range from -180 (exclusive) to +180
(inclusive) degrees, or the analogous range in radians.  A similar
result would be obtained with `/' followed by `I T', but the
value would only be in the range from -90 to +90 degrees
since the division loses information about the signs of the two
components, and an error might result from an explicit division by zero
which `arctan2' would avoid.  By (arbitrary) definition,
`arctan2(0,0)=0'.

The `calc-sincos' [`sincos'] command computes the sine and cosine of a
number, returning them as a vector of the form `[COS, SIN]'.  With the
Inverse flag [`arcsincos'], this command takes a two-element vector as
an argument and computes `arctan2' of the elements.  (This command does
not accept the Hyperbolic flag.)


File: calc.info  Node: Advanced Math Functions, Prev: Trigonometric and Hyperbolic Functions, Up: Scientific Functions, Next: Branch Cuts

Advanced Mathematical Functions
===============================

Calc can compute a variety of less common functions that arise in
various branches of mathematics.  All of the functions described in
this section allow arbitrary complex arguments and, except as noted,
will work to arbitrarily large precisions.  They can not at present
handle error forms or intervals as arguments.

NOTE:  These functions are still experimental.  In particular, their
accuracy is not guaranteed in all domains.  It is advisable to set the
current precision comfortably higher than you actually need when
using these functions.  Also, these functions may be impractically
slow for some values of the arguments.

The `f g' (`calc-gamma') [`gamma'] command computes the Euler
gamma function.  For positive integer arguments, this is related to the
factorial function:  `gamma(n+1) = fact(n)'.  For general complex
arguments the gamma function can be defined by the following definite
integral:  `gamma(a) = integ(t^(a-1) exp(t), t, 0, inf)'.
(The actual implementation uses far more efficient computational methods.)

The `f G' (`calc-inc-gamma') [`gammaP'] command computes
the incomplete gamma function, denoted `P(a,x)'.  This is defined by
the integral, `gammaP(a,x) = integ(t^(a-1) exp(t), t, 0, x) / gamma(a)'.
This implies that `gammaP(a,inf) = 1' for any `a' (see the
definition of the normal gamma function).

Several other varieties of incomplete gamma function are defined.
The complement of `P(a,x)', called `Q(a,x) = 1-P(a,x)' by
some authors, is computed by the `I f G' [`gammaQ'] command.
You can think of this as taking the other half of the integral, from
`x' to infinity.

The functions corresponding to the integrals that define `P(a,x)'
and `Q(a,x)' but without the normalizing `1/gamma(a)'
factor are called `g(a,x)' and `G(a,x)', respectively
(where `g' and `G' represent the lower- and upper-case Greek
letter gamma).  You can obtain these using the `H f G' [`gammag']
and `H I f G' [`gammaG'] commands.

The `f b' (`calc-beta') [`beta'] command computes the
Euler beta function, which is defined in terms of the gamma function as
`beta(a,b) = gamma(a) gamma(b) / gamma(a+b)', or by
`beta(a,b) = integ(t^(a-1) (1-t)^(b-1), t, 0, 1)'.

The `f B' (`calc-inc-beta') [`betaI'] command computes
the incomplete beta function `I(x,a,b)'.  It is defined by
`betaI(x,a,b) = integ(t^(a-1) (1-t)^(b-1), t, 0, x) / beta(a,b)'.
Once again, the `H' (hyperbolic) prefix gives the corresponding
un-normalized version [`betaB'].

The `f e' (`calc-erf') [`erf'] command computes the
error function `erf(x) = 2 integ(exp(-(t^2)), t, 0, x) / sqrt(pi)'.
The complementary error function `I f e' (`calc-erfc') [`erfc']
is the corresponding integral from `x' to infinity; the sum
`erf(x) + erfc(x) = 1'.

The `f j' (`calc-bessel-J') [`besJ'] and `f y' (`calc-bessel-Y')
[`besY'] commands compute the Bessel functions of the first and second
kinds, respectively.  In `besJ(n,x)' and `besY(n,x)' the "order"
parameter `n' is often an integer, but is not required to be one.
Calc's implementation of the Bessel functions currently limits the
precision to 8 digits, and may not be exact even to that precision.  Use
with care!


File: calc.info  Node: Branch Cuts, Prev: Advanced Math Functions, Up: Scientific Functions, Next: Random Numbers

Branch Cuts and Principal Values
================================

All of the logarithmic, trigonometric, and other scientific functions are
defined for complex numbers as well as for reals.
This section describes the values
returned in cases where the general result is a family of possible values.
Calc follows section 12.5.3 of Steele's "Common Lisp, the Language",
second edition, in these matters.  This section will describe each
function briefly; for a more detailed discussion (including some nifty
diagrams), consult Steele's book.

Note that the branch cuts for `arctan' and `arctanh' were
changed between the first and second editions of Steele.  Versions of
Calc starting with 2.00 follow the second edition.

The new branch cuts exactly match those of the HP-28/48 calculators.
They also match those of Mathematica 1.2, except that Mathematica's
`arctan' cut is always in the right half of the complex plane,
and its `arctanh' cut is always in the top half of the plane.
Calc's cuts are continuous with quadrants I and III for `arctan',
or II and IV for `arctanh'.

Note:  The current implementations of these functions with complex arguments
are designed with proper behavior around the branch cuts in mind, *not*
efficiency or accuracy.  You may need to increase the floating precision
and wait a while to get suitable answers from them.

For `sqrt(a+bi)':  When `a<0' and `b' is small but positive
or zero, the result is close to the `+i' axis.  For `b' small and
negative, the result is close to the `-i' axis.  The result always lies
in the right half of the complex plane.

For `ln(a+bi)':  The real part is defined as `ln(abs(a+bi))'.
The imaginary part is defined as `arg(a+bi) = arctan2(b,a)'.
Thus the branch cuts for `sqrt' and `ln' both lie on the
negative real axis.

The following table describes these branch cuts in another way.
If the real and imaginary parts of `z' are as shown, then
the real and imaginary parts of `f(z)' will be as shown.
Here `eps' stands for a small positive value; each
occurrence of `eps' may stand for a different small value.

          z           sqrt(z)       ln(z)
     ----------------------------------------
        +,   0         +,  0       any, 0
        -,   0         0,  +       any, pi
        -, +eps      +eps, +      +eps, +
        -, -eps      +eps, -      +eps, -

For `z1^z2':  This is defined by `exp(ln(z1)*z2)'.
One interesting consequence of this is that `(-8)^1:3' does
not evaluate to -2 as you might expect, but to the complex
number `(1., 1.732)'.  Both of these are valid cube roots
of -8 (as is `(1., -1.732)'); Calc chooses a perhaps
less-obvious root for the sake of mathematical consistency.

For `arcsin(z)':  This is defined by `-i*ln(i*z + sqrt(1-z^2))'.
The branch cuts are on the real axis, less than -1 and greater than 1.

For `arccos(z)':  This is defined by `-i*ln(z + i*sqrt(1-z^2))',
or equivalently by `pi/2 - arcsin(z)'.  The branch cuts are on
the real axis, less than -1 and greater than 1.

For `arctan(z)':  This is defined by
`(ln(1+i*z) - ln(1-i*z)) / (2*i)'.  The branch cuts are on the
imaginary axis, below `-i' and above `i'.

For `arcsinh(z)':  This is defined by `ln(z + sqrt(1+z^2))'.
The branch cuts are on the imaginary axis, below `-i' and
above `i'.

For `arccosh(z)':  This is defined by
`ln(z + (z+1)*sqrt((z-1)/(z+1)))'.  The branch cut is on the
real axis less than 1.

For `arctanh(z)':  This is defined by `(ln(1+z) - ln(1-z)) / 2'.
The branch cuts are on the real axis, less than -1 and greater than 1.

The following entries for `arcsin', `arccos', and
`arctan' assume the current angular mode is radians.  The
hyperbolic functions operate independently of the angular mode.

            z             arcsin(z)            arccos(z)
     -------------------------------------------------------
      (-1..1),  0      (-pi/2..pi/2), 0       (0..pi), 0
      (-1..1), +eps    (-pi/2..pi/2), +eps    (0..pi), -eps
      (-1..1), -eps    (-pi/2..pi/2), -eps    (0..pi), +eps
        <-1,    0          -pi/2,     +         pi,    -
        <-1,  +eps      -pi/2 + eps,  +      pi - eps, -
        <-1,  -eps      -pi/2 + eps,  -      pi - eps, +
         >1,    0           pi/2,     -          0,    +
         >1,  +eps       pi/2 - eps,  +        +eps,   -
         >1,  -eps       pi/2 - eps,  -        +eps,   +

            z            arccosh(z)         arctanh(z)
     -----------------------------------------------------
      (-1..1),  0        0,  (0..pi)       any,     0
      (-1..1), +eps    +eps, (0..pi)       any,    +eps
      (-1..1), -eps    +eps, (-pi..0)      any,    -eps
        <-1,    0        +,    pi           -,     pi/2
        <-1,  +eps       +,  pi - eps       -,  pi/2 - eps
        <-1,  -eps       +, -pi + eps       -, -pi/2 + eps
         >1,    0        +,     0           +,    -pi/2
         >1,  +eps       +,   +eps          +,  pi/2 - eps
         >1,  -eps       +,   -eps          +, -pi/2 + eps

            z           arcsinh(z)           arctan(z)
     -----------------------------------------------------
        0, (-1..1)    0, (-pi/2..pi/2)         0,     any
        0,   <-1      -,    -pi/2            -pi/2,    -
      +eps,  <-1      +, -pi/2 + eps       pi/2 - eps, -
      -eps,  <-1      -, -pi/2 + eps      -pi/2 + eps, -
        0,    >1      +,     pi/2             pi/2,    +
      +eps,   >1      +,  pi/2 - eps       pi/2 - eps, +
      -eps,   >1      -,  pi/2 - eps      -pi/2 + eps, +

Finally, the following identities help to illustrate the relationship
between the complex trigonometric and hyperbolic functions.  They
are valid everywhere, including on the branch cuts.

     sin(i*z)  = i*sinh(z)       arcsin(i*z)  = i*arcsinh(z)
     cos(i*z)  =   cosh(z)       arcsinh(i*z) = i*arcsin(z)
     tan(i*z)  = i*tanh(z)       arctan(i*z)  = i*arctanh(z)
     sinh(i*z) = i*sin(z)        cosh(i*z)    =   cos(z)

The "advanced math" functions (gamma, Bessel, etc.) are also defined
for general complex arguments, but their branch cuts and principal values
are not rigorously specified at present.


File: calc.info  Node: Random Numbers, Prev: Branch Cuts, Up: Scientific Functions, Next: Combinatorial Functions

Random Numbers
==============

The `k r' (`calc-random') [`random'] command produces
random numbers of various sorts.

Given a positive numeric prefix argument `M', it produces a random
integer `N' in the range `0 <= N < M'.  Each of the `M' values appears
with equal probability.

With no numeric prefix argument, the `k r' command takes its argument
from the stack instead.  Once again, if this is a positive integer `M'
the result is a random integer less than `M'.  However, note that
while numeric prefix arguments are limited to six digits or so, an `M'
taken from the stack can be arbitrarily large.  If `M' is negative,
the result is a random integer in the range `M < N <= 0'.

If the value on the stack is a floating-point number `M', the result
is a random floating-point number `N' in the range `0 <= N < M'
or `M < N <= 0', according to the sign of `M'.

If `M' is zero, the result is a Gaussian-distributed random real
number; the distribution has a mean of zero and a standard deviation
of one.  The algorithm used generates random numbers in pairs; thus,
every other call to this function will be especially fast.

If `M' is an error form `M +/- S' where M
and S are both real numbers, the result uses a Gaussian
distribution with mean M and standard deviation S.

If `M' is an interval form, the lower and upper bounds specify the
acceptable limits of the random numbers.  If both bounds are integers,
the result is a random integer in the specified range.  If either bound
is floating-point, the result is a random real number in the specified
range.  If the interval is open at enter end, the result will be sure
not to equal that end value.  (This makes a big difference for integer
intervals, but for floating-point intervals it's relatively minor:
with a precision of 6, `random([1.0..2.0))' will return any of one
million numbers from 1.00000 to 1.99999; `random([1.0..2.0])' may
additionally return 2.00000, but the probability of this happening is
extremely small.)

If `M' is a vector, the result is one element taken at random from
the vector.  All elements of the vector are given equal probabilities.

The sequence of numbers produced by `k r' is completely random by
default, i.e., the sequence is seeded each time you start Calc using
the current time and other information.  You can get a reproducible
sequence by storing a particular "seed value" in the Calc variable
`RandSeed'.  Any integer will do for a seed; integers of from 1
to 12 digits are good.  If you later store a different integer into
`RandSeed', Calc will switch to a different pseudo-random
sequence.  If you "unstore" `RandSeed', Calc will re-seed itself
from the current time.  If you store the same integer that you used
before back into `RandSeed', you will get the exact same sequence
of random numbers as before.

The `calc-rrandom' command produces a random real number between
zero and one.  It is equivalent to `random(1.0)'.

The `k a' (`calc-random-again') command produces another random
number, re-using the most recent value of `M'.  With a numeric
prefix argument N, it produces N more random numbers using
that value of `M'.

The `k h' (`calc-shuffle') command produces a vector of several
random values with no duplicates.  The value on the top of the stack
specifies the set from which the random values are drawn, and may be any
of the `M' formats described above.  The numeric prefix argument
gives the length of the desired list.  (If you do not provide a numeric
prefix argument, the length of the list is taken from the top of the
stack, and `M' from second-to-top.)

If `M' is a floating-point number, zero, or an error form (so
that the random values are being drawn from the set of real numbers)
there is little practical difference between using `k h' and using
`k r' several times.  But if the set of possible values consists
of just a few integers, or the elements of a vector, then there is
a very real chance that multiple `k r''s will produce the same
number more than once.  The `k h' command produces a vector whose
elements are always distinct.  (Actually, there is a slight exception:
If `M' is a vector, no given vector element will be drawn more
than once, but if several elements of `M' are equal, they may
each make it into the result vector.)

One use of `k h' is to rearrange a list at random.  This happens
if the prefix argument is equal to the number of values in the list:
`[1, 1.5, 2, 2.5, 3] 5 k h' might produce the permuted list
`[2.5, 1, 1.5, 3, 2]'.  As a convenient feature, if the argument
N is negative it is replaced by the size of the set represented
by `M'.  Naturally, this is allowed only when `M' specifies
a small discrete set of possibilities.

To do the equivalent of `k h' but with duplications allowed,
given `M' on the stack and with N just entered as a numeric
prefix, use `v b' to build a vector of copies of `M', then use
`V M k r' to "map" the normal `k r' function over the
elements of this vector.  *Note Matrix Functions::.

* Menu:

* Random Number Generator::     (Complete description of Calc's algorithm)


File: calc.info  Node: Random Number Generator, Prev: Random Numbers, Up: Random Numbers

Random Number Generator
-----------------------

Calc's random number generator uses several methods to ensure that
the numbers it produces are highly random.  Knuth's *Art of
Computer Programming*, Volume II, contains a thorough description
of the theory of random number generators and their measurement and
characterization.

If `RandSeed' has no stored value, Calc calls Emacs' built-in
`random' function to get a stream of random numbers, which it
then treats in various ways to avoid problems inherent in the simple
random number generators that many systems use to implement `random'.

When Calc's random number generator is first invoked, it "seeds"
the low-level random sequence using the time of day, so that the
random number sequence will be different every time you use Calc.

Since Emacs Lisp doesn't specify the range of values that will be
returned by its `random' function, Calc exercises the function
several times to estimate the range.  When Calc subsequently uses
the `random' function, it takes only 10 bits of the result
near the most-significant end.  (It avoids at least the bottom
four bits, preferably more, and also tries to avoid the top two
bits.)  This strategy works well with the linear congruential
generators that are typically used to implement `random'.

If `RandSeed' contains an integer, Calc uses this integer to
seed an "additive congruential" method (Knuth's algorithm 3.2.2A,
computing `X_n-55 - X_n-24').  This method expands the seed
value into a large table which is maintained internally; the variable
`RandSeed' is changed from, e.g., 42 to the vector `[42]'
to indicate that the seed has been absorbed into this table.  When
`RandSeed' contains a vector, `k r' and related commands
continue to use the same internal table as last time.  There is no
way to extract the complete state of the random number generator
so that you can restart it from any point; you can only restart it
from the same initial seed value.  A simple way to restart from the
same seed is to type `s r RandSeed' to get the seed vector,
`v u' to unpack it back into a number, then `s t RandSeed'
to reseed the generator with that number.

Calc uses a "shuffling" method as described in algorithm 3.2.2B
of Knuth.  It fills a table with 13 random 10-bit numbers.  Then,
to generate a new random number, it uses the previous number to
index into the table, picks the value it finds there as the new
random number, then replaces that table entry with a new value
obtained from a call to the base random number generator (either
the additive congruential generator or the `random' function
supplied by the system).  If there are any flaws in the base
generator, shuffling will tend to even them out.  But if the system
provides an excellent `random' function, shuffling will not
damage its randomness.

To create a random integer of a certain number of digits, Calc
builds the integer three decimal digits at a time.  For each group
of three digits, Calc calls its 10-bit random number generator
(which returns a value from 0 to 1023); if the random value is 1000
or more, Calc throws it out and tries again until it gets a suitable
value.

To create a random floating-point number with precision P, Calc
simply creates a random P-digit integer and multiplies by
`10^-p'.  The resulting random numbers should be very clean, but note
that relatively small numbers will have few significant random digits.
In other words, with a precision of 12, you will occasionally get
numbers on the order of `10^-9' or `10^-10', but those numbers
will only have two or three random digits since they correspond to small
integers times `10^-12'.

To create a random integer in the interval `[0 .. M)', Calc
counts the digits in M, creates a random integer with three
additional digits, then reduces modulo M.  Unless M is a
power of ten the resulting values will be very slightly biased toward
the lower numbers, but this bias will be less than 0.1%.  (For example,
if M is 42, Calc will reduce a random integer less than 100000
modulo 42 to get a result less than 42.  It is easy to show that the
numbers 40 and 41 will be only 2380/2381 as likely to result from this
modulo operation as numbers 39 and below.)  If M is a power of
ten, however, the numbers should be completely unbiased.

The Gaussian random numbers generated by `random(0.0)' use the
"polar" method described in Knuth section 3.4.1C.  This method
generates a pair of Gaussian random numbers at a time, so only every
other call to `random(0.0)' will require significant calculations.


File: calc.info  Node: Combinatorial Functions, Prev: Random Numbers, Up: Scientific Functions, Next: Probability Distribution Functions

Combinatorial Functions
=======================

Commands relating to combinatorics and number theory begin with the
`k' key prefix.

The `k g' (`calc-gcd') [`gcd'] command computes the Greatest Common
Divisor of two integers.  It also accepts fractions; the GCD of two
fractions is defined by taking the GCD of the numerators, and the LCM of
the denominators.  This definition is consistent with the idea that `a /
gcd(a,x)' should yield an integer for any `a' and `x'.  For other types
of arguments, the operation is left in symbolic form.

The `k l' (`calc-lcm') [`lcm'] command computes the Least Common
Multiple of two integers or fractions.  The product of the LCM and GCD
of two numbers is equal to the product of the numbers.

The `k E' (`calc-extended-gcd') [`egcd'] command computes
the GCD of two integers `x' and `y' and returns a vector
`[g, a, b]' where `g = gcd(x,y) = a x + b y'.

The `!' (`calc-factorial') [`fact'] command computes the factorial of
the number at the top of the stack.  If the number is an integer, the
result is an exact integer.  If the number is an integer-valued float,
the result is a floating-point approximation.  If the number is a
non-integral real number, the generalized factorial is used, as defined
by the Euler Gamma function.  Please note that computation of large
factorials can be slow; using floating-point format will help since
fewer digits must be maintained.  The same is true of many of the
commands in this section.

The `k d' (`calc-double-factorial') [`dfact'] command computes the
"double factorial" of an integer.  For an even integer, this is the
product of even integers from 2 to `N'.  For an odd integer, this is the
product of odd integers from 3 to `N'.  If the argument is an
integer-valued float, the result is a floating-point approximation.
This function is undefined for negative even integers.  The notation
`N!!' is also recognized for double factorials.

The `k c' (`calc-choose') [`choose'] command computes the
binomial coefficient `N'-choose-`M', where `M' is the number
on the top of the stack and `N' is second-to-top.  If both arguments
are integers, the result is an exact integer.  Otherwise, the result is a
floating-point approximation.  The binomial coefficient is defined for all
real numbers by `N! / M! (N-M)!'.

The `H k c' (`calc-perm') [`perm'] command computes the
number-of-permutations function `N! / (N-M)!'.

The `k b' (`calc-bernoulli-number') [`bern'] command
computes a given Bernoulli number.  The value at the top of the stack
is a nonnegative integer `n' that specifies which Bernoulli number
is desired.  The `H k b' command computes a Bernoulli polynomial,
taking `n' from the second-to-top position and `x' from the
top of the stack.  If `x' is a variable or formula the result is
a polynomial in `x'; if `x' is a number the result is a number.

The `k e' (`calc-euler-number') [`euler'] command similarly
computes an Euler number, and `H k e' computes an Euler polynomial.
Bernoulli and Euler numbers occur in the Taylor expansions of several
functions.

The `k s' (`calc-stirling-number') [`stir1'] command
computes a Stirling number of the first kind, given two integers
`n' and `m' on the stack.  The `H k s' [`stir2']
command computes a Stirling number of the second kind.  These are
the number of `m'-cycle permutations of `n' objects, and
the number of ways to partition `n' objects into `m'
non-empty sets, respectively.

The `k p' (`calc-prime-test') command checks if the integer on
the top of the stack is prime.  For integers less than eight million, the
answer is always exact and reasonably fast.  For larger integers, a
probabilistic method is used (See Knuth vol. II, section 4.5.4, algorithm P).
The number is first checked against small prime factors (up to 13).  Then,
any number of iterations of the algorithm are performed.  Each step either
discovers that the number is non-prime, or substantially increases the
certainty that the number is prime.  After a few steps, the chance that
a number was mistakenly described as prime will be less than one percent.
(Indeed, this is the worst case; in practice even a single iteration is
quite reliable.)  After the `k p' command, the number will be reported
as definitely prime or non-prime if possible, or otherwise "probably"
prime with a certain probability of error.

The normal `k p' command performs one iteration of the primality
test.  Pressing `k p' repeatedly for the same integer will perform
additional iterations.  Also, `k p' with a numeric prefix performs
the specified number of iterations.  There is also an algebraic function
`prime(n)' or `prime(n,iters)' which returns 1 if `n'
is (probably) prime and 0 if not.

The `k f' (`calc-prime-factors') [`prfac'] command
attempts to decompose an integer into its prime factors.  For numbers up
to 25 million, the answer is exact although it may take some time.  The
result is a vector of the prime factors in increasing order.  For larger
inputs, prime factors above 5000 may not be found, in which case the
last number in the vector will be an unfactored integer greater than 25
million.  For negative integers, the first element of the list will be
-1.  For inputs -1, 0, and 1, the result is a list of
the same number.

The `k n' (`calc-next-prime') [`nextprime'] command finds
the next prime above a given number.  Essentially, it searches by calling
`calc-prime-test' on successive integers until it finds one that
passes the test.  This is quite fast for integers less than eight million,
but once the probabilistic test comes into play the search may be rather
slow.  Ordinarily this command stops for any prime that passes one iteration
of the primality test.  With a numeric prefix argument, a number must pass
the specified number of iterations before the search stops.  (This only
matters when searching above eight million.)  You can always use additional
`k p' commands to increase your certainty that the number is indeed
prime.

The `I k n' (`calc-prev-prime') [`prevprime'] command
analogously finds the next prime less than a given number.

The `k t' (`calc-totient') [`totient'] command computes the
Euler "totient" function, the number of integers less than `n' which
are relatively prime to `n'.

The `k m' (`calc-moebius') [`moebius'] command computes the
Moebius "mu" function.  If the input number is a product of `k'
distinct factors, this is `(-1)^k'.  If the input number has any
duplicate factors (i.e., can be divided by the same prime more than once),
the result is zero.


File: calc.info  Node: Probability Distribution Functions, Prev: Combinatorial Functions, Up: Scientific Functions

Probability Distribution Functions
==================================

The functions in this section compute various probability distributions.
For continuous distributions, this is the integral of the probability
density function from `x' to infinity.  (These are the "upper
tail" distribution functions; there are also corresponding "lower
tail" functions which integrate from minus infinity to `x'.)
For discrete distributions, the upper tail function gives the sum
from `x' to infinity; the lower tail function gives the sum
from minus infinity up to, but not including, `x'.

To integrate from `x' to `y', just use the distribution
function twice and subtract.  For example, the probability that a
Gaussian random variable with mean 2 and standard deviation 1 will
lie in the range from 2.5 to 2.8 is `utpn(2.5,2,1) - utpn(2.8,2,1)'
("the probability that it is greater than 2.5, but not greater than 2.8"),
or equivalently `ltpn(2.8,2,1) - ltpn(2.5,2,1)'.

The `k B' (`calc-utpb') [`utpb'] function uses the
binomial distribution.  Push the parameters N, P, and
then X onto the stack; the result (`utpb(x,n,p)') is the
probability that an event will occur X or more times out
of N trials, if its probability of occurring in any given
trial is P.  The `I k B' [`ltpb'] function is
the probability that the event will occur fewer than X times.

The other probability distribution functions similarly take the
form `k X' (`calc-utpX') [`utpX']
and `I k X' [`ltpX'], for various letters
X.  The arguments to the algebraic functions are the value of
the random variable first, then whatever other parameters define the
distribution.  Note these are among the few Calc functions where the
order of the arguments in algebraic form differs from the order of
arguments as found on the stack.  (The random variable comes last on
the stack, so that you can type, e.g., `2 RET 1 RET 2.5
k N M-RET DEL 2.8 k N -', using `M-RET DEL' to
recover the original arguments but substitute a new value for `x'.)

The `utpc(x,v)' function uses the chi-square distribution with
`v' degrees of freedom.  It is the probability that a model is
correct if its chi-square statistic is `x'.

The `utpf(F,v1,v2)' function uses the F distribution, used in
various statistical tests.  The parameters `v1' and `v2'
are the degrees of freedom in the numerator and denominator,
respectively, used in computing the statistic `F'.

The `utpn(x,m,s)' function uses a normal (Gaussian) distribution
with mean `m' and standard deviation `s'.  It is the
probability that such a normal-distributed random variable would
exceed `x'.

The `utpp(n,x)' function uses a Poisson distribution with
mean `x'.  It is the probability that `n' or more such
Poisson random events will occur.

The `utpt(t,v)' function uses the Student's "t" distribution
with `v' degrees of freedom.  It is the probability that a
t-distributed random variable will be greater than `t'.
(Note:  This computes the distribution function `A(t|v)'
where `A(0|v) = 1' and `A(inf|v) -> 0'.  The
`UTPT' operation on the HP-48 uses a different definition
which returns half of Calc's value:  `UTPT(t,v) = .5*utpt(t,v)'.)

While Calc does not provide inverses of the probability distribution
functions, the `a R' command can be used to solve for the inverse.
Since the distribution functions are monotonic, `a R' is guaranteed
to be able to find a solution given any initial guess.
*Note Numerical Solutions::.


File: calc.info  Node: Matrix Functions, Prev: Scientific Functions, Up: Top, Next: Algebra

Vector/Matrix Functions
***********************

Many of the commands described here begin with the `v' prefix.
(For convenience, the shift-`V' prefix is equivalent to `v'.)
The commands usually apply to both plain vectors and matrices; some
apply only to matrices or only to square matrices.  If the argument
has the wrong dimensions the operation is left in symbolic form.

Vectors are entered and displayed using `[a,b,c]' notation.
Matrices are vectors of which all elements are vectors of equal length.
(Though none of the standard Calc commands use this concept, a
three-dimensional matrix or rank-3 tensor could be defined as a
vector of matrices, and so on.)

* Menu:

* Packing and Unpacking::
* Building Vectors::
* Extracting Elements::
* Manipulating Vectors::
* Vector and Matrix Arithmetic::
* Set Operations::
* Statistical Operations::
* Reducing and Mapping::
* Vector and Matrix Formats::


File: calc.info  Node: Packing and Unpacking, Prev: Matrix Functions, Up: Matrix Functions, Next: Building Vectors

Packing and Unpacking
=====================

Calc's "pack" and "unpack" commands collect stack entries to build
composite objects such as vectors and complex numbers.  They are
described in this chapter because they are most often used to build
vectors.

The `v p' (`calc-pack') [`pack'] command collects several
elements from the stack into a matrix, complex number, HMS form, error
form, etc.  It uses a numeric prefix argument to specify the kind of
object to be built; this argument is referred to as the "packing mode."
If the packing mode is a nonnegative integer, a vector of that
length is created.  For example, `C-u 5 v p' will pop the top
five stack elements and push back a single vector of those five
elements.  (`C-u 0 v p' simply creates an empty vector.)

The same effect can be had by pressing `[' to push an incomplete
vector on the stack, using `calc-roll-down' to sneak the
incomplete object up past a certain number of elements, and
then pressing `]' to complete the vector.

Negative packing modes create other kinds of composite objects:

`-1'
     Two values are collected to build a complex number.  For example,
     `5 RET 7 C-u -1 v p' creates the complex number
     `(5, 7)'.  The result is always a rectangular complex
     number.  The two input values must both be real numbers,
     i.e., integers, fractions, or floats.  If they are not, Calc
     will instead build a formula like `a + (0, 1) b'.  (The
     other packing modes also create a symbolic answer if the
     components are not suitable.)

`-2'
     Two values are collected to build a polar complex number.
     The first is the magnitude; the second is the phase expressed
     in either degrees or radians according to the current angular
     mode.

`-3'
     Three values are collected into an HMS form.  The first
     two values (hours and minutes) must be integers or
     integer-valued floats.  The third value may be any real
     number.

`-4'
     Two values are collected into an error form.  The inputs
     may be real numbers or formulas.

`-5'
     Two values are collected into a modulo form.  The inputs
     must be real numbers.

`-6'
     Two values are collected into the interval `[a .. b]'.
     The inputs may be real numbers, HMS or date forms, or formulas.

`-7'
     Two values are collected into the interval `[a .. b)'.

`-8'
     Two values are collected into the interval `(a .. b]'.

`-9'
     Two values are collected into the interval `(a .. b)'.

`-10'
     Two integer values are collected into a fraction.

`-11'
     Two values are collected into a floating-point number.
     The first is the mantissa; the second, which must be an
     integer, is the exponent.  The result is the mantissa
     times ten to the power of the exponent.

`-12'
     This is treated the same as -11 by the `v p' command.
     When unpacking, -12 specifies that a floating-point mantissa
     is desired.

`-13'
     A real number is converted into a date form.

`-14'
     Three numbers (year, month, day) are packed into a pure date form.

`-15'
     Six numbers are packed into a date/time form.

With any of the two-input negative packing modes, either or both
of the inputs may be vectors.  If both are vectors of the same
length, the result is another vector made by packing corresponding
elements of the input vectors.  If one input is a vector and the
other is a plain number, the number is packed along with each vector
element to produce a new vector.  For example, `C-u -4 v p'
could be used to convert a vector of numbers and a vector of errors
into a single vector of error forms; `C-u -5 v p' could convert
a vector of numbers and a single number M into a vector of
numbers modulo M.

If you don't give a prefix argument to `v p', it takes
the packing mode from the top of the stack.  The elements to
be packed then begin at stack level 2.  Thus
`1 RET 2 RET 4 n v p' is another way to
enter the error form `1 +/- 2'.

If the packing mode taken from the stack is a vector, the result is a
matrix with the dimensions specified by the elements of the vector,
which must each be integers.  For example, if the packing mode is
`[2, 3]', then six numbers will be taken from the stack and
returned in the form `[[a, b, c], [d, e, f]]'.

If any elements of the vector are negative, other kinds of
packing are done at that level as described above.  For
example, `[2, 3, -4]' takes 12 objects and creates a
2x3 matrix of error forms: `[[a +/- b, c +/- d ... ]]'.
Also, `[-4, -10]' will convert four integers into an
error form consisting of two fractions:  `a:b +/- c:d'.

There is an equivalent algebraic function,
`pack(MODE, ITEMS)' where MODE is a
packing mode (an integer or a vector of integers) and ITEMS
is a vector of objects to be packed (re-packed, really) according
to that mode.  For example, `pack([3, -4], [a,b,c,d,e,f])'
yields `[a +/- b, c +/- d, e +/- f]'.  The function is
left in symbolic form if the packing mode is illegal, or if the
number of data items does not match the number of items required
by the mode.

The `v u' (`calc-unpack') command takes the vector, complex
number, HMS form, or other composite object on the top of the stack and
"unpacks" it, pushing each of its elements onto the stack as separate
objects.  Thus, it is the "inverse" of `v p'.  If the value
at the top of the stack is a formula, `v u' unpacks it by pushing
each of the arguments of the top-level operator onto the stack.

You can optionally give a numeric prefix argument to `v u'
to specify an explicit (un)packing mode.  If the packing mode is
negative and the input is actually a vector or matrix, the result
will be two or three similar vectors or matrices of the elements.
For example, given the vector `[a +/- b, c^2, d +/- 7]',
the result of `C-u -4 v u' will be the two vectors
`[a, c^2, d]' and `[b, 0, 7]'.

Note that the prefix argument can have an effect even when the input is
not a vector.  For example, if the input is the number -5, then
`c-u -1 v u' yields -5 and 0 (the components of -5
when viewed as a rectangular complex number); `C-u -2 v u' yields 5
and 180 (assuming degrees mode); and `C-u -10 v u' yields -5
and 1 (the numerator and denominator of -5, viewed as a rational
number).  Plain `v u' with this input would complain that the input
is not a composite object.

Unpacking mode -11 converts a float into an integer mantissa and
an integer exponent, where the mantissa is not divisible by 10
(except that 0.0 is represented by a mantissa and exponent of 0).
Unpacking mode -12 converts a float into a floating-point mantissa
and integer exponent, where the mantissa (for non-zero numbers)
is guaranteed to lie in the range [1 .. 10).  In both cases,
the mantissa is shifted left or right (and the exponent adjusted
to compensate) in order to satisfy these constraints.

Positive unpacking modes are treated differently than for `v p'.
A mode of 1 is much like plain `v u' with no prefix argument,
except that in addition to the components of the input object,
a suitable packing mode to re-pack the object is also pushed.
Thus, `C-u 1 v u' followed by `v p' will re-build the
original object.

A mode of 2 unpacks two levels of the object; the resulting
re-packing mode will be a vector of length 2.  This might be used
to unpack a matrix, say, or a vector of error forms.  Higher
unpacking modes unpack the input even more deeply.

There are two algebraic functions analogous to `v u'.
The `unpack(MODE, ITEM)' function unpacks the
ITEM using the given MODE, returning the result as
a vector of components.  Here the MODE must be an
integer, not a vector.  For example, `unpack(-4, a +/- b)'
returns `[a, b]', as does `unpack(1, a +/- b)'.

The `unpackt' function is like `unpack' but instead
of returning a simple vector of items, it returns a vector of
two things:  The mode, and the vector of items.  For example,
`unpackt(1, 2:3 +/- 1:4)' returns `[-4, [2:3, 1:4]]',
and `unpackt(2, 2:3 +/- 1:4)' returns `[[-4, -10], [2, 3, 1, 4]]'.
The identity for re-building the original object is
`apply(pack, unpackt(N, X)) = X'.  (The
`apply' function builds a function call given the function
name and a vector of arguments.)

Subscript notation is a useful way to extract a particular part
of an object.  For example, to get the numerator of a rational
number, you can use `unpack(-10, X)_1'.


