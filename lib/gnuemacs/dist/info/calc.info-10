Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: TeX Language Mode, Prev: C FORTRAN Pascal, Up: Language Modes, Next: Eqn Language Mode

TeX Language Mode
-----------------

The `d T' (`calc-tex-language') command selects the conventions of "math
mode" in the TeX typesetting language, by Donald Knuth.  Formulas are
entered and displayed in TeX notation, as in `\sin\left( a \over b
\right)'.  Math formulas are usually enclosed by `$ $' signs in TeX;
these should be omitted when interfacing with Calc.  To Calc, the `$'
sign has the same meaning it always does in algebraic formulas (a
reference to an existing entry on the stack).

Complex numbers are displayed as in `3 + 4i'.  Fractions and quotients
are written using `\over'; binomial coefficients are written with
`\choose'.  Interval forms are written with `\ldots', and error forms
are written with `\pm'.  Absolute values are written as in `|x + 1|',
and the floor and ceiling functions are written with `\lfloor',
`\rfloor', etc.  The words `\left' and `\right' are ignored when reading
formulas in TeX mode.  Both `inf' and `uinf' are written as `\infty';
when read, `\infty' always translates to `inf'.

Function calls are written the usual way, with the function name followed
by the arguments in parentheses.  However, functions for which TeX has
special names (like `\sin') will use curly braces instead of
parentheses for very simple arguments.  During input, curly braces and
parentheses work equally well for grouping, but when the document is
formatted the curly braces will be invisible.  Thus the printed result is
`sin 2x' but `sin(2 + x)'.

Function and variable names not treated specially by TeX are simply
written out as-is, which will cause them to come out in italic letters
in the printed document.  If you invoke `d T' with a positive numeric
prefix argument, names of more than one character will instead be written
`\hbox{NAME}'.  The `\hbox{ }' notation is ignored
during reading.  If you use a negative prefix argument, such function
names are written `\NAME', and function names that begin
with `\' during reading have the `\' removed.  (Note that
in this mode, long variable names are still written with `\hbox'.
However, you can always make an actual variable name like `\bar'
in any TeX mode.)

During reading, text of the form `\matrix{ ... }' is replaced
by `[ ... ]'.  The same also applies to `\pmatrix' and
`\bmatrix'.  The symbol `&' is interpreted as a comma,
and the symbols `\cr' and `\\' are interpreted as semicolons.
During output, matrices are displayed in `\matrix{ a & b \\ c & d}'
format; you may need to edit this afterwards to change `\matrix'
to `\pmatrix' or `\\' to `\cr'.

Accents like `\tilde' and `\bar' translate into function
calls internally (`tilde(x)', `bar(x)').  The `\underline'
sequence is treated as an accent.  The `\vec' accent corresponds
to the function name `Vec', because `vec' is the name of
a built-in Calc function.  The following table shows the accents
in Calc, TeX, and "eqn" (described in the next section):

     Calc      TeX           eqn
     ----      ---           ---
     acute     \acute
     bar       \bar          bar
     breve     \breve        
     check     \check
     dot       \dot          dot
     dotdot    \ddot         dotdot
     dyad                    dyad
     grave     \grave
     hat       \hat          hat
     Prime                   prime
     tilde     \tilde        tilde
     under     \underline    under
     Vec       \vec          vec

The `=>' (evaluates-to) operator appears as a `\to' symbol:
`{A \to B}'.  TeX defines `\to' as an
alias for `\rightarrow'.  However, if the `=>' is the
top-level expression being formatted, a slightly different notation
is used:  `\evalto A \to B'.  The `\evalto'
word is ignored by Calc's input routines, and is undefined in TeX.
You will typically want to include one of the following definitions
at the top of a TeX file that uses `\evalto':

     \def\evalto{}
     \def\evalto#1\to{}

The first definition formats evaluates-to operators in the usual
way.  The second causes only the B part to appear in the
printed document; the A part and the arrow are hidden.
Another definition you may wish to use is `\let\to=\Rightarrow'
which causes `\to' to appear more like Calc's `=>' symbol.
*Note Evaluates-To Operator::, for a discussion of `evalto'.

The complete set of TeX control sequences that are ignored during
reading is:

     \hbox  \mbox  \text  \left  \right
     \,  \>  \:  \;  \!  \quad  \qquad  \hfil  \hfill
     \displaystyle  \textstyle  \dsize  \tsize
     \scriptstyle  \scriptscriptstyle  \ssize  \ssize
     \rm  \bf  \it  \sl  \roman  \bold  \italic  \slanted
     \cal  \mit  \Cal  \Bbb  \frak  \goth
     \evalto

Note that, because these symbols are ignored, reading a TeX formula
into Calc and writing it back out may lose spacing and font information.

Also, the "discretionary multiplication sign" `\*' is read
the same as `*'.

The TeX version of this manual includes some printed examples at the
end of this section.


File: calc.info  Node: Eqn Language Mode, Prev: TeX Language Mode, Up: Language Modes, Next: Mathematica Language Mode

Eqn Language Mode
-----------------

"Eqn" is another popular formatter for math formulas.  It is
designed for use with the TROFF text formatter, and comes standard
with many versions of Unix.  The `d E' (`calc-eqn-language')
command selects "eqn" notation.

The "eqn" language's main idiosyncrasy is that whitespace plays
a significant part in the parsing of the language.  For example,
`sqrt x+1 + y' treats `x+1' as the argument of the
`sqrt' operator.  "Eqn" also understands more conventional
grouping using curly braces:  `sqrt{x+1} + y'.  Braces are
required only when the argument contains spaces.

In Calc's "eqn" mode, however, curly braces are required to
delimit arguments of operators like `sqrt'.  The first of the
above examples would treat only the `x' as the argument of
`sqrt', and in fact `sin x+1' would be interpreted as
`sin * x + 1', because `sin' is not a special operator
in the "eqn" language.  If you always surround the argument
with curly braces, Calc will never misunderstand.

Calc also understands parentheses as grouping characters.  Another
peculiarity of "eqn"'s syntax makes it advisable to separate
words with spaces from any surrounding characters that aren't curly
braces, so Calc writes `sin ( x + y )' in "eqn" mode.
(The spaces around `sin' are important to make "eqn"
recognize that `sin' should be typeset in a roman font, and
the spaces around `x' and `y' are a good idea just in
case the "eqn" document has defined special meanings for these
names, too.)

Powers and subscripts are written with the `sub' and `sup'
operators, respectively.  Note that the caret symbol `^' is
treated the same as a space in "eqn" mode, as is the `~'
symbol (these are used to introduce spaces of various widths into
the typeset output of "eqn").

As in TeX mode, Calc's formatter omits parentheses around the
arguments of functions like `ln' and `sin' if they are
"simple-looking"; in this case Calc surrounds the argument with
braces, separated by a `~' from the function name: `sin~{x}'.

Font change codes (like `roman X') and positioning codes
(like `~' and `down N X') are ignored by the
"eqn" reader.  Also ignored are the words `left', `right',
`mark', and `lineup'.  Quotation marks in "eqn" mode input
are treated the same as curly braces: `sqrt "1+x"' is equivalent to
`sqrt {1+x}'; this is only an approximation to the true meaning
of quotes in "eqn", but it is good enough for most uses.

Accent codes (`X dot') are handled by treating them as
function calls (`dot(X)') internally.  *Note TeX Language Mode:: for a table of these accent functions.  The `prime' accent
is treated specially if it occurs on a variable or function name:
`f prime prime ( x prime )' is stored internally as `f"(x')'.
For example, taking the derivative of `f(2 x)' with `a d x'
will produce `2 f'(2 x)', which "eqn" mode will display as
`2 f prime ( 2 x )'.

Assignments are written with the `<-' (left-arrow) symbol,
and `evalto' operators are written with `->' or
`evalto ... ->' (*Note TeX Language Mode::, for a discussion
of this).  The regular Calc symbols `:=' and `=>' are also
recognized for these operators during reading.

Vectors in "eqn" mode use regular Calc square brackets, but
matrices are formatted as `matrix { ccol { a above b } ... }'.
The words `lcol' and `rcol' are recognized as synonyms
for `ccol' during input, and are generated instead of `ccol'
if the matrix justification mode so specifies.


File: calc.info  Node: Mathematica Language Mode, Prev: Eqn Language Mode, Up: Language Modes, Next: Maple Language Mode

Mathematica Language Mode
-------------------------

The `d M' (`calc-mathematica-language') command selects the
conventions of Mathematica, a powerful and popular mathematical tool
from Wolfram Research, Inc.  Notable differences in Mathematica mode
are that the names of built-in functions are capitalized, and function
calls use square brackets instead of parentheses.  Thus the Calc
formula `sin(2 x)' is entered and displayed `Sin[2 x]' in
Mathematica mode.

Vectors and matrices use curly braces in Mathematica.  Complex numbers
are written `3 + 4 I'.  The standard special constants in Calc are
written `Pi', `E', `I', `GoldenRatio', `EulerGamma', `Infinity',
`ComplexInfinity', and `Indeterminate' in Mathematica mode.  Non-decimal
numbers are written, e.g., `16^^7fff'.  Floating-point numbers in
scientific notation are written `1.23*10.^3'.  Subscripts use double
square brackets: `a[[i]]'.


File: calc.info  Node: Maple Language Mode, Prev: Mathematica Language Mode, Up: Language Modes, Next: Compositions

Maple Language Mode
-------------------

The `d W' (`calc-maple-language') command selects the
conventions of Maple, another mathematical tool from the University
of Waterloo.  

Maple's language is much like C.  Underscores are allowed in symbol
names; square brackets are used for subscripts; explicit `*'s for
multiplications are required.  Use either `^' or `**' to
denote powers.

Maple uses square brackets for lists and curly braces for sets.  Calc
interprets both notations as vectors, and displays vectors with square
brackets.  This means Maple sets will be converted to lists when they
pass through Calc.  As a special case, matrices are written as calls
to the function `matrix', given a list of lists as the argument,
and can be read in this form or with all-capitals `MATRIX'.

The Maple interval notation `2 .. 3' has no surrounding brackets;
Calc reads `2 .. 3' as the closed interval `[2 .. 3]', and
writes any kind of interval as `2 .. 3'.  This means you cannot
see the difference between an open and a closed interval while in
Maple display mode.

Maple writes complex numbers as `3 + 4*I'.  Its special constants
are `Pi', `E', `I', and `infinity' (all three of
`inf', `uinf', and `nan' display as `infinity').
Floating-point numbers are written `1.23*10.^3'.

Among things not currently handled by Calc's Maple mode are the
various quote symbols, procedures and functional operators, and
inert (`&') operators.


File: calc.info  Node: Compositions, Prev: Maple Language Mode, Up: Language Modes

Compositions
------------

There are several "composition functions" which allow you to get
displays in a variety of formats similar to those in Big language
mode.  Most of these functions do not evaluate to anything; they are
placeholders which are left in symbolic form by Calc's evaluator but
are recognized by Calc's display formatting routines.

Two of these, `string' and `bstring', are described elsewhere.
*Note Strings::.  For example, `string("ABC")' is displayed as
`ABC'.  When viewed on the stack it will be indistinguishable from
the variable `ABC', but internally it will be stored as
`string([65, 66, 67])' and can still be manipulated this way; for
example, the selection and vector commands `j 1 v v j u' would
select the vector portion of this object and reverse the elements, then
deselect to reveal a string whose characters had been reversed.

The composition functions do the same thing in all language modes
(although their components will of course be formatted in the current
language mode).  The one exception is Unformatted mode (`d U'),
which does not give the composition functions any special treatment.
The functions are discussed here because of their relationship to
the language modes.

* Menu:

* Composition Basics::
* Horizontal Compositions::
* Vertical Compositions::
* Other Compositions::
* Information about Compositions::
* User-Defined Compositions::


File: calc.info  Node: Composition Basics, Prev: Compositions, Up: Compositions, Next: Horizontal Compositions

Compositions
............

Compositions are generally formed by stacking formulas together
horizontally or vertically in various ways.  Those formulas are
themselves compositions.  TeX users will find this analogous
to TeX's "boxes."  Each multi-line composition has a
"baseline"; horizontal compositions use the baselines to
decide how formulas should be positioned relative to one another.
For example, in the Big mode formula

               2
          a + b
     17 + ------
            c

the second term of the sum is four lines tall and has line three as
its baseline.  Thus when the term is combined with 17, line three
is placed on the same level as the baseline of 17.


Another important composition concept is "precedence".  This is
an integer that represents the binding strength of various operators.
For example, `*' has higher precedence (195) than `+' (180),
which means that `(a * b) + c' will be formatted without the
parentheses, but `a * (b + c)' will keep the parentheses.

The operator table used by normal and Big language modes has the
following precedences:

     _     1200   (subscripts)
     %     1100   (as in n%)
     -     1000   (as in -n)
     !     1000   (as in !n)
     mod    400
     +/-    300
     !!     210    (as in n!!)
     !      210    (as in n!)
     ^      200
     *      195    (or implicit multiplication)
     / % \  190
     + -    180    (as in a+b)
     |      170
     < =    160    (and other relations)
     &&     110
     ||     100
     ? :     90
     !!!     85
     &&&     80
     |||     75
     :=      50
     ::      45
     =>      40

The general rule is that if an operator with precedence `n'
occurs as an argument to an operator with precedence `m', then
the argument is enclosed in parentheses if `n < m'.  Top-level
expressions and expressions which are function arguments, vector
components, etc., are formatted with precedence zero (so that they
normally never get additional parentheses).

For binary left-associative operators like `+', the righthand
argument is actually formatted with one-higher precedence than shown
in the table.  This makes sure `(a + b) + c' omits the parentheses,
but the unnatural form `a + (b + c)' keeps its parentheses.
Right-associative operators like `^' format the lefthand argument
with one-higher precedence.

The `cprec' function formats an expression with an arbitrary
precedence.  For example, `cprec(abc, 185)' will combine into
sums and products as follows:  `7 + abc', `7 (abc)' (because
this `cprec' form has higher precedence than addition, but lower
precedence than multiplication).


A final composition issue is "line breaking".  Calc uses two
different strategies for "flat" and "non-flat" compositions.
A non-flat composition is anything that appears on multiple lines
(not counting line breaking).  Examples would be matrices, and Big
mode powers and quotients.  Non-flat compositions are displayed
exactly as specified.  If they come out wider than the current
window, you must use horizontal scrolling (`<' and `>') to
view them.

Flat compositions, on the other hand, will be broken across several
lines if they are too wide to fit the window.  Certain points in a
composition are noted internally as "break points".  Calc's
general strategy is to fill each line as much as possible, then to
move down to the next line starting at the first break point that
didn't fit.  However, the line breaker understands the hierarchical
structure of formulas.  It will not break an "inner" formula if
it can use an earlier break point from an "outer" formula instead.
For example, a vector of sums might be formatted as:

     [ a + b + c, d + e + f,
       g + h + i, j + k + l, m ]

If the `m' can fit, then so, it seems, could the `g'.
But Calc prefers to break at the comma since the comma is part
of a "more outer" formula.  Calc would break at a plus sign
only if it had to, say, if the very first sum in the vector had
itself been too large to fit.

Of the composition functions described below, only `choriz'
generates break points.  The `bstring' function (*Note Strings::)
also generates breakable items:  A break point is added after every
space (or group of spaces) except for spaces at the very beginning or
end of the string.

Composition functions themselves count as levels in the formula
hierarchy, so a `choriz' that is a component of a larger
`choriz' will be less likely to be broken.  As a special case,
if a `bstring' occurs as a component of a `choriz' or
`choriz'-like object (such as a vector or a list of arguments
in a function call), then the break points in that `bstring'
will be on the same level as the break points of the surrounding
object.


File: calc.info  Node: Horizontal Compositions, Prev: Composition Basics, Up: Compositions, Next: Vertical Compositions

Horizontal Compositions
.......................

The `choriz' function takes a vector of objects and composes
them horizontally.  For example, `choriz([17, a b/c, d])' formats
as `17a b / cd' in normal language mode, or as

       a b
     17---d
        c

in Big language mode.  This is actually one case of the general
function `choriz(VEC, SEP, PREC)', where
either or both of SEP and PREC may be omitted.
PREC gives the "precedence" to use when formatting
each of the components of VEC.  The default precedence is
the precedence from the surrounding environment.

SEP is a string (i.e., a vector of character codes as might
be entered with `" "' notation) which should separate components
of the composition.  Also, if SEP is given, the line breaker
will allow lines to be broken after each occurrence of SEP.
If SEP is omitted, the composition will not be breakable
(unless any of its component compositions are breakable).

For example, `2 choriz([a, b c, d = e], " + ", 180)' is
formatted as `2 a + b c + (d = e)'.  To get the `choriz'
to have precedence 180 "outwards" as well as "inwards",
enclose it in a `cprec' form:  `2 cprec(choriz(...), 180)'
formats as `2 (a + b c + (d = e))'.

The baseline of a horizontal composition is the same as the
baselines of the component compositions, which are all aligned.


File: calc.info  Node: Vertical Compositions, Prev: Horizontal Compositions, Up: Compositions, Next: Other Compositions

Vertical Compositions
.....................

The `cvert' function makes a vertical composition.  Each
component of the vector is centered in a column.  The baseline of
the result is by default the top line of the resulting composition.
For example, `f(cvert([a, bb, ccc]), cvert([a^2 + 1, b^2]))'
formats in Big mode as

     f( a ,  2    )
       bb   a  + 1
       ccc     2
              b

There are several special composition functions that work only as
components of a vertical composition.  The `cbase' function
controls the baseline of the vertical composition; the baseline
will be the same as the baseline of whatever component is enclosed
in `cbase'.  Thus `f(cvert([a, cbase(bb), ccc]),
cvert([a^2 + 1, cbase(b^2)]))' displays as

             2
            a  + 1
        a      2
     f(bb ,   b   )
       ccc

There are also `ctbase' and `cbbase' functions which
make the baseline of the vertical composition equal to the top
or bottom line (rather than the baseline) of that component.
Thus `cvert([cbase(a / b)]) + cvert([ctbase(a / b)]) +
cvert([cbbase(a / b)])' gives

             a
     a       -
     - + a + b
     b   -
         b

There should be only one `cbase', `ctbase', or `cbbase'
function in a given vertical composition.  These functions can also
be written with no arguments:  `ctbase()' is a zero-height object
which means the baseline is the top line of the following item, and
`cbbase()' means the baseline is the bottom line of the preceding
item.

The `crule' function builds a "rule," or horizontal line,
across a vertical composition.  By itself `crule()' uses `-'
characters to build the rule.  You can specify any other character,
e.g., `crule("=")'.  The argument must be a character code or
vector of exactly one character code.  It is repeated to match the
width of the widest item in the stack.  For example, a quotient
with a thick line is `cvert([a + 1, cbase(crule("=")), b^2])':

     a + 1
     =====
       2
      b

Finally, the functions `clvert' and `crvert' act exactly
like `cvert' except that the items are left- or right-justified
in the stack.  Thus `clvert([a, bb, ccc]) + crvert([a, bb, ccc])'
gives:

     a   +   a
     bb     bb
     ccc   ccc

Like `choriz', the vertical compositions accept a second argument
which gives the precedence to use when formatting the components.
Vertical compositions do not support separator strings.


File: calc.info  Node: Other Compositions, Prev: Vertical Compositions, Up: Compositions, Next: Information about Compositions

Other Compositions
..................

The `csup' function builds a superscripted expression.  For
example, `csup(a, b)' looks the same as `a^b' does in Big
language mode.  This is essentially a horizontal composition of
`a' and `b', where `b' is shifted up so that its
bottom line is one above the baseline.

Likewise, the `csub' function builds a subscripted expression.
This shifts `b' down so that its top line is one below the
bottom line of `a' (note that this is not quite analogous to
`csup').  Other arrangements can be obtained by using
`choriz' and `cvert' directly.

The `cflat' function formats its argument in "flat" mode,
as obtained by `d O', if the current language mode is normal
or Big.  It is invisible in other language modes.  For example,
`a^(b/c)' is formatted by Big mode like `csup(a, cflat(b/c))'
to improve its readability.

The `cspace' function creates horizontal space.  For example,
`cspace(4)' is effectively the same as `string("    ")'.
A second string (i.e., vector of characters) argument is repeated
instead of the space character.  For example, `cspace(4, "ab")'
looks like `abababab'.  If the second argument is not a string,
it is formatted in the normal way and then several copies of that
are composed together:  `cspace(4, a^2)' yields

      2 2 2 2
     a a a a

If the number argument is zero, this is a zero-width object.

The `cvspace' function creates vertical space, or a vertical
stack of copies of a certain string or formatted object.  The
baseline is the center line of the resulting stack.  A numerical
argument of zero will produce an object which contributes zero
height if used in a vertical composition.

There are also `ctspace' and `cbspace' functions which
create vertical space with the baseline the same as the baseline
of the top or bottom copy, respectively, of the second argument.
Thus `cvspace(2, a/b) + ctspace(2, a/b) + cbspace(2, a/b)'
displays as:

             a
             -
     a       b
     -   a   a
     b + - + -
     a   b   b
     -   a
     b   -
         b


File: calc.info  Node: Information about Compositions, Prev: Other Compositions, Up: Compositions, Next: User-Defined Compositions

Information about Compositions
..............................

The functions in this section are actual functions; they compose their
arguments according to the current language and other display modes,
then return a certain measurement of the composition as an integer.

The `cwidth' function measures the width, in characters, of a
composition.  For example, `cwidth(a + b)' is 5, and
`cwidth(a / b)' is 5 in normal mode, 1 in Big mode, and 11 in
TeX mode (for `{a \over b}').  The argument may involve
the composition functions described in this section.

The `cheight' function measures the height of a composition.
This is the total number of lines in the argument's printed form.

The functions `cascent' and `cdescent' measure the amount
of the height that is above (and including) the baseline, or below
the baseline, respectively.  Thus `cascent(X) + cdescent(X)'
always equals `cheight(X)'.  For a one-line formula like
`a + b', `cascent' returns 1 and `cdescent' returns 0.
For `a / b' in Big mode, `cascent' returns 2 and `cdescent'
returns 1.  The only formula for which `cascent' will return zero
is `cvspace(0)' or equivalents.


File: calc.info  Node: User-Defined Compositions, Prev: Information about Compositions, Up: Compositions

User-Defined Compositions
.........................

The `Z C' (`calc-user-define-composition') command lets you
define the display format for any algebraic function.  You provide a
formula containing a certain number of argument variables on the stack.
Any time Calc formats a call to the specified function in the current
language mode and with that number of arguments, Calc effectively
replaces the function call with that formula with the arguments
replaced.

Calc builds the default argument list by sorting all the variable names
that appear in the formula into alphabetical order.  You can edit this
argument list before pressing RET if you wish.  Any variables in
the formula that do not appear in the argument list will be displayed
literally; any arguments that do not appear in the formula will not
affect the display at all.

You can define formats for built-in functions, for functions you have
defined with `Z F' (*Note Algebraic Definitions::), or for functions
which have no definitions but are being used as purely syntactic objects.
You can define different formats for each language mode, and for each
number of arguments, using a succession of `Z C' commands.  When
Calc formats a function call, it first searches for a format defined
for the current language mode (and number of arguments); if there is
none, it uses the format defined for the Normal language mode.  If
neither format exists, Calc uses its built-in standard format for that
function (usually just `FUNC(ARGS)').

If you execute `Z C' with the number 0 on the stack instead of a
formula, any defined formats for the function in the current language
mode will be removed.  The function will revert to its standard format.

For example, the default format for the binomial coefficient function
`choose(n, m)' in the Big language mode is

      n
     ( )
      m

You might prefer the notation,

      C
     n m

To define this notation, first make sure you are in Big mode,
then put the formula

     choriz([cvert([cvspace(1), n]), C, cvert([cvspace(1), m])])

on the stack and type `Z C'.  Answer the first prompt with
`choose'.  The second prompt will be the default argument list
of `(C m n)'.  Edit this list to be `(n m)' and press
RET.  Now, try it out:  For example, turn simplification
off with `m O' and enter `choose(a,b) + choose(7,3)'
as an algebraic entry.

      C  +  C 
     a b   7 3

As another example, let's define the usual notation for Stirling
numbers of the first kind, `stir1(n, m)'.  This is just like
the regular format for binomial coefficients but with square brackets
instead of parentheses.

     choriz([string("["), cvert([n, cbase(cvspace(1)), m]), string("]")])

Now type `Z C stir1 RET', edit the argument list to
`(n m)', and type RET.

The formula provided to `Z C' usually will involve composition
functions, but it doesn't have to.  Putting the formula `a + b + c'
onto the stack and typing `Z C foo RET RET' would define
the function `foo(x,y,z)' to display like `x + y + z'.
This "sum" will act exactly like a real sum for all formatting
purposes (it will be parenthesized the same, and so on).  However
it will be computationally unrelated to a sum.  For example, the
formula `2 * foo(1, 2, 3)' will display as `2 (1 + 2 + 3)'.
Operator precedences have caused the "sum" to be written in
parentheses, but the arguments have not actually been summed.
(Generally a display format like this would be undesirable, since
it can easily be confused with a real sum.)

The special function `eval' can be used inside a `Z C'
composition formula to cause all or part of the formula to be
evaluated at display time.  For example, if the formula is
`a + eval(b + c)', then `foo(1, 2, 3)' will be displayed
as `1 + 5'.  Evaluation will use the default simplifications,
regardless of the current simplification mode.  There are also
`evalsimp' and `evalextsimp' which simplify as if by
`a s' and `a e' (respectively).  Note that these "functions"
operate only in the context of composition formulas (and also in
rewrite rules, where they serve a similar purpose; *Note Rewrite Rules::).  On the stack, a call to `eval' will be left in
symbolic form.

It is not a good idea to use `eval' except as a last resort.
It can cause the display of formulas to be extremely slow.  For
example, while `eval(a + b)' might seem quite fast and simple,
there are several situations where it could be slow.  For example,
`a' and/or `b' could be polar complex numbers, in which
case doing the sum requires trigonometry.  Or, `a' could be
the factorial `fact(100)' which is unevaluated because the
user has typed `m O'; `eval' will evaluate it anyway to
produce a large, unwieldy integer.

You can save your display formats permanently using the `Z P'
command (*Note Creating User Keys::).


File: calc.info  Node: Calc Mode Line, Prev: Language Modes, Up: Mode Settings

The Calc Mode Line
==================

This section is a summary of all symbols that can appear on the
Calc mode line, the highlighted bar that appears under the Calc
stack window (or under an editing window in Embedded Mode).

The basic mode line format is:

     --%%-Calc: 12 Deg OTHER MODES       (Calculator)

The `%%' is the Emacs symbol for "read-only"; it shows that
regular Emacs commands are not allowed to edit the stack buffer
as if it were text.

The word `Calc:' changes to `CalcEmbed:' if Embedded Mode
is enabled.  The words after this describe the various Calc modes
that are in effect.

The first mode is always the current precision, an integer.
The second mode is always the angular mode, either `Deg',
`Rad', or `Hms'.

Here is a complete list of the remaining symbols that can appear
on the mode line:

`Alg'
     Algebraic mode (`m a'; *Note Algebraic Entry::).

`Alg[('
     Incomplete algebraic mode (`C-u m a').

`Alg*'
     Total algebraic mode (`m t').

`Symb'
     Symbolic mode (`m s'; *Note Symbolic Mode::).

`Matrix'
     Matrix mode (`m v'; *Note Matrix Mode::).

`MatrixN'
     Dimensioned matrix mode (`C-u N m v').

`Scalar'
     Scalar mode (`m v'; *Note Matrix Mode::).

`Polar'
     Polar complex mode (`m p'; *Note Polar Mode::).

`Frac'
     Fraction mode (`m f'; *Note Fraction Mode::).

`Inf'
     Infinite mode (`m i'; *Note Infinite Mode::).

`+Inf'
     Positive infinite mode (`C-u 0 m i').

`NoSimp'
     Default simplifications off (`m O'; *Note Simplification Modes::).

`NumSimp'
     Default simplifications for numeric arguments only (`m N').

`BinSimpW'
     Binary-integer simplification mode; word size W (`m B').

`AlgSimp'
     Algebraic simplification mode (`m A').

`ExtSimp'
     Extended algebraic simplification mode (`m E').

`UnitSimp'
     Units simplification mode (`m U').

`Bin'
     Current radix is 2 (`d 2'; *Note Radix Modes::).

`Oct'
     Current radix is 8 (`d 8').

`Hex'
     Current radix is 16 (`d 6').

`RadixN'
     Current radix is N (`d r').

`Zero'
     Leading zeros (`d z'; *Note Radix Modes::).

`Flat'
     One-line normal language mode (`d O'; *Note Normal Language Modes::).

`Big'
     Big language mode (`d B').

`Unform'
     Unformatted language mode (`d U').

`C'
     C language mode (`d C'; *Note C FORTRAN Pascal::).

`Pascal'
     Pascal language mode (`d P').

`Fortran'
     FORTRAN language mode (`d F').

`TeX'
     TeX language mode (`d T'; *Note TeX Language Mode::).

`Eqn'
     "Eqn" language mode (`d E'; *Note Eqn Language Mode::).

`Math'
     Mathematica language mode (`d M'; *Note Mathematica Language Mode::).

`Maple'
     Maple language mode (`d W'; *Note Maple Language Mode::).

`NormN'
     Normal float mode with N digits (`d n'; *Note Float Formats::).

`FixN'
     Fixed point mode with N digits after the point (`d f').

`Sci'
     Scientific notation mode (`d s').

`SciN'
     Scientific notation with N digits (`d s').

`Eng'
     Engineering notation mode (`d e').

`EngN'
     Engineering notation with N digits (`d e').

`LeftN'
     Left-justified display indented by N (`d <'; *Note Justification::).

`Right'
     Right-justified display (`d >').

`RightN'
     Right-justified display with width N (`d >').

`Center'
     Centered display (`d =').

`CenterN'
     Centered display with center column N (`d =').

`WidN'
     Line breaking with width N (`d b'; *Note Normal Language Modes::).

`Wide'
     No line breaking (`d b').

`Break'
     Selections show deep structure (`j b'; *Note Making Selections::).

`Save'
     Record modes in `~/.emacs' (`m R'; *Note General Mode Commands::).

`Local'
     Record modes in Embedded buffer (`m R').

`LocEdit'
     Record modes as editing-only in Embedded buffer (`m R').

`LocPerm'
     Record modes as permanent-only in Embedded buffer (`m R').

`Global'
     Record modes as global in Embedded buffer (`m R').

`Manual'
     Automatic recomputation turned off (`m C'; *Note Automatic Recomputation::).

`Graph'
     GNUPLOT process is alive in background (*Note Graphics::).

`Sel'
     Top-of-stack has a selection (Embedded only; *Note Making Selections::).

`Dirty'
     The stack display may not be up-to-date (*Note Display Modes::).

`Inv'
     "Inverse" prefix was pressed (`I'; *Note Inverse and Hyperbolic::).

`Hyp'
     "Hyperbolic" prefix was pressed (`H').

`Keep'
     "Keep-arguments" prefix was pressed (`K').

`Narrow'
     Stack is truncated (`d t'; *Note Truncating the Stack::).

In addition, the symbols `Active' and `~Active' can appear
as minor modes on an Embedded buffer's mode line.  *Note Embedded Mode::.


File: calc.info  Node: Arithmetic, Prev: Mode Settings, Up: Top, Next: Scientific Functions

Arithmetic Functions
********************

This chapter describes the Calc commands for doing simple calculations
on numbers, such as addition, absolute value, and square roots.  These
commands work by removing the top one or two values from the stack,
performing the desired operation, and pushing the result back onto the
stack.  If the operation cannot be performed, the result pushed is a
formula instead of a number, such as `2/0' (because division by zero
is illegal) or `sqrt(x)' (because the argument `x' is a formula).

Most of the commands described here can be invoked by a single keystroke.
Some of the more obscure ones are two-letter sequences beginning with
the `f' ("functions") prefix key.

*Note Prefix Arguments::, for a discussion of the effect of numeric
prefix arguments on commands in this chapter which do not otherwise
interpret a prefix argument.

* Menu:

* Basic Arithmetic::
* Integer Truncation::
* Complex Number Functions::
* Conversions::
* Date Arithmetic::
* Financial Functions::
* Binary Functions::


File: calc.info  Node: Basic Arithmetic, Prev: Arithmetic, Up: Arithmetic, Next: Integer Truncation

Basic Arithmetic
================

The `+' (`calc-plus') command adds two numbers.  The numbers may
be any of the standard Calc data types.  The resulting sum is pushed back
onto the stack.

If both arguments of `+' are vectors or matrices (of matching dimensions),
the result is a vector or matrix sum.  If one argument is a vector and the
other a scalar (i.e., a non-vector), the scalar is added to each of the
elements of the vector to form a new vector.  If the scalar is not a
number, the operation is left in symbolic form:  Suppose you added `x'
to the vector `[1,2]'.  You may want the result `[1+x,2+x]', or
you may plan to substitute a 2-vector for `x' in the future.  Since
the Calculator can't tell which interpretation you want, it makes the
safest assumption.  *Note Reducing and Mapping::, for a way to add `x'
to every element of a vector.

If either argument of `+' is a complex number, the result will in general
be complex.  If one argument is in rectangular form and the other polar,
the current Polar Mode determines the form of the result.  If Symbolic
Mode is enabled, the sum may be left as a formula if the necessary
conversions for polar addition are non-trivial.

If both arguments of `+' are HMS forms, the forms are added according to
the usual conventions of hours-minutes-seconds notation.  If one argument
is an HMS form and the other is a number, that number is converted from
degrees or radians (depending on the current Angular Mode) to HMS format
and then the two HMS forms are added.

If one argument of `+' is a date form, the other can be either a
real number, which advances the date by a certain number of days, or
an HMS form, which advances the date by a certain amount of time.
Subtracting two date forms yields the number of days between them.
Adding two date forms is meaningless, but Calc interprets it as the
subtraction of one date form and the negative of the other.  (The
negative of a date form can be understood by remembering that dates
are stored as the number of days before or after Jan 1, 1 AD.)

If both arguments of `+' are error forms, the result is an error form
with an appropriately computed standard deviation.  If one argument is an
error form and the other is a number, the number is taken to have zero error.
Error forms may have symbolic formulas as their mean and/or error parts;
adding these will produce a symbolic error form result.  However, adding an
error form to a plain symbolic formula (as in `(a +/- b) + c') will not
work, for the same reasons just mentioned for vectors.  Instead you must
write `(a +/- b) + (c +/- 0)'.

If both arguments of `+' are modulo forms with equal values of `M',
or if one argument is a modulo form and the other a plain number, the
result is a modulo form which represents the sum, modulo `M', of
the two values.

If both arguments of `+' are intervals, the result is an interval
which describes all possible sums of the possible input values.  If one
argument is a plain number, it is treated as the interval `[x .. x]'.

If one argument of `+' is an infinity and the other is not, the
result is that same infinity.  If both arguments are infinite and in
the same direction, the result is the same infinity, but if they are
infinite in different directions the result is `nan'.

The `-' (`calc-minus') command subtracts two values.  The top
number on the stack is subtracted from the one behind it, so that the
computation `5 RET 2 -' produces 3, not -3.  All options
available for `+' are available for `-' as well.

The `*' (`calc-times') command multiplies two numbers.  If one
argument is a vector and the other a scalar, the scalar is multiplied by
the elements of the vector to produce a new vector.  If both arguments
are vectors, the interpretation depends on the dimensions of the
vectors:  If both arguments are matrices, a matrix multiplication is
done.  If one argument is a matrix and the other a plain vector, the
vector is interpreted as a row vector or column vector, whichever is
dimensionally correct.  If both arguments are plain vectors, the result
is a single scalar number which is the dot product of the two vectors.

If one argument of `*' is an HMS form and the other a number, the
HMS form is multiplied by that amount.  It is an error to multiply two
HMS forms together, or to attempt any multiplication involving date
forms.  Error forms, modulo forms, and intervals can be multiplied;
see the comments for addition of those forms.  When two error forms
or intervals are multiplied they are considered to be statistically
independent; thus, `[-2 .. 3] * [-2 .. 3]' is `[-6 .. 9]',
whereas `[-2 .. 3] ^ 2' is `[0 .. 9]'.

The `/' (`calc-divide') command divides two numbers.  When
dividing a scalar `B' by a square matrix `A', the computation
performed is `B' times the inverse of `A'.  This also occurs
if `B' is itself a vector or matrix, in which case the effect is
to solve the set of linear equations represented by `B'.  If `B'
is a matrix with the same number of rows as `A', or a plain vector
(which is interpreted here as a column vector), then the equation
`A X = B' is solved for the vector or matrix `X'.  Otherwise,
if `B' is a non-square matrix with the same number of *columns*
as `A', the equation `X A = B' is solved.  If you wish a vector
`B' to be interpreted as a row vector to be solved as `X A = B',
make it into a one-row matrix with `C-u 1 v p' first.  To force a
left-handed solution with a square matrix `B', transpose `A' and
`B' before dividing, then transpose the result.

HMS forms can be divided by real numbers or by other HMS forms.  Error
forms can be divided in any combination of ways.  Modulo forms where both
values and the modulo are integers can be divided to get an integer modulo
form result.  Intervals can be divided; dividing by an interval that
encompasses zero or has zero as a limit will result in an infinite
interval.

The `^' (`calc-power') command raises a number to a power.  If
the power is an integer, an exact result is computed using repeated
multiplications.  For non-integer powers, Calc uses Newton's method or
logarithms and exponentials.  Square matrices can be raised to integer
powers.  If either argument is an error (or interval or modulo) form,
the result is also an error (or interval or modulo) form.

If you press the `I' (inverse) key first, the `I ^' command
computes an Nth root:  `125 RET 3 I ^' computes the number 5.
(This is entirely equivalent to `125 RET 1:3 ^'.)

The `%' (`calc-mod') command performs a "modulo" (or "remainder")
operation.  Mathematically, `a%b = a - floor(a/b)*b', and is defined
for all real numbers `a' and `b' (except `b=0').  For
positive `b', the result will always be between 0 (inclusive) and
`b' (exclusive).  Modulo does not work for HMS forms and error forms.
If `a' is a modulo form, its modulo is changed to `b', which
must be positive real number.

The `\' (`calc-idiv') command divides two numbers on the stack
to produce an integer result.  It is equivalent to dividing with
/, then rounding down with `F' (`calc-floor'), only a bit
more convenient and efficient.  Also, since it is an all-integer
operation when the arguments are integers, it avoids problems that
`/ F' would have with floating-point roundoff.

The `:' (`calc-fdiv') command [`fdiv' function in a formula]
divides the two integers on the top of the stack to produce a fractional
result.  This is a convenient shorthand for enabling Fraction Mode (with
`m f') temporarily and using `/'.  Note that during numeric entry
the `:' key is interpreted as a fraction separator, so to divide 8 by 6
you would have to type `8 RET 6 RET :'.  (Of course, in
this case, it would be much easier simply to enter the fraction directly
as `8:6 RET'!)

The `n' (`calc-change-sign') command negates the number on the top
of the stack.  It works on numbers, vectors and matrices, HMS forms, date
forms, error forms, intervals, and modulo forms.

The `A' (`calc-abs') [`abs'] command computes the absolute
value of a number.  The result of `abs' is always a nonnegative
real number:  With a complex argument, it computes the complex magnitude.
With a vector or matrix argument, it computes the Frobenius norm, i.e.,
the square root of the sum of the squares of the absolute values of the
elements.  The absolute value of an error form is defined by replacing
the mean part with its absolute value and leaving the error part the same.
The absolute value of a modulo form is undefined.  The absolute value of
an interval is defined in the obvious way.

The `f A' (`calc-abssqr') [`abssqr'] command computes the
absolute value squared of a number, vector or matrix, or error form.

The `f s' (`calc-sign') [`sign'] command returns 1 if its
argument is positive, -1 if its argument is negative, or 0 if its
argument is zero.  In algebraic form, you can also write `sign(a,x)'
which evaluates to `x * sign(a)', i.e., either `x', `-x', or
zero depending on the sign of `a'.

The `&' (`calc-inv') [`inv'] command computes the
reciprocal of a number, i.e., `1 / x'.  Operating on a square
matrix, it computes the inverse of that matrix.

The `Q' (`calc-sqrt') [`sqrt'] command computes the square
root of a number.  For a negative real argument, the result will be a
complex number whose form is determined by the current Polar Mode.

The `f h' (`calc-hypot') [`hypot'] command computes the square
root of the sum of the squares of two numbers.  That is, `hypot(a,b)'
is the length of the hypotenuse of a right triangle with sides `a'
and `b'.  If the arguments are complex numbers, their squared
magnitudes are used.

The `f Q' (`calc-isqrt') [`isqrt'] command computes the
integer square root of an integer.  This is the true square root of the
number, rounded down to an integer.  For example, `isqrt(10)'
produces 3.  Note that, like `\' [`idiv'], this uses exact
integer arithmetic throughout to avoid roundoff problems.  If the input
is a floating-point number or other non-integer value, this is exactly
the same as `floor(sqrt(x))'.

The `f n' (`calc-min') [`min'] and `f x' (`calc-max') [`max'] commands
take the minimum or maximum of two real numbers, respectively.  These
commands also work on HMS forms, date forms, intervals, and infinities.
(In algebraic expressions, these functions take any number of arguments
and return the maximum or minimum among all the arguments.)

The `f M' (`calc-mant-part') [`mant'] function extracts the "mantissa"
part `m' of its floating-point argument; `f X' (`calc-xpon-part')
[`xpon'] extracts the "exponent" part `e'.  The original number is equal
to `m * 10^e', where `m' is in the interval `[1.0 .. 10.0)' except that
`m=e=0' if the original number is zero.  For integers and fractions,
`mant' returns the number unchanged and `xpon' returns zero.  The `v u'
(`calc-unpack') command can also be used to "unpack" a floating-point
number; this produces an integer mantissa and exponent, with the
constraint that the mantissa is not a a multiple of ten (again except
for the `m=e=0' case).

The `f S' (`calc-scale-float') [`scf'] function scales a number by a
given power of ten.  Thus, `scf(mant(x), xpon(x)) = x' for any real `x'.
The second argument must be an integer, but the first may actually be
any numeric value.  For example, `scf(5,-2) = 0.05' or `1:20' depending
on the current Fraction Mode.

The `f [' (`calc-decrement') [`decr'] and `f ]'
(`calc-increment') [`incr'] functions decrease or increase
a number by one unit.  For integers, the effect is obvious.  For
floating-point numbers, the change is by one unit in the last place.
For example, incrementing `12.3456' when the current precision
is 6 digits yields `12.3457'.  If the current precision had been
8 digits, the result would have been `12.345601'.  Incrementing
`0.0' produces `10^-p', where `p' is the current
precision.  These operations are defined only on integers and floats.
With numeric prefix arguments, they change the number by `n' units.

Note that incrementing followed by decrementing, or vice-versa, will
almost but not quite always cancel out.  Suppose the precision is
6 digits and the number `9.99999' is on the stack.  Incrementing
will produce `10.0000'; decrementing will produce `9.9999'.
One digit has been dropped.  This is an unavoidable consequence of the
way floating-point numbers work.

Incrementing a date/time form adjusts it by a certain number of seconds.
Incrementing a pure date form adjusts it by a certain number of days.


File: calc.info  Node: Integer Truncation, Prev: Basic Arithmetic, Up: Arithmetic, Next: Complex Number Functions

Integer Truncation
==================

There are four commands for truncating a real number to an integer,
differing mainly in their treatment of negative numbers.  All of these
commands have the property that if the argument is an integer, the result
is the same integer.  An integer-valued floating-point argument is converted
to integer form.

If you press `H' (`calc-hyperbolic') first, the result will be
expressed as an integer-valued floating-point number.

The `F' (`calc-floor') [`floor' or `ffloor'] command truncates a real
number to the next lower integer, i.e., toward minus infinity.  Thus
`3.6 F' produces 3, but `_3.6 F' produces -4.

The `I F' (`calc-ceiling') [`ceil' or `fceil'] command truncates toward
positive infinity.  Thus `3.6 I F' produces 4, and `_3.6 I F' produces
-3.

The `R' (`calc-round') [`round' or `fround'] command rounds to the
nearest integer.  When the fractional part is .5 exactly, this command
rounds away from zero.  (All other rounding in the Calculator uses this
convention as well.)  Thus `3.5 R' produces 4 but `3.4 R' produces 3;
`_3.5 R' produces -4.

The `I R' (`calc-trunc') [`trunc' or `ftrunc'] command truncates toward
zero.  In other words, it "chops off" everything after the decimal
point.  Thus `3.6 I R' produces 3 and `_3.6 I R' produces -3.

These functions may not be applied meaningfully to error forms, but they
do work for intervals.  As a convenience, applying `floor' to a
modulo form floors the value part of the form.  Applied to a vector,
these functions operate on all elements of the vector one by one.
Applied to a date form, they operate on the internal numerical
representation of dates, converting a date/time form into a pure date.

There are two more rounding functions which can only be entered in
algebraic notation.  The `roundu' function is like `round'
except that it rounds up, toward plus infinity, when the fractional
part is .5.  This distinction matters only for negative arguments.
Also, `rounde' rounds to an even number in the case of a tie,
rounding up or down as necessary.  For example, `rounde(3.5)' and
`rounde(4.5)' both return 4, but `rounde(5.5)' returns 6.
The advantage of round-to-even is that the net error due to rounding
after a long calculation tends to cancel out to zero.  An important
subtle point here is that the number being fed to `rounde' will
already have been rounded to the current precision before `rounde'
begins.  For example, `rounde(2.500001)' with a current precision
of 6 will incorrectly, or at least surprisingly, yield 2 because the
argument will first have been rounded down to `2.5' (which
`rounde' sees as an exact tie between 2 and 3).

Each of these functions, when written in algebraic formulas, allows
a second argument which specifies the number of digits after the
decimal point to keep.  For example, `round(123.4567, 2)' will
produce the answer 123.46, and `round(123.4567, -1)' will
produce 120 (i.e., the cutoff is one digit to the *left* of
the decimal point).  A second argument of zero is equivalent to
no second argument at all.

To compute the fractional part of a number (i.e., the amount which, when
added to `floor(N)', will produce `N') just take `N' modulo 1 using the
`%' command.

Note also the `\' (integer quotient), `f I' (integer logarithm),
and `f Q' (integer square root) commands, which are analogous to
`\', `B', and `Q', respectively, except that they take integer
arguments and return the result rounded down to an integer.


