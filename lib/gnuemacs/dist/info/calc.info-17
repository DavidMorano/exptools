Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: Logical Operations, Prev: Summations, Up: Algebra, Next: Rewrite Rules

Logical Operations
==================

The following commands and algebraic functions return true/false values,
where 1 represents "true" and 0 represents "false."  In cases where
a truth value is required (such as for the condition part of a rewrite
rule, or as the condition for a `Z [  Z ]' control structure), any
nonzero value is accepted to mean "true."  (Specifically, anything
for which `dnonzero' returns 1 is "true," and anything for
which `dnonzero' returns 0 or cannot decide is assumed "false."
Note that this means that `Z [  Z ]' will execute the "then"
portion if its condition is provably true, but it will execute the
"else" portion if for any condition like `a = b' that is not
provably true, even if it might be true.  Algebraic functions that
have conditions as arguments, like `if' and `land', remain
unevaluated if the condition is neither provably true nor provable
false.  *Note Declarations::.)

The `a =' (`calc-equal-to') command, or `eq(a,b)' function
(which can also be written `a = b' or `a == b' in an algebraic
formula) is true if `a' and `b' are equal, either because they
are identical expressions, or because they are numbers which are
numerically equal.  (Thus the integer 1 is considered equal to the float
1.0.)  If the equality of `a' and `b' cannot be determined,
the comparison is left in symbolic form.  Note that as a command, this
operation pops two values from the stack and pushes back either a 1 or
a 0, or a formula `a = b' if the values' equality cannot be determined.

Many Calc commands use `=' formulas to represent "equations".
For example, the `a S' (`calc-solve-for') command rearranges
an equation to solve for a given variable.  The `a M'
(`calc-map-equation') command can be used to apply any
function to both sides of an equation; for example, `2 a M *'
multiplies both sides of the equation by two.  Note that just
`2 *' would not do the same thing; it would produce the formula
`2 (a = b)' which represents 2 if the equality is true or
zero if not.

The `eq' function with more than two arguments (e.g., `C-u 3 a ='
or `a = b = c') tests if all of its arguments are equal.  In
algebraic notation, the `=' operator is unusual in that it is
neither left- nor right-associative:  `a = b = c' is not the
same as `(a = b) = c' or `a = (b = c)' (which each compare
one variable with the 1 or 0 that results from comparing two other
variables).

The `a #' (`calc-not-equal-to') command, or `neq(a,b)' or
`a != b' function, is true if `a' and `b' are not equal.
This also works with more than two arguments; `a != b != c != d'
tests that all four of `a', `b', `c', and `d' are
distinct numbers.

The `a <' (`calc-less-than') [`lt(a,b)' or `a < b']
operation is true if `a' is less than `b'.  Similar functions
are `a >' (`calc-greater-than') [`gt(a,b)' or `a > b'],
`a [' (`calc-less-equal') [`leq(a,b)' or `a <= b'], and
`a ]' (`calc-greater-equal') [`geq(a,b)' or `a >= b'].

While the inequality functions like `lt' do not accept more
than two arguments, the syntax `a <= b < c' is translated to an
equivalent expression involving intervals: `b in [a .. c)'.
(See the description of `in' below.)  All four combinations
of `<' and `<=' are allowed, or any of the four combinations
of `>' and `>='.  Four-argument constructions like
`a < b < c < d', and mixtures like `a < b = c' that
involve both equalities and inequalities, are not allowed.

The `a .' (`calc-remove-equal') [`rmeq'] command extracts
the righthand side of the equation or inequality on the top of the
stack.  It also works elementwise on vectors.  For example, if
`[x = 2.34, y = z / 2]' is on the stack, then `a .' produces
`[2.34, z / 2]'.  As a special case, if the righthand side is a
variable and the lefthand side is a number (as in `2.34 = x'), then
Calc keeps the lefthand side instead.  Finally, this command works with
assignments `x := 2.34' as well as equations, always taking the
the righthand side, and for `=>' (evaluates-to) operators, always
taking the lefthand side.

The `a &' (`calc-logical-and') [`land(a,b)' or `a && b']
function is true if both of its arguments are true, i.e., are
non-zero numbers.  In this case, the result will be either `a' or
`b', chosen arbitrarily.  If either argument is zero, the result is
zero.  Otherwise, the formula is left in symbolic form.

The `a |' (`calc-logical-or') [`lor(a,b)' or `a || b']
function is true if either or both of its arguments are true (nonzero).
The result is whichever argument was nonzero, choosing arbitrarily if both
are nonzero.  If both `a' and `b' are zero, the result is
zero.

The `a !' (`calc-logical-not') [`lnot(a)' or `! a']
function is true if `a' is false (zero), or false if `a' is
true (nonzero).  It is left in symbolic form if `a' is not a
number.

The `a :' (`calc-logical-if') [`if(a,b,c)' or `a ? b : c']
function is equal to either `b' or `c' if `a' is a nonzero
number or zero, respectively.  If `a' is not a number, the test is
left in symbolic form and neither `b' nor `c' is evaluated in
any way.  In algebraic formulas, this is one of the few Calc functions
whose arguments are not automatically evaluated when the function itself
is evaluated.  The others are `lambda', `quote', and
`condition'.

One minor surprise to watch out for is that the formula `a?3:4'
will not work because the `3:4' is parsed as a fraction instead of
as three separate symbols.  Type something like `a ? 3 : 4' or
`a?(3):4' instead.

As a special case, if `a' evaluates to a vector, then both `b'
and `c' are evaluated; the result is a vector of the same length
as `a' whose elements are chosen from corresponding elements of
`b' and `c' according to whether each element of `a'
is zero or nonzero.  Each of `b' and `c' must be either a
vector of the same length as `a', or a non-vector which is matched
with all elements of `a'.

The `a {' (`calc-in-set') [`in(a,b)'] function is true if
the number `a' is in the set of numbers represented by `b'.
If `b' is an interval form, `a' must be one of the values
encompassed by the interval.  If `b' is a vector, `a' must be
equal to one of the elements of the vector.  (If any vector elements are
intervals, `a' must be in any of the intervals.)  If `b' is a
plain number, `a' must be numerically equal to `b'.
*Note Set Operations::, for a group of commands that manipulate sets
of this sort.

The `typeof(a)' function produces an integer or variable which
characterizes `a'.  If `a' is a number, vector, or variable,
the result will be one of the following numbers:

      1   Integer
      2   Fraction
      3   Floating-point number
      4   HMS form
      5   Rectangular complex number
      6   Polar complex number
      7   Error form
      8   Interval form
      9   Modulo form
     10   Date-only form
     11   Date/time form
     12   Infinity (inf, uinf, or nan)
     100  Variable
     101  Vector (but not a matrix)
     102  Matrix

Otherwise, `a' is a formula, and the result is a variable which
represents the name of the top-level function call.

The `integer(a)' function returns true if `a' is an integer.  The
`real(a)' function is true if `a' is a real number, either integer,
fraction, or float.  The `constant(a)' function returns true if `a' is
any of the objects for which `typeof' would produce an integer code
result except for variables, and provided that the components of an
object like a vector or error form are themselves constant.  Note that
infinities do not satisfy any of these tests.

*Note Declarations::, for a set of similar functions that recognize
formulas as well as actual numbers.  For example, `dint(floor(x))'
is true because `floor(x)' is provably integer-valued, but
`integer(floor(x))' does not because `floor(x)' is not
literally an integer constant.

The `refers(a,b)' function is true if the variable (or sub-expression)
`b' appears in `a', or false otherwise.  Unlike the other
tests described here, this function returns a definite "no" answer
even if its arguments are still in symbolic form.  The only case where
`refers' will be left unevaluated is if `a' is a plain
variable (different from `b').

The `negative(a)' function returns true if `a' "looks" negative,
because it is a negative number, because it is of the form `-x',
or because it is a product or quotient with a term that looks negative.
This is most useful in rewrite rules.  Beware that `negative(a)'
evaluates to 1 or 0 for *any* argument `a', so it can only
be stored in a formula if the default simplifications are turned off
first with `m O'.

The `variable(a)' function is true if `a' is a variable,
or false if not.  If `a' is a function call, this test is left
in symbolic form.  Built-in variables like `pi' and `inf'
are considered variables like any others by this test.

The `nonvar(a)' function is true if `a' is a non-variable.
If its argument is a variable it is left unsimplified; it never
actually returns zero.  However, since Calc's condition-testing
commands consider "false" anything not provably true, this is
often good enough.

The functions `lin', `linnt', `islin', and `islinnt'
check if an expression is "linear," i.e., can be written in the form
`a + b x' for some constants `a' and `b', and some
variable or subformula `x'.  The function `islin(f,x)' checks
if formula `f' is linear in `x', returning 1 if so.  For
example, `islin(x,x)', `islin(-x,x)', `islin(3,x)', and
`islin(x y / 3 - 2, x)' all return 1.  The `lin(f,x)' function
is similar, except that instead of returning 1 it returns the vector
`[a, b, x]'.  For the above examples, this vector would be
`[0, 1, x]', `[0, -1, x]', `[3, 0, x]', and
`[-2, y/3, x]', respectively.  Both `lin' and `islin'
generally remain unevaluated for expressions which are not linear,
e.g., `lin(2 x^2, x)' and `lin(sin(x), x)'.  The second
argument can also be a formula; `islin(2 + 3 sin(x), sin(x))'
returns true.

The `linnt' and `islinnt' functions perform a similar check,
but require a "non-trivial" linear form, which means that the
`b' coefficient must be non-zero.  For example, `lin(2,x)'
returns `[2, 0, x]' and `lin(y,x)' returns `[y, 0, x]',
but `linnt(2,x)' and `linnt(y,x)' are left unevaluated
(in other words, these formulas are considered to be only "trivially"
linear in `x').

All four linearity-testing functions allow you to omit the second
argument, in which case the input may be linear in any non-constant
formula.  Here, the `a=0', `b=1' case is also considered
trivial, and only constant values for `a' and `b' are
recognized.  Thus, `lin(2 x y)' returns `[0, 2, x y]',
`lin(2 - x y)' returns `[2, -1, x y]', and `lin(x y)'
returns`[0, 1, x y]'.  The `linnt' function would allow the
first two cases but not the third.  Also, neither `lin' nor
`linnt' accept plain constants as linear in the one-argument
case: `islin(2,x)' is true, but `islin(2)' is false.

The `istrue(a)' function returns 1 if `a' is a nonzero
number, or 0 if `a' is anything else.  Calls to `istrue'
can only be entered or manipulated if `m O' mode is used to
make sure they are not evaluated prematurely.


File: calc.info  Node: Rewrite Rules, Prev: Logical Operations, Up: Algebra

Rewrite Rules
=============

The `a r' (`calc-rewrite') [`rewrite'] command makes
substitutions in a formula according to a specified pattern or patterns
known as "rewrite rules".  Whereas `a b' (`calc-substitute')
matches literally, so that substituting `sin(x)' with `cos(x)'
matches only the `sin' function applied to the variable `x',
rewrite rules match general kinds of formulas; rewriting using the rule
`sin(x) := cos(x)' matches `sin' of any argument and replaces
it with `cos' of that same argument.  The only significance of the
name `x' is that the same name is used on both sides of the rule.

* Menu:

* Entering Rewrite Rules::
* Basic Rewrite Rules::
* Conditional Rewrite Rules::
* Algebraic Properties of Rewrite Rules::
* Other Features of Rewrite Rules::
* Composing Patterns in Rewrite Rules::
* Nested Formulas with Rewrite Rules::
* Multi-Phase Rewrite Rules::
* Selections with Rewrite Rules::
* Matching Commands::
* Automatic Rewrites::
* Debugging Rewrites::
* Examples of Rewrite Rules::


File: calc.info  Node: Entering Rewrite Rules, Prev: Rewrite Rules, Up: Rewrite Rules, Next: Basic Rewrite Rules

Entering Rewrite Rules
----------------------

Rewrite rules normally use the "assignment" operator `old := new'.
This operator is equivalent to the function call `assign(old, new)'.
The `assign' function is undefined by itself in Calc, so an
assignment formula like a rewrite rule will be left alone by ordinary
Calc commands.  But certain commands, like the rewrite system, interpret
assignments in special ways.

For example, the rule `sin(x)^2 := 1-cos(x)^2' says to replace
every occurrence of the sine of something, squared, with one minus the
square of the cosine of that same thing.  All by itself it does nothing,
but when given to the `a r' command it turns that command into
a sine-squared-to-cosine-squared converter.

To specify a set of rules, make a vector of rules.

When `a r' prompts you to enter the rewrite rules, you can answer
in several ways:

  1. With a rule:  `f(x) := g(x) RET'.
  2. With a vector of rules:  `[f1(x) := g1(x), f2(x) := g2(x)] RET'.
     (You can omit the enclosing square brackets if you wish.)
  3. With the name of a variable that contains the rule or rules vector:
     `myrules RET'.
  4. With any formula except a rule, a vector, or a variable name; this
     will be interpreted as the `old' half of a rewrite rule,
     and you will be prompted a second time for the `new' half:
     `f(x) RET g(x) RET'.
  5. With a blank line, in which case the rule, rules vector, or variable
     will be taken from the top of the stack (and the formula to be
     rewritten will come from the second-to-top position).

If you enter the rules directly (as opposed to using rules stored
in a variable), those rules will be put into the Trail so that you
can retrieve them later.  *Note Trail Commands::.

It is most convenient to store rules you use often in a variable and
invoke them by naming the variable.  The `s e' (`calc-edit-variable')
command is an easy way to create or edit a rule set stored in a
variable.  You may also wish to use `s p' (`calc-permanent-variable') to
save your rules permanently; *Note Operations on Variables::.

Rewrite rules are compiled into a special internal form for faster
matching.  If you enter a rule set directly it must be recompiled
for every `a r' command.  If you store the rules in a variable
and refer to them through that variable, they will be compiled
once and saved away along with the variable for later reference.
This is another good reason to store your rules in a variable.

Calc also accepts an obsolete notation for rules, as vectors
`[old, new]'.  But because it is easily confused with a vector
of two rules, the use of this notation is no longer recommended.


File: calc.info  Node: Basic Rewrite Rules, Prev: Entering Rewrite Rules, Up: Rewrite Rules, Next: Conditional Rewrite Rules

Basic Rewrite Rules
-------------------

To match a particular formula `x' with a particular rewrite rule
`old := new', Calc compares the structure of `x' with the
structure of `old'.  Variables that appear in `old' are
treated as "meta-variables"; the corresponding positions in `x'
may contain any sub-formulas.  For example, the pattern `f(x,y)'
would match the expression `f(12, a+1)' with the meta-variable
`x' corresponding to 12 and with `y' corresponding to
`a+1'.  However, this pattern would not match `f(12)' or
`g(12, a+1)', since there is no assignment of the meta-variables
that will make the pattern match these expressions.  Notice that if
the pattern is a single meta-variable, it will match any expression.

If a given meta-variable appears more than once in `old', the
corresponding sub-formulas of `x' must be identical.  Thus
the pattern `f(x,x)' would match `f(12, 12)' and
`f(a+1, a+1)' but not `f(12, a+1)' or `f(x+y, y+x)'.

Things other than variables must match exactly between the pattern
and the target formula.  To match a particular variable exactly, use
the pseudo-function `quote(v)' in the pattern.  For example, the
pattern `x+quote(y)' matches `x+y', `2+y', or
`sin(a)+y'.

The special variable names `e', `pi', `i', `phi',
`gamma', `inf', `uinf', and `nan' always match
literally.  Thus the pattern `sin(d + e + f)' acts exactly like
`sin(d + quote(e) + f)'.

If the `old' pattern is found to match a given formula, that
formula is replaced by `new', where any occurrences in `new'
of meta-variables from the pattern are replaced with the sub-formulas
that they matched.  Thus, applying the rule `f(x,y) := g(y+x,x)'
to `f(12, a+1)' would produce `g(a+13, 12)'.

The normal `a r' command applies rewrite rules over and over
throughout the target formula until no further changes are possible.
Use `C-u 1 a r' to make only one change at a time.


File: calc.info  Node: Conditional Rewrite Rules, Prev: Basic Rewrite Rules, Up: Rewrite Rules, Next: Algebraic Properties of Rewrite Rules

Conditional Rewrite Rules
-------------------------

A rewrite rule can also be "conditional", written in the form
`old := new :: cond'.  (There is also the obsolete form
`[old, new, cond]'.)  If a `cond' part is present in the
rule, this is an additional condition that must be satisfied before
the rule is accepted.  Once `old' has been successfully matched
to the target expression, `cond' is evaluated (with all the
meta-variables substituted for the values they matched) and simplified
with `a s' (`calc-simplify').  If the result is a nonzero
number or any other object known to be nonzero (*Note Declarations::),
the rule is accepted.  If the result is zero or if it is a symbolic
formula that is not known to be nonzero, the rule is rejected.
*Note Logical Operations::, for a number of functions that return
1 or 0 according to the results of various tests.

For example, the formula `n > 0' simplifies to 1 or 0 if `n'
is replaced by a positive or nonpositive number, respectively (or if
`n' has been declared to be positive or nonpositive).  Thus,
the rule `f(x,y) := g(y+x,x) :: x+y > 0' would apply to
`f(0, 4)' but not to `f(-3, 2)' or `f(12, a+1)'
(assuming no outstanding declarations for `a').  In the case of
`f(-3, 2)', the condition can be shown not to be satisfied; in
the case of `f(12, a+1)', the condition merely cannot be shown
to be satisfied, but that is enough to reject the rule.

While Calc will use declarations to reason about variables in the
formula being rewritten, declarations do not apply to meta-variables.
For example, the rule `[f(a), g(a+1)]' will match for any values
of `a', such as complex numbers, vectors, or formulas, even if
`a' has been declared to be real or scalar.  If you want the
meta-variable `a' to match only literal real numbers, use
`f(a) := g(a+1) :: real(a)'.  If you want `a' to match only
reals and formulas which are provably real, use `dreal(a)' as
the condition.

The `::' operator is a shorthand for the `condition'
function; `old := new :: cond' is equivalent to the formula
`condition(assign(old, new), cond)'.

If you have several conditions, you can use `... :: c1 :: c2 :: c3'
or `... :: c1 && c2 && c3'.  The two are entirely equivalent.

It is also possible to embed conditions inside the pattern:
`f(x :: x>0, y) := g(y+x, x)'.  This is purely a notational
convenience, though; where a condition appears in a rule has no
effect on when it is tested.  The rewrite-rule compiler automatically
decides when it is best to test each condition while a rule is being
matched.

Certain conditions are handled as special cases by the rewrite rule
system and are tested very efficiently:  Where `x' is any
meta-variable, these conditions are `integer(x)', `real(x)',
`constant(x)', `negative(x)', `x >= y' where `y'
is either a constant or another meta-variable and `>=' may be
replaced by any of the six relational operators, and `x % a = b'
where `a' and `b' are constants.  Other conditions, like
`x >= y+1' or `dreal(x)', will be less efficient to check
since Calc must bring the whole evaluator and simplifier into play.

An interesting property of `::' is that neither of its arguments
will be touched by Calc's default simplifications.  This is important
because conditions often are expressions that cannot safely be
evaluated early.  For example, the `typeof' function never
remains in symbolic form; entering `typeof(a)' will put the
number 100 (the type code for variables like `a') on the stack.
But putting the condition `... :: typeof(a) = 6' on the stack
is safe since `::' prevents the `typeof' from being
evaluated until the condition is actually used by the rewrite system.

Since `::' protects its lefthand side, too, you can use a dummy
condition to protect a rule that itself must not evaluate early.
For example, it's not safe to put `a(f,x) := apply(f, [x])' on
the stack because it will immediately evaluate to `a(f,x) := f(x)',
where the meta-variable-ness of `f' on the righthand side has been
lost.  But `a(f,x) := apply(f, [x]) :: 1' is safe, and of course
the condition `1' is always true (nonzero) so it has no effect on
the functioning of the rule.  (The rewrite compiler will ensure that
it doesn't even impact the speed of matching the rule.)


File: calc.info  Node: Algebraic Properties of Rewrite Rules, Prev: Conditional Rewrite Rules, Up: Rewrite Rules, Next: Other Features of Rewrite Rules

Algebraic Properties of Rewrite Rules
-------------------------------------

The rewrite mechanism understands the algebraic properties of functions
like `+' and `*'.  In particular, pattern matching takes
the associativity and commutativity of the following functions into
account:

     + - *  = !=  && ||  and or xor  vint vunion vxor  gcd lcm  max min  beta

For example, the rewrite rule:

     a x + b x  :=  (a + b) x

will match formulas of the form,

     a x + b x,  x a + x b,  a x + x b,  x a + b x

Rewrites also understand the relationship between the `+' and `-'
operators.  The above rewrite rule will also match the formulas,

     a x - b x,  x a - x b,  a x - x b,  x a - b x

by matching `b' in the pattern to `-b' from the formula.

Applied to a sum of many terms like `r + a x + s + b x + t', this
pattern will check all pairs of terms for possible matches.  The rewrite
will take whichever suitable pair it discovers first.

In general, a pattern using an associative operator like `a + b'
will try 2 n different ways to match a sum of n terms
like `x + y + z - w'.  First, `a' is matched against each
of `x', `y', `z', and `-w' in turn, with `b'
being matched to the remainders `y + z - w', `x + z - w', etc.
If none of these succeed, then `b' is matched against each of the
four terms with `a' matching the remainder.  Half-and-half matches,
like `(x + y) + (z - w)', are not tried.

Note that `*' is not commutative when applied to matrices, but
rewrite rules pretend that it is.  If you type `m v' to enable
matrix mode (*Note Matrix Mode::), rewrite rules will match `*'
literally, ignoring its usual commutativity property.  (In the
current implementation, the associativity also vanishes---it is as
if the pattern had been enclosed in a `plain' marker; see below.)
If you are applying rewrites to formulas with matrices, it's best to
enable matrix mode first to prevent algebraically incorrect rewrites
from occurring.

The pattern `-x' will actually match any expression.  For example,
the rule

     f(-x)  :=  -f(x)

will rewrite `f(a)' to `-f(-a)'.  To avoid this, either use
a `plain' marker as described below, or add a `negative(x)'
condition.  The `negative' function is true if its argument
"looks" negative, for example, because it is a negative number or
because it is a formula like `-x'.  The new rule using this
condition is:

     f(x)  :=  -f(-x)  :: negative(x)    or, equivalently,
     f(-x)  :=  -f(x)  :: negative(-x)

In the same way, the pattern `x - y' will match the sum `a + b'
by matching `y' to `-b'.

The pattern `a b' will also match the formula `x/y' if
`y' is a number.  Thus the rule `a x + b x := (a+b) x'
will also convert `a x + x / 2' to `(a + 0.5) x' (or
`(a + 1:2) x', depending on the current fraction mode).

Calc will *not* take other liberties with `*', `/', and
`^'.  For example, the pattern `f(a b)' will not match
`f(x^2)', and `f(a + b)' will not match `f(2 x)', even
though conceivably these patterns could match with `a = b = x'.
Nor will `f(a b)' match `f(x / y)' if `y' is not a
constant, even though it could be considered to match with `a = x'
and `b = 1/y'.  The reasons are partly for efficiency, and partly
because while few mathematical operations are substantively different
for addition and subtraction, often it is preferable to treat the cases
of multiplication, division, and integer powers separately.

Even more subtle is the rule set

     [ f(a) + f(b) := f(a + b),  -f(a) := f(-a) ]

attempting to match `f(x) - f(y)'.  You might think that Calc
will view this subtraction as `f(x) + (-f(y))' and then apply
the above two rules in turn, but actually this will not work because
Calc only does this when considering rules for `+' (like the
first rule in this set).  So it will see first that `f(x) + (-f(y))'
does not match `f(a) + f(b)' for any assignments of the
meta-variables, and then it will see that `f(x) - f(y)' does
not match `-f(a)' for any assignment of `a'.  Because Calc
tries only one rule at a time, it will not be able to rewrite
`f(x) - f(y)' with this rule set.  An explicit `f(a) - f(b)'
rule will have to be added.

Another thing patterns will *not* do is break up complex numbers.
The pattern `myconj(a + b i) := a - b i' will work for formulas
involving the special constant `i' (such as `3 - 4 i'), but
it will not match actual complex numbers like `(3, -4)'.  A version
of the above rule for complex numbers would be

     myconj(a)  :=  re(a) - im(a) (0,1)  :: im(a) != 0

(Because the `re' and `im' functions understand the properties
of the special constant `i', this rule will also work for
`3 - 4 i'.  In fact, this particular rule would probably be better
without the `im(a) != 0' condition, since if `im(a) = 0' the
righthand side of the rule will still give the correct answer for the
conjugate of a real number.)

It is also possible to specify optional arguments in patterns.  The rule

     opt(a) x + opt(b) (x^opt(c) + opt(d))  :=  f(a, b, c, d)

will match the formula

     5 (x^2 - 4) + 3 x

in a fairly straightforward manner, but it will also match reduced
formulas like

     x + x^2,    2(x + 1) - x,    x + x

producing, respectively,

     f(1, 1, 2, 0),   f(-1, 2, 1, 1),   f(1, 1, 1, 0)

(The latter two formulas can be entered only if default simplifications
have been turned off with `m O'.)

The default value for a term of a sum is zero.  The default value
for a part of a product, for a power, or for the denominator of a
quotient, is one.  Also, `-x' matches the pattern `opt(a) b'
with `a = -1'.

In particular, the distributive-law rule can be refined to

     opt(a) x + opt(b) x  :=  (a + b) x

so that it will convert, e.g., `a x - x', to `(a - 1) x'.

The pattern `opt(a) + opt(b) x' matches any formula which is
linear in `x'.  You can also use the `lin' and `islin'
functions with rewrite conditions to test for this; *Note Logical Operations::.  These functions are not as convenient to use in rewrite
rules, but they recognize more kinds of formulas as linear:
`x/z' is considered linear with `b = 1/z' by `lin',
but it will not match the above pattern because that pattern calls
for a multiplication, not a division.

As another example, the obvious rule to replace `sin(x)^2 + cos(x)^2'
by 1,

     sin(x)^2 + cos(x)^2  :=  1

misses many cases because the sine and cosine may both be multiplied by
an equal factor.  Here's a more successful rule:

     opt(a) sin(x)^2 + opt(a) cos(x)^2  :=  a

Note that this rule will *not* match `sin(x)^2 + 6 cos(x)^2'
because one `a' would have "matched" 1 while the other matched 6.

Calc automatically converts a rule like

     f(x-1, x)  :=  g(x)

into the form

     f(temp, x)  :=  g(x)  :: temp = x-1

(where `temp' stands for a new, invented meta-variable that
doesn't actually have a name).  This modified rule will successfully
match `f(6, 7)', binding `temp' and `x' to 6 and 7,
respectively, then verifying that they differ by one even though
`6' does not superficially look like `x-1'.

However, Calc does not solve equations to interpret a rule.  The
following rule,

     f(x-1, x+1)  :=  g(x)

will not work.  That is, it will match `f(a - 1 + b, a + 1 + b)'
but not `f(6, 8)'.  Calc always interprets at least one occurrence
of a variable by literal matching.  If the variable appears "isolated"
then Calc is smart enough to use it for literal matching.  But in this
last example, Calc is forced to rewrite the rule to `f(x-1, temp)
:= g(x) :: temp = x+1' where the `x-1' term must correspond to an
actual "something-minus-one" in the target formula.

A successful way to write this would be `f(x, x+2) := g(x+1)'.
You could make this resemble the original form more closely by using
`let' notation, which is described in the next section:

     f(xm1, x+1)  :=  g(x)  :: let(x := xm1+1)

Calc does this rewriting or "conditionalizing" for any sub-pattern
which involves only the functions in the following list, operating
only on constants and meta-variables which have already been matched
elsewhere in the pattern.  When matching a function call, Calc is
careful to match arguments which are plain variables before arguments
which are calls to any of the functions below, so that a pattern like
`f(x-1, x)' can be conditionalized even though the isolated
`x' comes after the `x-1'.

     + - * / \ % ^  abs sign  round rounde roundu trunc floor ceil
     max min  re im conj arg

You can suppress all of the special treatments described in this
section by surrounding a function call with a `plain' marker.
This marker causes the function call which is its argument to be
matched literally, without regard to commutativity, associativity,
negation, or conditionalization.  When you use `plain', the
"deep structure" of the formula being matched can show through.
For example,

     plain(a - a b)  :=  f(a, b)

will match only literal subtractions.  However, the `plain'
marker does not affect its arguments' arguments.  In this case,
commutativity and associativity is still considered while matching
the `a b' sub-pattern, so the whole pattern will match
`x - y x' as well as `x - x y'.  We could go still
further and use

     plain(a - plain(a b))  :=  f(a, b)

which would do a completely strict match for the pattern.

By contrast, the `quote' marker means that not only the
function name but also the arguments must be literally the same.
The above pattern will match `x - x y' but

     quote(a - a b)  :=  f(a, b)

will match only the single formula `a - a b'.  Also,

     quote(a - quote(a b))  :=  f(a, b)

will match only `a - quote(a b)'---probably not the desired
effect!

A certain amount of algebra is also done when substituting the
meta-variables on the righthand side of a rule.  For example,
in the rule

     a + f(b)  :=  f(a + b)

matching `f(x) - y' would produce `f((-y) + x)' if
taken literally, but the rewrite mechanism will simplify the
righthand side to `f(x - y)' automatically.  (Of course,
the default simplifications would do this anyway, so this
special simplification is only noticeable if you have turned the
default simplifications off.)  This rewriting is done only when
a meta-variable expands to a "negative-looking" expression.
If this simplification is not desirable, you can use a `plain'
marker on the righthand side:

     a + f(b)  :=  f(plain(a + b))

In this example, we are still allowing the pattern-matcher to
use all the algebra it can muster, but the righthand side will
always simplify to a literal addition like `f((-y) + x)'.


File: calc.info  Node: Other Features of Rewrite Rules, Prev: Algebraic Properties of Rewrite Rules, Up: Rewrite Rules, Next: Composing Patterns in Rewrite Rules

Other Features of Rewrite Rules
-------------------------------

Certain "function names" serve as markers in rewrite rules.
Here is a complete list of these markers.  First are listed the
markers that work inside a pattern; then come the markers that
work in the righthand side of a rule.

One kind of marker, `import(x)', takes the place of a whole
rule.  Here `x' is the name of a variable containing another
rule set; those rules are "spliced into" the rule set that
imports them.  For example, if `[f(a+b) := f(a) + f(b),
f(a b) := a f(b) :: real(a)]' is stored in variable `linearF',
then the rule set `[f(0) := 0, import(linearF)]' will apply
all three rules.  It is possible to modify the imported rules
slightly:  `import(x, v1, x1, v2, x2, ...)' imports
the rule set `x' with all occurrences of `v1', as either
a variable name or a function name, replaced with `x1' and
so on.  (If `v1' is used as a function name, then `x1'
must be either a function name itself or a `< >' nameless
function *Note Specifying Operators::.)  For example, `[g(0) := 0,
import(linearF, f, g)]' applies the linearity rules to the function
`g' instead of `f'.  Imports can be nested, but the
import-with-renaming feature may not properly rename sub-imports.

The special functions allowed in patterns are:

`quote(x)'
     This pattern matches exactly `x'; variable names in `x' are
     not interpreted as meta-variables.  The only flexibility is that
     numbers are compared for numeric equality, so that the pattern
     `f(quote(12))' will match both `f(12)' and `f(12.0)'.
     (Numbers are always treated this way by the rewrite mechanism:
     The rule `f(x,x) := g(x)' will match `f(12, 12.0)'.
     The rewrite may produce either `g(12)' or `g(12.0)'
     as a result in this case.)

`plain(x)'
     Here `x' must be a function call `f(x1,x2,...)'.  This
     pattern matches a call to function `f' with the specified
     argument patterns.  No special knowledge of the properties of the
     function `f' is used in this case; `+' is not commutative or
     associative.  Unlike `quote', the arguments `x1,x2,...'
     are treated as patterns.  If you wish them to be treated "plainly"
     as well, you must enclose them with more `plain' markers:
     `plain(plain(-a) + plain(b c))'.

`opt(x,def)'
     Here `x' must be a variable name.  This must appear as an argument
     to a function or an element of a vector; it specifies that the
     argument or element is optional.  As an argument to `+', `-', `*',
     `&&', or `||', or as the second argument to `/' or `^', the value
     DEF may be omitted.  The pattern `x + opt(y)' matches a sum by
     binding one summand to `x' and the other to `y', and it matches
     anything else by binding the whole expression to `x' and zero to
     `y'.  The other operators above work similarly.

     For general miscellanous functions, the default value `def'
     must be specified.  Optional arguments are dropped starting with
     the rightmost one during matching.  For example, the pattern
     `f(opt(a,0), b, opt(c,b))' will match `f(b)', `f(a,b)',
     or `f(a,b,c)'.  Default values of zero and `b' are
     supplied in this example for the omitted arguments.  Note that
     the literal variable `b' will be the default in the latter
     case, *not* the value that matched the meta-variable `b'.
     In other words, the default DEF is effectively quoted.

`condition(x,c)'
     This matches the pattern `x', with the attached condition
     `c'.  It is the same as `x :: c'.

`pand(x,y)'
     This matches anything that matches both pattern `x' and
     pattern `y'.  It is the same as `x &&& y'.
     *Note Composing Patterns in Rewrite Rules::.

`por(x,y)'
     This matches anything that matches either pattern `x' or
     pattern `y'.  It is the same as `x ||| y'.

`pnot(x)'
     This matches anything that does not match pattern `x'.
     It is the same as `!!! x'.

`cons(h,t)'
     This matches any vector of one or more elements.  The first
     element is matched to `h'; a vector of the remaining
     elements is matched to `t'.  Note that vectors of fixed
     length can also be matched as actual vectors:  The rule
     `cons(a,cons(b,[])) := cons(a+b,[])' is equivalent
     to the rule `[a,b] := [a+b]'.

`rcons(t,h)'
     This is like `cons', except that the *last* element
     is matched to `h', with the remaining elements matched
     to `t'.

`apply(f,args)'
     This matches any function call.  The name of the function, in
     the form of a variable, is matched to `f'.  The arguments
     of the function, as a vector of zero or more objects, are
     matched to `args'.  Constants, variables, and vectors
     do *not* match an `apply' pattern.  For example,
     `apply(f,x)' matches any function call, `apply(quote(f),x)'
     matches any call to the function `f', `apply(f,[a,b])'
     matches any function call with exactly two arguments, and
     `apply(quote(f), cons(a,cons(b,x)))' matches any call
     to the function `f' with two or more arguments.  Another
     way to implement the latter, if the rest of the rule does not
     need to refer to the first two arguments of `f' by name,
     would be `apply(quote(f), x :: vlen(x) >= 2)'.
     Here's a more interesting sample use of `apply':

          apply(f,[x+n])  :=  n + apply(f,[x])
             :: in(f, [floor,ceil]) :: integer(n)

     Note, however, that this will be slower to match than a rule
     set with two separate rules.  The reason is that Calc sorts
     the rules of a rule set according to top-level function name;
     if the top-level function is `apply', Calc must try the
     rule for every single formula and sub-formula.  If the top-level
     function in the pattern is, say, `floor', then Calc invokes
     the rule only for sub-formulas which are calls to `floor'.

     You must use `apply' for meta-variables with function names
     on both sides of a rewrite rule:  `apply(f, [x]) := f(x+1)'
     is *not* correct, because it rewrites `spam(6)' into
     `f(7)'.  The righthand side should be `apply(f, [x+1])'.
     Also note that you will have to use no-simplify (`m O')
     mode when entering this rule so that the `apply' isn't
     evaluated immediately to get the new rule `f(x) := f(x+1)'.
     Or, use `s e' to enter the rule without going through the stack,
     or enter the rule as `apply(f, [x]) := apply(f, [x+1]) :: 1'.
     *Note Conditional Rewrite Rules::.

`select(x)'
     This is used for applying rules to formulas with selections;
     *Note Selections with Rewrite Rules::.

Special functions for the righthand sides of rules are:

`quote(x)'
     The notation `quote(x)' is changed to `x' when the
     righthand side is used.  As far as the rewrite rule is concerned,
     `quote' is invisible.  However, `quote' has the special
     property in Calc that its argument is not evaluated.  Thus,
     while it will not work to put the rule `t(a) := typeof(a)'
     on the stack because `typeof(a)' is evaluated immediately
     to produce `t(a) := 100', you can use `quote' to
     protect the righthand side:  `t(a) := quote(typeof(a))'.
     (*Note Conditional Rewrite Rules::, for another trick for
     protecting rules from evaluation.)

`plain(x)'
     Special properties of and simplifications for the function call
     `x' are not used.  One interesting case where `plain'
     is useful is the rule, `q(x) := quote(x)', trying to expand a
     shorthand notation for the `quote' function.  This rule will
     not work as shown; instead of replacing `q(foo)' with
     `quote(foo)', it will replace it with `foo'!  The correct
     rule would be `q(x) := plain(quote(x))'.

`cons(h,t)'
     Where `t' is a vector, this is converted into an expanded
     vector during rewrite processing.  Note that `cons' is a regular
     Calc function which normally does this anyway; the only way `cons'
     is treated specially by rewrites is that `cons' on the righthand
     side of a rule will be evaluated even if default simplifications
     have been turned off.

`rcons(t,h)'
     Analogous to `cons' except putting `h' at the *end* of
     the vector `t'.

`apply(f,args)'
     Where `f' is a variable and `args' is a vector, this
     is converted to a function call.  Once again, note that `apply'
     is also a regular Calc function.

`eval(x)'
     The formula `x' is handled in the usual way, then the
     default simplifications are applied to it even if they have
     been turned off normally.  This allows you to treat any function
     similarly to the way `cons' and `apply' are always
     treated.  However, there is a slight difference:  `cons(2+3, [])'
     with default simplifications off will be converted to `[2+3]',
     whereas `eval(cons(2+3, []))' will be converted to `[5]'.

`evalsimp(x)'
     The formula `x' has meta-variables substituted in the usual
     way, then algebraically simplified as if by the `a s' command.

`evalextsimp(x)'
     The formula `x' has meta-variables substituted in the normal
     way, then "extendedly" simplified as if by the `a e' command.

`select(x)'
     *Note Selections with Rewrite Rules::.

There are also some special functions you can use in conditions.

`let(v := x)'
     The expression `x' is evaluated with meta-variables substituted.
     The `a s' command's simplifications are *not* applied by default,
     but `x' can include calls to `evalsimp' or `evalextsimp' as
     described above to invoke higher levels of simplification.  The
     result of `x' is then bound to the meta-variable `v'.  As usual, if
     this meta-variable has already been matched to something else the
     two values must be equal; if the meta-variable is new then it is
     bound to the result of the expression.  This variable can then
     appear in later conditions, and on the righthand side of the rule.
     In fact, `v' may be any pattern in which case the result of
     evaluating `x' is matched to that pattern, binding any
     meta-variables that appear in that pattern.  Note that `let' can
     only appear by itself as a condition, or as one term of an `&&'
     which is a whole condition: It cannot be inside an `||' term or
     otherwise buried.

     The alternate, equivalent form `let(v, x)' is also recognized.
     Note that the use of `:=' by `let', while still being
     assignment-like in character, is unrelated to the use of `:='
     in the main part of a rewrite rule.

     As an example, `f(a) := g(ia) :: let(ia := 1/a) :: constant(ia)'
     replaces `f(a)' with `g' of the inverse of `a', if that inverse
     exists and is constant.  For example, if `a' is a singular matrix
     the operation `1/a' is left unsimplified and `constant(ia)' fails,
     but if `a' is an invertible matrix then the rule succeeds.  Without
     `let' there would be no way to implement this rule that didn't have
     to invert the matrix twice.  Note that, because the meta-variable
     `ia' is otherwise unbound in this rule, the `let' condition itself
     always "succeeds" because no matter what `1/a' evaluates to, it can
     successfully be bound to `ia'.

     As another example, here is a rule for integrating cosines of
     linear terms: `myint(cos(y),x) := sin(y)/b :: let([a,b,x] :=
     lin(y,x))'.  The `lin' function returns a 3-vector if its argument
     is linear, or leaves itself unevaluated if not.  But an unevaluated
     `lin' call will not match the 3-vector on the lefthand side of the
     `let', so this `let' both verifies that `y' is linear, and binds
     the coefficients `a' and `b' for use elsewhere in the rule.  (It
     would have been possible to use `sin(a x + b)/b' for the righthand
     side instead, but using `sin(y)/b' avoids gratuitous rearrangement
     of the argument of the sine.)

     Similarly, here is a rule that implements an inverse-`erf'
     function.  It uses `root' to search for a solution.  If
     `root' succeeds, it will return a vector of two numbers
     where the first number is the desired solution.  If no solution
     is found, `root' remains in symbolic form.  So we use
     `let' to check that the result was indeed a vector.

          ierf(x)  :=  y  :: let([y,z] := root(erf(a) = x, a, .5))

`matches(v,p)'
     The meta-variable V, which must already have been matched
     to something elsewhere in the rule, is compared against pattern
     P.  Since `matches' is a standard Calc function, it
     can appear anywhere in a condition.  But if it appears alone or
     as a term of a top-level `&&', then you get the special
     extra feature that meta-variables which are bound to things
     inside P can be used elsewhere in the surrounding rewrite
     rule.

     The only real difference between `let(p := v)' and
     `matches(v, p)' is that the former evaluates `v' using
     the default simplifications, while the latter does not.

`remember'
     This is actually a variable, not a function.  If `remember'
     appears as a condition in a rule, then when that rule succeeds
     the original expression and rewritten expression are added to the
     front of the rule set that contained the rule.  If the rule set
     was not stored in a variable, `remember' is ignored.  The
     lefthand side is enclosed in `quote' in the added rule if it
     contains any variables.

     For example, the rule `f(n) := n f(n-1) :: remember' applied
     to `f(7)' will add the rule `f(7) := 7 f(6)' to the front
     of the rule set.  The rule set `EvalRules' works slightly
     differently:  There, the evaluation of `f(6)' will complete before
     the result is added to the rule set, in this case as `f(7) := 5040'.
     Thus `remember' is most useful inside `EvalRules'.

     It is up to you to ensure that the optimization performed by
     `remember' is safe.  For example, the rule `foo(n) := n
     :: evalv(eatfoo) > 0 :: remember' is a bad idea (`evalv' is
     the function equivalent of the `=' command); if the variable
     `eatfoo' ever contains 1, rules like `foo(7) := 7' will
     be added to the rule set and will continue to operate even if
     `eatfoo' is later changed to 0.

`remember(c)'
     Remember the match as described above, but only if condition `c'
     is true.  For example, `remember(n % 4 = 0)' in the above factorial
     rule remembers only every fourth result.  Note that `remember(1)'
     is equivalent to `remember', and `remember(0)' has no effect.


File: calc.info  Node: Composing Patterns in Rewrite Rules, Prev: Other Features of Rewrite Rules, Up: Rewrite Rules, Next: Nested Formulas with Rewrite Rules

Composing Patterns in Rewrite Rules
-----------------------------------

There are three operators, `&&&', `|||', and `!!!',
that combine rewrite patterns to make larger patterns.  The
combinations are "and," "or," and "not," respectively, and
these operators are the pattern equivalents of `&&', `||'
and `!' (which operate on zero-or-nonzero logical values).

Note that `&&&', `|||', and `!!!' are left in symbolic
form by all regular Calc features; they have special meaning only in
the context of rewrite rule patterns.

The pattern `P1 &&& P2' matches anything that
matches both P1 and P2.  One especially useful case is
when one of P1 or P2 is a meta-variable.  For example,
here is a rule that operates on error forms:

     f(x &&& a +/- b, x)  :=  g(x)

This does the same thing, but is arguably simpler than, the rule

     f(a +/- b, a +/- b)  :=  g(a +/- b)

Here's another interesting example:

     ends(cons(a, x) &&& rcons(y, b))  :=  [a, b]

which effectively clips out the middle of a vector leaving just
the first and last elements.  This rule will change a one-element
vector `[a]' to `[a, a]'.  The similar rule

     ends(cons(a, rcons(y, b)))  :=  [a, b]

would do the same thing except that it would fail to match a
one-element vector.


The pattern `P1 ||| P2' matches anything that
matches either P1 or P2.  Calc first tries matching
against P1; if that fails, it goes on to try P2.

A simple example of `|||' is

     curve(inf ||| -inf)  :=  0

which converts both `curve(inf)' and `curve(-inf)' to zero.

Here is a larger example:

     log(a, b) ||| (ln(a) :: let(b := e))  :=  mylog(a, b)

This matches both generalized and natural logarithms in a single rule.
Note that the `::' term must be enclosed in parentheses because
that operator has lower precedence than `|||' or `:='.

(In practice this rule would probably include a third alternative,
omitted here for brevity, to take care of `log10'.)

While Calc generally treats interior conditions exactly the same as
conditions on the outside of a rule, it does guarantee that if all the
variables in the condition are special names like `e', or already
bound in the pattern to which the condition is attached (say, if
`a' had appeared in this condition), then Calc will process this
condition right after matching the pattern to the left of the `::'.
Thus, we know that `b' will be bound to `e' only if the
`ln' branch of the `|||' was taken.

Note that this rule was careful to bind the same set of meta-variables
on both sides of the `|||'.  Calc does not check this, but if
you bind a certain meta-variable only in one branch and then use that
meta-variable elsewhere in the rule, results are unpredictable:

     f(a,b) ||| g(b)  :=  h(a,b)

Here if the pattern matches `g(17)', Calc makes no promises about
the value that will be substituted for `a' on the righthand side.


The pattern `!!! PAT' matches anything that does not
match PAT.  Any meta-variables that are bound while matching
PAT remain unbound outside of PAT.

For example,

     f(x &&& !!! a +/- b, !!![])  :=  g(x)

converts `f' whose first argument is anything *except* an
error form, and whose second argument is not the empty vector, into
a similar call to `g' (but without the vector).

If we know that the second argument will be a vector (empty or not),
then an equivalent rule would be:

     f(x, y)  :=  g(x)  :: typeof(x) != 7 :: vlen(y) > 0

where of course 7 is the `typeof' code for error forms.
Another final condition, that works for any kind of `y',
would be `!istrue(y == [])'.  (The `istrue' function
returns an explicit 0 if its argument was left in symbolic form;
plain `!(y == [])' or `y != []' would not work to replace
`!!![]' since these would be left unsimplified, and thus cause
the rule to fail, if `y' was something like a variable name.)

It is possible for a `!!!' to refer to meta-variables bound
elsewhere in the pattern.  For example,

     f(a, !!!a)  :=  g(a)

matches any call to `f' with different arguments, changing
this to `g' with only the first argument.

If a function call is to be matched and one of the argument patterns
contains a `|||' somewhere inside it, that argument will be
matched last.  Thus

     f(!!!a, a)  :=  g(a)

will be careful to bind `a' to the second argument of `f'
before testing the first argument.  If Calc had tried to match the
first argument of `f' first, the results would have been
disasterous:  Since `a' was unbound so far, the pattern `a'
would have matched anything at all, and the pattern `!!!a'
therefore would *not* have matched anything at all!


