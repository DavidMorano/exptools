Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: Vector Lisp Functions, Prev: Computational Lisp Functions, Up: Internals, Next: Symbolic Lisp Functions

Vector Functions
................

The functions described here perform various operations on vectors and
matrices.

* Function: math-concat X Y
     Do a vector concatenation; this operation is written `X | Y'
     in a symbolic formula.  *Note Building Vectors::.

* Function: vec-length V
     Return the length of vector V.  If V is not a vector, the
     result is zero.  If V is a matrix, this returns the number of
     rows in the matrix.

* Function: mat-dimens M
     Determine the dimensions of vector or matrix M.  If M is not a
     vector, the result is an empty list.  If M is a plain vector but
     not a matrix, the result is a one-element list containing the
     length of the vector.  If M is a matrix with R rows and C columns,
     the result is the list `(R C)'.  Higher-order tensors produce lists
     of more than two dimensions.  Note that the object `[[1, 2, 3], [4,
     5]]' is a vector of vectors not all the same size, and is treated
     by this and other Calc routines as a plain vector of two elements.

* Function: dimension-error
     Abort the current function with a message of "Dimension error."
     The Calculator will leave the function being evaluated in symbolic
     form; this is really just a special case of `reject-arg'.

* Function: build-vector ARGS
     Return a Calc vector with the zero-or-more ARGS as elements.
     For example, `(build-vector 1 2 3)' returns the Calc vector
     `[1, 2, 3]', stored internally as the list `(vec 1 2 3)'.

* Function: make-vec OBJ DIMS
     Return a Calc vector or matrix all of whose elements are equal to
     OBJ.  For example, `(make-vec 27 3 4)' returns a 3x4 matrix
     filled with 27's.

* Function: row-matrix V
     If V is a plain vector, convert it into a row matrix, i.e.,
     a matrix whose single row is V.  If V is already a matrix,
     leave it alone.

* Function: col-matrix V
     If V is a plain vector, convert it into a column matrix, i.e., a
     matrix with each element of V as a separate row.  If V is
     already a matrix, leave it alone.

* Function: map-vec F V
     Map the Lisp function F over the Calc vector V.  For example,
     `(map-vec 'math-floor v)' returns a vector of the floored components
     of vector V.

* Function: map-vec-2 F A B
     Map the Lisp function F over the two vectors A and B.  If A and B
     are vectors of equal length, the result is a vector of the results
     of calling `(F AI BI)' for each pair of elements AI and BI.  If
     either A or B is a scalar, it is matched with each value of the
     other vector.  For example, `(map-vec-2 'math-add v 1)' returns the
     vector V with each element increased by one.  Note that using `'+'
     would not work here, since `defmath' does not expand function names
     everywhere, just where they are in the function position of a Lisp
     expression.

* Function: reduce-vec F V
     Reduce the function F over the vector V.  For example, if
     V is `[10, 20, 30, 40]', this calls `(f (f (f 10 20) 30) 40)'.
     If V is a matrix, this reduces over the rows of V.

* Function: reduce-cols F M
     Reduce the function F over the columns of matrix M.  For
     example, if M is `[[1, 2], [3, 4], [5, 6]]', the result
     is a vector of the two elements `(f (f 1 3) 5)' and `(f (f 2 4) 6)'.

* Function: mat-row M N
     Return the Nth row of matrix M.  This is equivalent to
     `(elt m n)'.  For a slower but safer version, use `mrow'.
     (*Note Extracting Elements::.)

* Function: mat-col M N
     Return the Nth column of matrix M, in the form of a vector.
     The arguments are not checked for correctness.

* Function: mat-less-row M N
     Return a copy of matrix M with its Nth row deleted.  The
     number N must be in range from 1 to the number of rows in M.

* Function: mat-less-col M N
     Return a copy of matrix M with its Nth column deleted.

* Function: transpose M
     Return the transpose of matrix M.

* Function: flatten-vector V
     Flatten nested vector V into a vector of scalars.  For example,
     if V is `[[1, 2, 3], [4, 5]]' the result is `[1, 2, 3, 4, 5]'.

* Function: copy-matrix M
     If M is a matrix, return a copy of M.  This maps `copy-sequence'
     over the rows of M; in Lisp terms, each element of the result
     matrix will be `eq' to the corresponding element of M, but none of
     the `cons' cells that make up the structure of the matrix will be
     `eq'.  If M is a plain vector, this is the same as `copy-sequence'.

* Function: swap-rows M R1 R2
     Exchange rows R1 and R2 of matrix M in-place.  In other words,
     unlike most of the other functions described here, this function
     changes M itself rather than building up a new result matrix.  The
     return value is M, i.e., `(eq (swap-rows m 1 2) m)' is true, with
     the side effect of exchanging the first two rows of M.


File: calc.info  Node: Symbolic Lisp Functions, Prev: Vector Lisp Functions, Up: Internals, Next: Formatting Lisp Functions

Symbolic Functions
..................

The functions described here operate on symbolic formulas in the
Calculator.

* Function: calc-prepare-selection NUM
     Prepare a stack entry for selection operations.  If NUM is
     omitted, the stack entry containing the cursor is used; otherwise,
     it is the number of the stack entry to use.  This function stores
     useful information about the current stack entry into a set of
     variables.  `calc-selection-cache-num' contains the number of
     the stack entry involved (equal to NUM if you specified it);
     `calc-selection-cache-entry' contains the stack entry as a
     list (such as `calc-top-list' would return with `entry'
     as the selection mode); and `calc-selection-cache-comp' contains
     a special "tagged" composition (*Note Formatting Lisp Functions::)
     which allows Calc to relate cursor positions in the buffer with
     their corresponding sub-formulas.

     A slight complication arises in the selection mechanism because
     formulas may contain small integers.  For example, in the vector
     `[1, 2, 1]' the first and last elements are `eq' to each
     other; selections are recorded as the actual Lisp object that
     appears somewhere in the tree of the whole formula, but storing
     `1' would falsely select both `1''s in the vector.  So
     `calc-prepare-selection' also checks the stack entry and
     replaces any plain integers with "complex number" lists of the form
     `(cplx N 0)'.  This list will be displayed the same as a
     plain N and the change will be completely invisible to the
     user, but it will guarantee that no two sub-formulas of the stack
     entry will be `eq' to each other.  Next time the stack entry
     is involved in a computation, `calc-normalize' will replace
     these lists with plain numbers again, again invisibly to the user.

* Function: calc-find-selected-part
     Find the smallest sub-formula of the current formula that contains
     the cursor.  This assumes `calc-prepare-selection' has been
     called already.  If the cursor is not actually on any part of the
     formula, this returns `nil'.

* Function: calc-change-current-selection SELECTION
     Change the currently prepared stack element's selection to
     SELECTION, which should be `eq' to some sub-formula
     of the stack element, or `nil' to unselect the formula.
     The stack element's appearance in the Calc buffer is adjusted
     to reflect the new selection.

* Function: calc-find-nth-part EXPR N
     Return the Nth sub-formula of EXPR.  This function is used
     by the selection commands, and (unless `j b' has been used) treats
     sums and products as flat many-element formulas.  Thus if EXPR
     is `((a + b) - c) + d', calling `calc-find-nth-part' with
     N equal to four will return `d'.

* Function: calc-find-parent-formula EXPR PART
     Return the sub-formula of EXPR which immediately contains
     PART.  If EXPR is `a*b + (c+1)*d' and PART
     is `eq' to the `c+1' term of EXPR, then this function
     will return `(c+1)*d'.  If PART turns out not to be a
     sub-formula of EXPR, the function returns `nil'.  If
     PART is `eq' to EXPR, the function returns `t'.
     This function does not take associativity into account.

* Function: calc-find-assoc-parent-formula EXPR PART
     This is the same as `calc-find-parent-formula', except that
     (unless `j b' has been used) it continues widening the selection
     to contain a complete level of the formula.  Given `a' from
     `((a + b) - c) + d', `calc-find-parent-formula' will
     return `a + b' but `calc-find-assoc-parent-formula' will
     return the whole expression.

* Function: calc-grow-assoc-formula EXPR PART
     This expands sub-formula PART of EXPR to encompass a
     complete level of the formula.  If PART and its immediate
     parent are not compatible associative operators, or if `j b'
     has been used, this simply returns PART.

* Function: calc-find-sub-formula EXPR PART
     This finds the immediate sub-formula of EXPR which contains
     PART.  It returns an index N such that
     `(calc-find-nth-part EXPR N)' would return PART.
     If PART is not a sub-formula of EXPR, it returns `nil'.
     If PART is `eq' to EXPR, it returns `t'.  This
     function does not take associativity into account.

* Function: calc-replace-sub-formula EXPR OLD NEW
     This function returns a copy of formula EXPR, with the
     sub-formula that is `eq' to OLD replaced by NEW.

* Function: simplify EXPR
     Simplify the expression EXPR by applying various algebraic rules.
     This is what the `a s' (`calc-simplify') command uses.  This
     always returns a copy of the expression; the structure EXPR points
     to remains unchanged in memory.

     More precisely, here is what `simplify' does:  The expression is
     first normalized and evaluated by calling `normalize'.  Then
     the expression is traversed in a depth-first, bottom-up fashion; at
     each level, any simplifications that can be made are made until no
     further changes are possible.  Once the entire formula has been
     traversed in this way, it is compared with the original formula (from
     before the call to `normalize') and, if it has changed,
     the entire procedure is repeated (starting with `normalize')
     until no further changes occur.  Usually only two iterations are
     needed: one to simplify the formula, and another to verify that no
     further simplifications were possible.

* Function: simplify-extended EXPR
     Simplify the expression EXPR, with additional rules enabled that
     help do a more thorough job, while not being entirely "safe" in all
     circumstances.  (For example, this mode will simplify `sqrt(x^2)'
     to `x', which is only valid when X is positive.)  This is
     implemented by temporarily binding the variable
     `math-living-dangerously' to `t' (using a `let' form) and calling
     `simplify'.  Dangerous simplification rules are written to check
     this variable before taking any action.

* Function: simplify-units EXPR
     Simplify the expression EXPR, treating variable names as units
     whenever possible.  This works by binding the variable
     `math-simplifying-units' to `t' while calling `simplify'.

* Macro: math-defsimplify FUNCS BODY
     Register a new simplification rule; this is normally called as a
     top-level form, like `defun' or `defmath'.  If FUNCS is a symbol
     (like `+' or `calcFunc-sqrt'), this simplification rule is applied
     to the formulas which are calls to the specified function.  Or,
     FUNCS can be a list of such symbols; the rule applies to all
     functions on the list.  The BODY is written like the body of a
     function with a single argument called `expr'.  The body will be
     executed with `expr' bound to a formula which is a call to one of
     the functions FUNCS.  If the function body returns `nil', or if it
     returns a result `equal' to the original `expr', it is ignored and
     Calc goes on to try the next simplification rule that applies.  If
     the function body returns something different, that new formula is
     substituted for EXPR in the original formula.

     At each point in the formula, rules are tried in the order of the
     original calls to `math-defsimplify'; the search stops after the
     first rule that makes a change.  Thus later rules for that same
     function will not have a chance to trigger until the next iteration
     of the main `simplify' loop.

     Note that, since `defmath' is not being used here, BODY must
     be written in true Lisp code without the conveniences that `defmath'
     provides.  If you prefer, you can have BODY simply call another
     function (defined with `defmath') which does the real work.

     The arguments of a function call will already have been simplified
     before any rules for the call itself are invoked.  Since a new argument
     list is consed up when this happens, this means that the rule's body is
     allowed to rearrange the function's arguments destructively if that is
     convenient.  Here is a typical example of a simplification rule:

          (math-defsimplify calcFunc-arcsinh
            (or (and (math-looks-negp (nth 1 expr))
                     (math-neg (list 'calcFunc-arcsinh (math-neg (nth 1 expr)))))
                (and (eq (car-safe (nth 1 expr)) 'calcFunc-sinh)
                     (or math-living-dangerously
                         (math-known-realp (nth 1 (nth 1 expr))))
                     (nth 1 (nth 1 expr)))))

     This is really a pair of rules written with one `math-defsimplify'
     for convenience; the first replaces `arcsinh(-x)' with
     `-arcsinh(x)', and the second, which is safe only for real `x',
     replaces `arcsinh(sinh(x))' with `x'.

* Function: common-constant-factor EXPR
     Check EXPR to see if it is a sum of terms all multiplied by the
     same rational value.  If so, return this value.  If not, return `nil'.
     For example, if called on `6x + 9y + 12z', it would return 3, since
     3 is a common factor of all the terms.

* Function: cancel-common-factor EXPR FACTOR
     Assuming EXPR is a sum with FACTOR as a common factor,
     divide each term of the sum by FACTOR.  This is done by
     destructively modifying parts of EXPR, on the assumption that
     it is being used by a simplification rule (where such things are
     allowed; see above).  For example, consider this built-in rule for
     square roots:

          (math-defsimplify calcFunc-sqrt
            (let ((fac (math-common-constant-factor (nth 1 expr))))
              (and fac
                   (math-mul (list 'calcFunc-sqrt fac)
                             (list 'calcFunc-sqrt
                                   (math-cancel-common-factor
                                    (nth 1 expr) fac))))))

* Function: frac-gcd A B
     Compute a "rational GCD" of A and B, which must both be rational
     numbers.  This is the fraction composed of the GCD of the
     numerators of A and B, over the GCD of the denominators.  It is
     used by `common-constant-factor'.

* Function: map-tree FUNC EXPR MANY
     Try applying Lisp function FUNC to various sub-expressions of EXPR.
     Initially, call FUNC with EXPR itself as an argument.  If this
     returns an expression which is not `equal' to EXPR, apply FUNC
     again until eventually it does return EXPR with no changes.  Then,
     if EXPR is a function call, recursively apply FUNC to each of the
     arguments.  This keeps going until no changes occur anywhere in the
     expression; this final expression is returned by `map-tree'.  Note
     that, unlike simplification rules, FUNC functions may *not* make
     destructive changes to EXPR.  If a third argument MANY is provided,
     it is an integer which says how many times FUNC may be applied; the
     default, as described above, is infinitely many times.

* Function: compile-rewrites RULES
     Compile the rewrite rule set specified by RULES, which should
     be a formula that is either a vector or a variable name.  If the latter,
     the compiled rules are saved so that later `compile-rules' calls
     for that same variable can return immediately.  If there are problems
     with the rules, this function calls `error' with a suitable
     message.

* Function: apply-rewrites EXPR CRULES HEADS
     Apply the compiled rewrite rule set CRULES to the expression
     EXPR.  This will make only one rewrite and only checks at the
     top level of the expression.  The result `nil' if no rules
     matched, or if the only rules that matched did not actually change
     the expression.  The HEADS argument is optional; if is given,
     it should be a list of all function names that (may) appear in
     EXPR.  The rewrite compiler tags each rule with the
     rarest-looking function name in the rule; if you specify HEADS,
     `apply-rewrites' can use this information to narrow its search
     down to just a few rules in the rule set.

* Function: rewrite-heads EXPR
     Compute a HEADS list for EXPR suitable for use with
     `apply-rewrites', as discussed above.

* Function: rewrite EXPR RULES MANY
     This is an all-in-one rewrite function.  It compiles the rule set
     specified by RULES, then uses `map-tree' to apply the
     rules throughout EXPR up to MANY (default infinity)
     times.

* Function: match-patterns PAT VEC NOT-FLAG
     Given a Calc vector VEC and an uncompiled pattern set or
     pattern set variable PAT, this function returns a new vector
     of all elements of VEC which do (or don't, if NOT-FLAG is
     non-`nil') match any of the patterns in PAT.

* Function: deriv EXPR VAR VALUE SYMB
     Compute the derivative of EXPR with respect to variable VAR
     (which may actually be any sub-expression).  If VALUE is specified,
     the derivative is evaluated at the value of VAR; otherwise, the
     derivative is left in terms of VAR.  If the expression contains
     functions for which no derivative formula is known, new derivative
     functions are invented by adding primes to the names; *Note Calculus::.
     However, if SYMB is non-`nil', the presence of undifferentiable
     functions in EXPR instead cancels the whole differentiation, and
     `deriv' returns `nil' instead.

     Derivatives of a one-argument function can be defined by
     adding a `math-derivative-N' property to the property list
     of the symbol for the function's derivative, which will be the
     function name followed by an apostrophe.  Here N is the number
     of arguments to the function.  The value of the property should be a
     Lisp function; it is called with the same arguments as the original
     function call that is being differentiated.  It should return a formula
     for the derivative.  For example, the derivative of `ln' is defined by

          (put 'calcFunc-ln\' 'math-derivative-1
               (function (lambda (u) (math-div 1 u))))

     The two-argument `log' function has two derivatives,
          (put 'calcFunc-log\' 'math-derivative-2     ; d(log(x,b)) / dx
               ... )
          (put 'calcFunc-log\'2 'math-derivative-2    ; d(log(x,b)) / db
               ... )

* Function: tderiv EXPR VAR VALUE SYMB
     Compute the total derivative of EXPR.  This is the same as
     `deriv', except that variables other than VAR are not
     assumed to be constant with respect to VAR.

* Function: integ EXPR VAR LOW HIGH
     Compute the integral of EXPR with respect to VAR.
     *Note Calculus::, for further details.

* Macro: math-defintegral FUNCS BODY
     Define a rule for integrating a function or functions of one argument;
     this macro is very similar in format to `math-defsimplify'.
     The main difference is that here BODY is the body of a function
     with a single argument `u' which is bound to the argument to the
     function being integrated, not the function call itself.  Also, the
     variable of integration is available as `math-integ-var'.  If
     evaluation of the integral requires doing further integrals, the body
     should call `(math-integral X)' to find the integral of
     X with respect to `math-integ-var'; this function returns
     `nil' if the integral could not be done.  Some examples:

          (math-defintegral calcFunc-conj
            (let ((int (math-integral u)))
              (and int
                   (list 'calcFunc-conj int))))

          (math-defintegral calcFunc-cos
            (and (equal u math-integ-var)
                 (math-from-radians-2 (list 'calcFunc-sin u))))

     In the `cos' example, we define only the integral of `cos(x) dx',
     relying on the general integration-by-substitution facility to
     handle cosines of more complicated arguments.  An integration rule
     should return `nil' if it can't do the integral; if several rules
     are defined for the same function, they are tried in order until
     one returns a non-`nil' result.

* Macro: math-defintegral-2 FUNCS BODY
     Define a rule for integrating a function or functions of two
     arguments.  This is exactly analogous to `math-defintegral', except
     that BODY is written as the body of a function with two arguments,
     U and V.

* Function: solve-for LHS RHS VAR FULL
     Attempt to solve the equation `LHS = RHS' by isolating the variable
     VAR on the lefthand side; return the resulting righthand side, or
     `nil' if the equation cannot be solved.  The variable VAR must
     appear at least once in LHS or RHS; if it appears more than once,
     Calc can solve the equation in only a few cases (such as when the
     quadratic formula can be applied).  Note that the return value is a
     formula which does not contain VAR; this is different from the
     user-level `solve' and `finv' functions, which return a rearranged
     equation or a functional inverse, respectively.  If FULL is
     non-`nil', a full solution including dummy signs and dummy integers
     will be produced.  User-defined inverses are provided as properties
     in a manner similar to derivatives:

          (put 'calcFunc-ln 'math-inverse
               (function (lambda (x) (list 'calcFunc-exp x))))

     This function can call `(math-solve-get-sign X)' to create
     a new arbitrary sign variable, returning X times that sign, and
     `(math-solve-get-int X)' to create a new arbitrary integer
     variable multiplied by X.  These functions simply return X
     if the caller requested a non-"full" solution.

* Function: solve-eqn EXPR VAR FULL
     This version of `solve-for' takes an expression which will
     typically be an equation or inequality.  (If it is not, it will be
     interpreted as the equation `EXPR = 0'.)  It returns an
     equation or inequality, or `nil' if no solution could be found.

* Function: expr-contains EXPR VAR
     Returns the number of occurrences of VAR as a subexpression of
     EXPR, or `nil' if there are no occurrences.  Thus, this function
     can be used as a Lisp predicate or as an actual counting function.

     When used as a predicate, this function seems at first to be identical
     to `calc-find-sub-formula'.  The key difference is that
     `expr-contains' uses `equal' to test for matches, whereas
     `calc-find-sub-formula' uses `eq'.  In the formula
     `f(a, a)', the two `a''s will be `equal' but not
     `eq' to each other.

* Function: expr-depends EXPR VAR
     Returns true if EXPR refers to any variable the occurs in VAR.
     In other words, it checks if EXPR and VAR have any variables
     in common.

* Function: expr-contains-vars EXPR
     Return true if EXPR contains any variables, or `nil' if EXPR
     contains only constants and functions with constant arguments.

* Function: expr-subst EXPR OLD NEW
     Returns a copy of EXPR, with all occurrences of OLD replaced by
     NEW.  This treats the derivative forms specially with respect to
     the dummy variable, so that the effect is always to return EXPR
     evaluated at OLD = NEW.

* Function: expr-weight EXPR
     Returns the "weight" of EXPR, basically a count of the total
     number of objects and function calls that appear in EXPR.  For
     "primitive" objects, this will be one.

* Function: expr-height EXPR
     Returns the "height" of EXPR, which is the deepest level to which
     function calls are nested.  (Note that `A + B' counts as a function
     call.)  For primitive objects, this returns zero.

* Function: polynomial-p EXPR VAR
     Check if EXPR is a polynomial in variable (or sub-expression) VAR.
     If so, return the degree of the polynomial, that is, the highest
     power of VAR that appears in EXPR.  For example, for `(x^2 + 3)^3 +
     4' this would return 6.  This function returns `nil' unless EXPR,
     when expanded out by `a x' (`calc-expand'), would consist of a sum
     of terms in which VAR appears only raised to nonnegative integer
     powers.  Note that if VAR does not occur in EXPR, then EXPR is
     considered a polynomial of degree 0.

* Function: is-polynomial EXPR VAR DEGREE LOOSE
     Check if EXPR is a polynomial in variable or sub-expression VAR,
     and, if so, return a list representation of the polynomial where
     the elements of the list are coefficients of successive powers of
     VAR: `A + B x + C x^3' would produce the list `(A B 0 C)', and `(x
     + 1)^2' would produce the list `(1 2 1)'.  The highest element of
     the list will be non-zero, with the special exception that if EXPR
     is the constant zero, the returned value will be `(0)'.  Return
     `nil' if EXPR is not a polynomial in VAR.  If DEGREE is specified,
     this will not consider polynomials of degree higher than that
     value.  This is a good precaution because otherwise an input of
     `(x+1)^1000' will cause a huge coefficient list to be built.  If
     LOOSE is non-`nil', then a looser definition of a polynomial is
     used in which coefficients are no longer required not to depend on
     VAR, but are only required not to take the form of polynomials
     themselves.  For example, `sin(x) x^2 + cos(x)' is a loose
     polynomial with coefficients `((calcFunc-cos x) 0 (calcFunc-sin
     x))'.  The result will never be `nil' in loose mode, since any
     expression can be interpreted as a "constant" loose polynomial.

* Function: polynomial-base EXPR PRED
     Check if EXPR is a polynomial in any variable that occurs in it; if
     so, return that variable.  (If EXPR is a multivariate polynomial,
     choose one variable arbitrarily.)  If PRED is specified, it should
     be a Lisp function which is called as `(PRED SUBEXPR)', and which
     should return true if `mpb-top-expr' (a global name for the
     original EXPR) is a suitable polynomial in SUBEXPR.  The default
     predicate uses `(polynomial-p mpb-top-expr SUBEXPR)'; you can use
     PRED to specify additional conditions.  Or, you could have PRED
     build up a list of every suitable SUBEXPR that is found.

* Function: poly-simplify POLY
     Simplify polynomial coefficient list POLY by (destructively)
     clipping off trailing zeros.

* Function: poly-mix A AC B BC
     Mix two polynomial lists A and B (in the form returned by
     `is-polynomial') in a linear combination with coefficient
     expressions AC and BC.  The result is a (not necessarily
     simplified) polynomial list representing `AC A + BC B'.

* Function: poly-mul A B
     Multiply two polynomial coefficient lists A and B.  The
     result will be in simplified form if the inputs were simplified.

* Function: build-polynomial-expr POLY VAR
     Construct a Calc formula which represents the polynomial
     coefficient list POLY applied to variable VAR.  The `a c'
     (`calc-collect') command uses `is-polynomial' to turn an expression
     into a coefficient list, then `build-polynomial-expr' to turn the
     list back into an expression in regular form.

* Function: check-unit-name VAR
     Check if VAR is a variable which can be interpreted as a unit
     name.  If so, return the units table entry for that unit.  This
     will be a list whose first element is the unit name (not counting
     prefix characters) as a symbol and whose second element is the
     Calc expression which defines the unit.  (Refer to the Calc sources
     for details on the remaining elements of this list.)  If VAR
     is not a variable or is not a unit name, return `nil'.

* Function: units-in-expr-p EXPR SUB-EXPRS
     Return true if EXPR contains any variables which can be interpreted
     as units.  If SUB-EXPRS is `t', the entire expression is searched.
     If SUB-EXPRS is `nil', this checks whether EXPR is directly a units
     expression.

* Function: single-units-in-expr-p EXPR
     Check whether EXPR contains exactly one units variable.  If so,
     return the units table entry for the variable.  If EXPR does
     not contain any units, return `nil'.  If EXPR contains
     two or more units, return the symbol `'wrong'.

* Function: to-standard-units EXPR WHICH
     Convert units expression EXPR to base units.  If WHICH is `nil',
     use Calc's native base units.  Otherwise, WHICH can specify a units
     system, which is a list of two-element lists, where the first
     element is a Calc base symbol name and the second is an expression
     to substitute for it.

* Function: remove-units EXPR
     Return a copy of EXPR with all units variables replaced by ones.
     This expression is generally normalized before use.

* Function: extract-units EXPR
     Return a copy of EXPR with everything but units variables replaced
     by ones.


File: calc.info  Node: Formatting Lisp Functions, Prev: Symbolic Lisp Functions, Up: Internals, Next: Lisp Variables

I/O and Formatting Functions
............................

The functions described here are responsible for parsing and formatting
Calc numbers and formulas.

* Function: calc-eval STR SEP ARG1 ARG2 ...
     This is the simplest interface to the Calculator from another Lisp program.
     *Note Calling Calc from Your Programs::.

* Function: read-number STR
     If string STR contains a valid Calc number, either integer,
     fraction, float, or HMS form, this function parses and returns that
     number.  Otherwise, it returns `nil'.

* Function: read-expr STR
     Read an algebraic expression from string STR.  If STR does not have
     the form of a valid expression, return a list of the form `(error
     POS MSG)' where POS is an integer index into STR of the general
     location of the error, and MSG is a string describing the problem.

* Function: read-exprs STR
     Read a list of expressions separated by commas, and return it as a
     Lisp list.  If an error occurs in any expressions, an error list as
     shown above is returned instead.

* Function: calc-do-alg-entry INITIAL PROMPT NO-NORM
     Read an algebraic formula or formulas using the minibuffer.  All
     conventions of regular algebraic entry are observed.  The return
     value is a list of Calc formulas; there will be more than one if
     the user entered a list of values separated by commas.  The result
     is `nil' if the user presses Return with a blank line.  If INITIAL
     is given, it is a string which the minibuffer will initially
     contain.  If PROMPT is given, it is the prompt string to use; the
     default is "Algebraic:".  If NO-NORM is `t', the formulas will be
     returned exactly as parsed; otherwise, they will be passed through
     `calc-normalize' first.

     To support the use of `$' characters in the algebraic entry, use
     `let' to bind `calc-dollar-values' to a list of the values to be
     substituted for `$', `$$', and so on, and bind `calc-dollar-used'
     to 0.  Upon return, `calc-dollar-used' will have been changed to
     the highest number of consecutive `$'s that actually appeared in
     the input.

* Function: format-number A
     Convert the real or complex number or HMS form A to string form.

* Function: format-flat-expr A PREC
     Convert the arbitrary Calc number or formula A to string form,
     in the style used by the trail buffer.  This is a simple format designed
     mostly to guarantee the string is of a form that can be re-parsed by
     `read-expr'.  Most formatting modes, such as digit grouping,
     complex number format, and point character, are ignored to ensure the
     result will be re-readable.  The PREC parameter is normally 0; if
     you pass a large integer like 1000 instead, the expression will be
     surrounded by parentheses unless it is a plain number or variable name.

* Function: format-nice-expr A WIDTH
     This is like `format-flat-expr' (with PREC equal to 0),
     except that newlines will be inserted to keep lines down to the
     specified WIDTH, and vectors of vectors (not necessarily
     strict matrices) are written in a pseudo-matrix format.  The
     `calc-edit' command uses this when only a stack entry is
     being edited.

* Function: format-value A WIDTH
     Convert the Calc number or formula A to string form, using the
     format seen in the stack buffer.  Beware the the string returned
     may not be re-readable by `read-expr', for example, because of
     digit grouping.  Multi-line objects like matrices produce strings
     that contain newline characters to separate the lines.  The W
     parameter, if given, is the target window size for which to format
     the expressions.  If W is omitted, the width of the Calculator
     window is used.

* Function: compose-expr A PREC
     Format the Calc number or formula A according to the current
     language mode, returning a "composition."  To learn about the
     structure of compositions, see the comments in the Calc source code.
     You can specify the format of a given type of function call by putting
     a `math-compose-LANG' property on the function's symbol,
     whose value is a Lisp function that takes A and PREC as
     arguments and returns a composition.  Here LANG is a language
     mode name, one of `normal', `big', `c', `pascal',
     `fortran', `tex', `eqn', `math', or `maple'.
     In Big mode, Calc actually tries `math-compose-big' first, then
     tries `math-compose-normal'.  If this property does not exist,
     or if the function returns `nil', the function is written in the
     normal function-call notation for that language.

* Function: composition-to-string C W
     Convert a composition structure returned by `compose-expr' into
     a string.  Multi-line compositions convert to strings containing
     newline characters.  The target window size is given by W.
     The `format-value' function basically calls `compose-expr'
     followed by `composition-to-string'.

* Function: comp-width C
     Compute the width in characters of composition C.

* Function: comp-height C
     Compute the height in lines of composition C.

* Function: comp-ascent C
     Compute the portion of the height of composition C which is on or
     above the baseline.  For a one-line composition, this will be one.

* Function: comp-descent C
     Compute the portion of the height of composition C which is below
     the baseline.  For a one-line composition, this will be zero.

* Function: comp-first-char C
     If composition C is a simple horizontal composition, return the
     first (leftmost) character of the composition as an integer.
     Otherwise, return `nil'.

* Function: comp-last-char C
     If composition C is a simple horizontal composition, return the
     last (rightmost) character, otherwise return `nil'.


File: calc.info  Node: Lisp Variables, Prev: Formatting Lisp Functions, Up: Internals, Next: Hooks

Lisp Variables
..............

(This section is currently unfinished.)


File: calc.info  Node: Hooks, Prev: Lisp Variables, Up: Internals

Hooks
.....

Hooks are variables which contain Lisp functions (or lists of functions)
which are called at various times.  Calc defines a number of hooks
that help you to customize it in various ways.  Calc uses the Lisp
function `run-hooks' to invoke the hooks shown below.  Several
other customization-related variables are also described here.

* Variable: calc-load-hook
     This hook is called at the end of `calc.el', after the file has
     been loaded, before any functions in it have been called, but after
     `calc-mode-map' and similar variables have been set up.

* Variable: calc-ext-load-hook
     This hook is called at the end of `calc-ext.el'.

* Variable: calc-start-hook
     This hook is called as the last step in a `M-x calc' command.
     At this point, the Calc buffer has been created and initialized if
     necessary, the Calc window and trail window have been created,
     and the "Welcome to Calc" message has been displayed.

* Variable: calc-mode-hook
     This hook is called when the Calc buffer is being created.  Usually
     this will only happen once per Emacs session.  The hook is called
     after Emacs has switched to the new buffer, the mode-settings file
     has been read if necessary, and all other buffer-local variables
     have been set up.  After this hook returns, Calc will perform a
     `calc-refresh' operation, set up the mode line display, then
     evaluate any deferred `calc-define' properties that have not
     been evaluated yet.

* Variable: calc-trail-mode-hook
     This hook is called when the Calc Trail buffer is being created.
     It is called as the very last step of setting up the Trail buffer.
     Like `calc-mode-hook', this will normally happen only once
     per Emacs session.

* Variable: calc-end-hook
     This hook is called by `calc-quit', generally because the user
     presses q or `M-# c' while in Calc.  The Calc buffer will
     be the current buffer.  The hook is called as the very first
     step, before the Calc window has been destroyed.

* Variable: calc-window-hook
     If this hook exists, it is called to create the Calc window.
     Upon return, this new Calc window should be the current window.
     (The Calc buffer will already be the current buffer when the
     hook is called.)  If the hook is not defined, Calc will
     generally use `split-window', `set-window-buffer',
     and `select-window' to create the Calc window.

* Variable: calc-trail-window-hook
     If this hook exists, it is called to create the Calc Trail window.
     The variable `calc-trail-buffer' will contain the buffer
     which the window should use.  Unlike `calc-window-hook',
     this hook must *not* switch into the new window.

* Variable: calc-edit-mode-hook
     This hook is called by `calc-edit' (and a few other similar
     commands) when the temporary editing buffer is being created.
     The buffer will have been selected and set up to be in
     `calc-edit-mode', but will not yet have been filled with
     text.  (In fact it may still have leftover text from a previous
     `calc-edit' command.)

* Variable: calc-mode-save-hook
     This hook is called by the `calc-save-modes' command,
     after Calc's own mode features have been inserted into the
     `.emacs' buffer and just before the "End of mode settings"
     message is inserted.

* Variable: calc-reset-hook
     This hook is called after `M-# 0' (`calc-reset') has
     reset all modes.  The Calc buffer will be the current buffer.

* Variable: calc-other-modes
     This variable contains a list of strings.  The strings are
     concatenated at the end of the modes portion of the Calc
     mode line (after standard modes such as "Deg", "Inv" and
     "Hyp").  Each string should be a short, single word followed
     by a space.  The variable is `nil' by default.

* Variable: calc-mode-map
     This is the keymap that is used by Calc mode.  The best time
     to adjust it is probably in a `calc-mode-hook'.  If the
     Calc extensions package (`calc-ext.el') has not yet been
     loaded, many of these keys will be bound to `calc-missing-key',
     which is a command that loads the extensions package and
     "retypes" the key.  If your `calc-mode-hook' rebinds
     one of these keys, it will probably be overridden when the
     extensions are loaded.

* Variable: calc-digit-map
     This is the keymap that is used during numeric entry.  Numeric
     entry uses the minibuffer, but this map binds every non-numeric
     key to `calcDigit-nondigit' which generally calls
     `exit-minibuffer' and "retypes" the key.

* Variable: calc-alg-ent-map
     This is the keymap that is used during algebraic entry.  This is
     mostly a copy of `minibuffer-local-map'.

* Variable: calc-store-var-map
     This is the keymap that is used during entry of variable names for
     commands like `calc-store' and `calc-recall'.  This is
     mostly a copy of `minibuffer-local-completion-map'.

* Variable: calc-edit-mode-map
     This is the (sparse) keymap used by `calc-edit' and other
     temporary editing commands.  It binds RET, LFD,
     and `C-c C-c' to `calc-edit-finish'.

* Variable: calc-mode-var-list
     This is a list of variables which are saved by `calc-save-modes'.
     Each entry is a list of two items, the variable (as a Lisp symbol)
     and its default value.  When modes are being saved, each variable
     is compared with its default value (using `equal') and any
     non-default variables are written out.

* Variable: calc-local-var-list
     This is a list of variables which should be buffer-local to the
     Calc buffer.  Each entry is a variable name (as a Lisp symbol).
     These variables also have their default values manipulated by
     the `calc' and `calc-quit' commands; *Note Multiple Calculators::.
     Since `calc-mode-hook' is called after this list has been
     used the first time, your hook should add a variable to the
     list and also call `make-local-variable' itself.


File: calc.info  Node: Installation, Prev: Programming, Up: Top, Next: Reporting Bugs

Installation
************

Calc 2.01 comes as a set of GNU Emacs Lisp files, with names like
`calc.el' and `calc-ext.el', and also as a `calc.texinfo' file which can
be used to generate both on-line and printed documentation.

To install Calc, just follow these simple steps.  If you want more
information, each step is discussed at length in the sections below.

  1. Change (`cd') to the Calc "home" directory.  This directory was
     created when you unbundled the Calc `.tar' or `.shar' file.

  2. Type `make' to install Calc privately for your own use, or type
     `make install' to install Calc system-wide.  This will compile all
     the Calc component files, modify your `.emacs' or the system-wide
     `lisp/default' file to install Calc as appropriate, and format
     the on-line Calc manual.

     Both variants are shorthand for the following three steps:
        * `make compile' to run the byte-compiler.

        * `make private' or `make public', corresponding to
          `make' and `make install', respectively.  (If `make public'
          fails because your system doesn't already have a `default' or
          `default.el' file, use Emacs or the Unix `touch' command
          to create a zero-sized one first.)

        * `make info' to format the on-line Calc manual.  This first tries
          to use the `makeinfo' program; if that program is not present, it
          uses the Emacs `texinfo-format-buffer' command instead.
     The Unix `make' utility looks in the file `Makefile' in the
     current directory to see what Unix commands correspond to the various
     "targets" like `install' or `public'.  If your system
     doesn't have `make', you will have to examine the `Makefile'
     and type in the corresponding commands by hand.

  3. If you ever move Calc to a new home directory, just give the
     `make private' or `make public' command again in the new
     directory.

  4. Test your installation as described at the end of these instructions.

  5. (Optional.)  To print a hardcopy of the Calc manual (over 500 pages)
     or just the Calc Summary (about 20 pages), follow the instructions under
     "Printed Documentation" below.

Calc is now installed and ready to go!



Upgrading from Calc 1.07
========================

If you have Calc version 1.07 or earlier, you will find that Calc 2.00
is organized quite differently.  For one, Calc 2.00 is now distributed
already split into many parts; formerly this was done as part of the
installation procedure.  Also, some new functions must be autoloaded
and the `M-#' key must be bound to `calc-dispatch' instead
of to `calc'.

The easiest way to upgrade is to delete your old Calc files and then
install Calc 2.00 from scratch using the above instructions.  You should
then go into your `.emacs' or `default' file and remove the
old `autoload' and `global-set-key' commands for Calc, since
`make public'/`make private' has added new, better ones.

*Note New for Calc 2.00::, for more information about what has
changed since version 1.07.



The `make public' Command
=========================

If you are not the regular Emacs administrator on your system, your
account may not be allowed to execute the `make public' command,
since the system-wide `default' file may be write-protected.
If this is the case, you will have to ask your Emacs installer to
execute this command.  (Just `cd' to the Calc home directory
and type `make public'.)

The `make private' command adds exactly the same set of commands
to your `.emacs' file as `make public' adds to `default'.
If your Emacs installer is concerned about typing this command out of
the blue, you can ask her/him instead to copy the necessary text from
your `.emacs' file.  (They will be marked by a comment that says
"Commands added by `calc-private-autoloads' on (date and time).")



Compilation
===========

Calc is written in a way that maximizes performance when its code has been
byte-compiled; a side effect is that performance is seriously degraded if
it *isn't* compiled.  Thus, it is essential to compile the Calculator
before trying to use it.  The function `calc-compile' in the file
`calc-maint.el' runs the Emacs byte-compiler on all the Calc source
files.  (Specifically, it runs `M-x byte-compile-file' on all files
in the current directory with names of the form `calc*.el', and also
on the file `macedit.el'.)

If `calc-compile' finds that certain files have already been
compiled and have not been changed since, then it will not bother to
recompile those files.

The `calc-compile' command also pre-builds certain tables, such as
the units table (*Note The Units Table::) and the built-in rewrite rules
(*Note Rearranging with Selections::) which Calc would otherwise
need to rebuild every time those features were used.

The `make compile' shell command is simply a convenient way to
start an Emacs and give it a `calc-compile' command.



Auto-loading
============

To teach Emacs how to load in Calc when you type `M-#' for the
first time, add these lines to your `.emacs' file (if you are
installing Calc just for your own use), or the system's `lisp/default'
file (if you are installing Calc publicly).  The `make private'
and `make public' commands, respectively, take care of this.
(Note that `make' runs `make private', and `make install'
runs `make public'.)

     (autoload 'calc-dispatch          "calc" "Calculator Options" t)
     (autoload 'full-calc              "calc" "Full-screen Calculator" t)
     (autoload 'full-calc-keypad       "calc" "Full-screen X Calculator" t)
     (autoload 'calc-eval              "calc" "Use Calculator from Lisp")
     (autoload 'defmath                "calc" nil t t)
     (autoload 'calc                   "calc" "Calculator Mode" t)
     (autoload 'quick-calc             "calc" "Quick Calculator" t)
     (autoload 'calc-keypad            "calc" "X windows Calculator" t)
     (autoload 'calc-embedded          "calc" "Use Calc from any buffer" t)
     (autoload 'calc-embedded-activate "calc" "Activate =>'s in buffer" t)
     (autoload 'calc-grab-region       "calc" "Grab region of Calc data" t)
     (autoload 'calc-grab-rectangle    "calc" "Grab rectangle of data" t)

Unless you have installed the Calc files in Emacs' main `lisp/'
directory, you will also have to add a command that looks like the
following to tell Emacs where to find them.  In this example, we
have put the files in directory `/usr/gnu/src/calc-2.01'.

     (setq load-path (append load-path (list "/usr/gnu/src/calc-2.01")))

The `make public' and `make private' commands also do this (they use the
then-current directory as the name to add to the path).  If you move
Calc to a new location, just repeat the `make public' or `make private'
command to have this new location added to the `load-path'.

The `autoload' command for `calc-dispatch' is what loads
`calc.elc' when you type `M-#'.  It is the only `autoload'
that is absolutely necessary for Calc to work.  The others are for
commands and features that you may wish to use before typing
`M-#' for the first time.  In particular, `full-calc' and
`full-calc-keypad' are autoloaded to support "standalone"
operation (*Note Standalone Operation::), `calc-eval' and
`defmath' are autoloaded to allow other Emacs Lisp programs to
use Calc facilities (*Note Calling Calc from Your Programs::), and
`calc-embedded-activate' is autoloaded because some Embedded
Mode files may call it as soon as they are read into Emacs
(*Note Assignments in Embedded Mode::).



Finding Component Files
=======================

There is no need to write `autoload' commands that point to all
the various Calc component files like `calc-misc.elc' and
`calc-alg.elc'.  The main file, `calc.elc', contains all
the necessary `autoload' commands for these files.

(Actually, to conserve space `calc.elc' only autoloads a few of
the component files, plus `calc-ext.elc', which in turn autoloads
the rest of the components.  This allows Calc to load a little faster
in the beginning, but the net effect is the same.)

This autoloading mechanism assumes that all the component files can
be found on the `load-path'.  The `make public' and
`make private' commands take care of this, but Calc has a few
other strategies in case you have installed it in an unusual way.

If, when Calc is loaded, it is unable to find its components on the
`load-path' it is given, it checks the file name in the original
`autoload' command for `calc-dispatch'.  If that name
included directory information, Calc adds that directory to the
`load-path':

     (autoload 'calc-dispatch "calc-2.01/calc" "Calculator" t)

Suppose the directory `/usr/gnu/src/emacs/lisp' is on the path, and
the above `autoload' allows Emacs to find Calc under the name
`/usr/gnu/src/emacs/lisp/calc-2.01/calc.elc'.  Then when Calc
starts up it will add `/usr/gnu/src/emacs/lisp/calc-2.01'
to the path so that it will later be able to find its component files.

If the above strategy does not locate the component files, Calc
examines the variable `calc-autoload-directory'.  This is
initially `nil', but you can store the name of Calc's home
directory in it as a sure-fire way of getting Calc to find its
components.



Merging Source Files
====================

If the `autoload' mechanism is not managing to load each part of Calc
when it is needed, you can concatenate all the `.el' files into one big
file.  The order should be `calc.el', then `calc-ext.el', then all the
other files in any order.  Byte-compile the resulting big file.  This
merged Calculator ought to work just like Calc normally does, though it
will be *substantially* slower to load.



Key Bindings
============

Calc is normally bound to the `M-#' key.  To set up this key
binding, include the following command in your `.emacs' or
`lisp/default' file.  (This is done automatically by
`make private' or `make public', respectively.)

     (global-set-key "\e#" 'calc-dispatch)

Note that `calc-dispatch' actually works as a prefix for various
two-key sequences.  If you have a convenient unused function key on
your keyboard, you may wish to bind `calc-dispatch' to that as
well.  You may even wish to bind other specific Calc functions like
`calc' or `quick-calc' to other handy function keys.

Even if you bind `calc-dispatch' to other keys, it is best to
bind it to `M-#' as well if you possibly can:  There are references
to `M-#' all throughout the Calc manual which would confuse novice
users if they didn't work as advertised.

Another key binding issue is the DEL key.  Some installations
use a different key (such as backspace) for this purpose.  Calc
normally scans the entire keymap and maps all keys defined like
DEL to the `calc-pop' command.  However, this may be
slow.  You can set the variable `calc-scan-for-dels' to
`nil' to cause only the actual DEL key to be mapped to
`calc-pop'; this will speed loading of Calc.



The `macedit' Package
=====================

The file `macedit.el' contains another useful Emacs extension
called `edit-kbd-macro'.  It allows you to edit a keyboard macro
in human-readable form.  The `Z E' command in Calc knows how to
use it to edit user commands that have been defined by keyboard macros.
To autoload it, you will want to include the commands,

     (autoload 'edit-kbd-macro      "macedit" "Edit Keyboard Macro" t)
     (autoload 'edit-last-kbd-macro "macedit" "Edit Keyboard Macro" t)
     (autoload 'read-kbd-macro      "macedit" "Read Keyboard Macro" t)

The `make public' and `make private' commands do this.



The GNUPLOT Program
===================

Calc's graphing commands use the GNUPLOT program.  If you have GNUPLOT
but you must type some command other than `gnuplot' to get it, you
should add a command to set the Lisp variable `calc-gnuplot-name' to the
appropriate file name.  You may also need to change the variables
`calc-gnuplot-plot-command' and `calc-gnuplot-print-command' in order to
get correct displays and hardcopies, respectively, of your plots.



On-Line Documentation
=====================

The documentation for Calc (this manual) comes in a file called
`calc.texinfo'.  To format this for use as an on-line manual,
type `make info' (to use the `makeinfo' program), or
`make texinfo' (to use the `texinfmt.el' program which runs
inside of Emacs).  The former command is recommended if it works
on your system; it is faster and produces nicer-looking output.

The `makeinfo' program will report inconsistencies involving
the nodes `Copying' and `Interactive Tutorial'; these
messages should be ignored.

The result will be a collection of files whose names begin with
`calc.info'.  You may wish to add a reference to the first
of these, `calc.info' itself, to your Info system's `dir'
file.  (The `M-# i' command will access `calc.info'
whether or not it appears in the `dir' file.)

There is a Lisp variable called `calc-info-filename' which holds
the name of the Info file containing Calc's on-line documentation.
Its default value is `"calc.info"', which will work correctly if
the Info files are stored in Emacs' main `info/' directory, or if
they are in any of the directories listed in the `load-path'.  If
you keep them elsewhere, you will want to put a command of the form,

     (setq calc-info-filename ".../calc.info")

in your `.emacs' or `lisp/default' file, where `...'
represents the directory containing the Info files.  This will not
be necessary if you follow the normal installation procedures.

The `make info' and `make texinfo' commands compare the dates
on the files `calc.texinfo' and `calc.info', and run the
appropriate program only if the latter file is older or does not exist.



Printed Documentation
=====================

Because the Calc manual is so large, you should only make a printed copy
if you really need it.  To print the manual, you will need the TeX
typesetting program (this is a free program by Donald Knuth at Stanford
University) as well as the `texindex' program and `texinfo.tex' file,
both of which can be obtained from the FSF under the name `texinfo2'.

To print the Calc manual in one huge 550 page tome, type `make tex'.
This will take care of running the manual through TeX twice so that
references to later parts of the manual will have correct page numbers.
(Don't worry if you get some "overfull box" warnings.  Also, some
versions of `texinfo.tex' have a bug that causes cross-references
to the index to print incorrectly.)

The result will be a device-independent output file called
`calc.dvi', which you must print in whatever way is right
for your system.  On many systems, the command is

     lpr -d calc.dvi

Some people find the Calc manual to be too large to handle easily.
In fact, some versions of TeX have too little memory to print it.
So Calc includes a `calc-split-manual' command that splits
`calc.texinfo' into two volumes, the Calc Tutorial and the
Calc Reference.  The easiest way to use it is to type `make tex2'
instead of `make tex'.  The result will be two smaller files,
`calctut.dvi' and `calcref.dvi'.  The former contains the
tutorial part of the manual; the latter contains the reference part.
Both volumes include copies of the "Getting Started" chapter and
licensing information.

To save disk space, you may wish to delete `calctut.*' and
`calcref.*' after you're done.  Don't delete `calc.texinfo',
because you will need it to install future patches to Calc.
The `make tex2' command takes care of this for you.

The `make textut' command formats only the Calc Tutorial volume,
producing `calctut.dvi' but not `calcref.dvi'.  Likewise,
`make texref' formats only the Calc Reference volume.

Finally, there is a `calc-split-summary' command that splits off
just the Calc Summary appendix suitable for printing by itself.
Type `make summary' instead of `make tex'.  The resulting
`calcsum.dvi' file will print in less than 20 pages.

If you don't have TeX, you can print the summary as a plain text
file by going to the `Summary' node in Calc's Info file, then
typing `M-x print-buffer' (*Note Summary::).



Settings File
=============

Another variable you might want to set is `calc-settings-file', which
holds the file name in which commands like `m m' and `Z P' store
"permanent" definitions.  The default value for this variable is
`"~/.emacs"'.  If `calc-settings-file' does not contain `".emacs"' as a
substring, and if the variable `calc-loaded-settings-file' is `nil',
then Calc will automatically load your settings file (if it exists) the
first time Calc is invoked.



Testing the Installation
========================

To test your installation of Calc, start a new Emacs and type `M-# c'
to make sure the autoloads and key bindings work.  Type `M-# i'
to make sure Calc can find its Info documentation.  Press `q' to
exit the Info system and `M-# c' to re-enter the Calculator.
Type `20 S' to compute the sine of 20 degrees; this will test the
autoloading of the extensions modules.  The result should be
0.342020143326.  Finally, press `M-# c' again to make sure the
Calculator can exit.

You may also wish to test the GNUPLOT interface; to plot a sine wave,
type `' [0 .. 360], sin(x) RET g f'.  Type `g q' when you
are done viewing the plot.

Calc is now ready to use.  If you wish to go through the Calc Tutorial,
press `M-# t' to begin.


(The above text is included in both the Calc documentation and the
file INSTALL in the Calc distribution directory.)


