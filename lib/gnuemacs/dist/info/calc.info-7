Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: Stack Basics, Prev: Help Commands, Up: Introduction, Next: Numeric Entry

Stack Basics
============

Calc uses RPN notation.  If you are not familar with RPN, *Note RPN Tutorial::.

To add the numbers 1 and 2 in Calc you would type the keys: `1 RET 2 +'.
(RET corresponds to the ENTER key on most calculators.)  The first three
keystrokes "push" the numbers 1 and 2 onto the stack.  The `+' key
always "pops" the top two numbers from the stack, adds them, and pushes
the result (3) back onto the stack.  This number is ready for further
calculations: `5 -' pushes 5 onto the stack, then pops the 3 and 5,
subtracts them, and pushes the result (-2).

Note that the "top" of the stack actually appears at the *bottom*
of the buffer.  A line containing a single `.' character signifies
the end of the buffer; Calculator commands operate on the number(s)
directly above this line.  The `d t' (`calc-truncate-stack')
command allows you to move the `.' marker up and down in the stack;
*Note Truncating the Stack::.

Stack elements are numbered consecutively, with number 1 being the top of
the stack.  These line numbers are ordinarily displayed on the lefthand side
of the window.  The `d l' (`calc-line-numbering') command controls
whether these numbers appear.  (Line numbers may be turned off since they
slow the Calculator down a bit and also clutter the display.)

The unshifted letter `o' (`calc-realign') command (also on the
`d `' key) repositions the cursor to its top-of-stack "home"
position.  It also undoes any horizontal scrolling in the window.
If you give it a numeric prefix argument, it instead moves the cursor
to the specified stack element.

The RET (or equivalent SPC) key is only required to separate two
consecutive numbers.  (After all, if you typed `1 2' by themselves the
Calculator would enter the number 12.)  If you press `RET' or `SPC'
*not* right after typing a number, the key duplicates the number on the
top of the stack.  `RET *' is thus a handy way to square a number.

The DEL key pops and throws away the top number on the stack.  The TAB
key swaps the top two objects on the stack.  *Note Stack and Trail::,
for descriptions of these and other stack-related commands.


File: calc.info  Node: Numeric Entry, Prev: Stack Basics, Up: Introduction, Next: Algebraic Entry

Numeric Entry
=============

Pressing a digit or other numeric key begins numeric entry using the
minibuffer.  The number is pushed on the stack when you press the RET
or SPC keys.  If you press any other non-numeric key, the number is
pushed onto the stack and the appropriate operation is performed.  If
you press a numeric key which is not valid (say, a second decimal point),
the key is ignored.

There are three different concepts corresponding to the word "minus,"
typified by `a-b' (subtraction), `-x' (change-sign), and `-5' (negative
number).  Calc uses three different keys for these operations,
respectively: `-', `n', and `_' (the underscore).  The `-' key subtracts
the two numbers on the top of the stack.  The `n' key changes the sign
of the number on the top of the stack or the number currently being
entered.  The `_' key begins entry of a negative number or changes the
sign of the number currently being entered.  The following sequences all
enter the number -5 onto the stack: `0 RET 5 -', `5 n RET', `5 RET n',
`_ 5 RET', `5 _ RET'.

The `#', `@', `'', `"', `p', and `M' keys are
also active during numeric entry.  They are used for entering
non-decimal numbers, HMS forms, and so on; these notations are
described later in this manual with the corresponding data types.
*Note Data Types::.

During numeric entry, the only editing key available is `DEL'.


File: calc.info  Node: Algebraic Entry, Prev: Numeric Entry, Up: Introduction, Next: Quick Calculator

Algebraic Entry
===============

Calculations can also be entered in algebraic form.  This is
accomplished by typing the apostrophe key, `'', followed by the
expression in standard format: `' 2+3*4 RET' computes `2+(3*4) = 14' and
pushes that on the stack.  If you wish you can ignore the RPN aspect of
Calc altogether and simply enter algebraic expressions in this way.  You
may want to use DEL every so often to clear previous results off the
stack.

You can press the apostrophe key during normal numeric entry to switch
the half-entered number into algebraic entry mode.  One reason to do this
would be to use the full Emacs cursor motion and editing keys, which are
available during algebraic entry but not during numeric entry.

In the same vein, during either numeric or algebraic entry you can
press ``' to switch to `calc-edit' mode, where you complete
your half-finished entry in a separate buffer.  *Note Editing Stack Entries::.

If you prefer algebraic entry, you can use the command `m a'
(`calc-algebraic-mode') to set Algebraic mode.  In this mode, digits and
other keys that would normally start numeric entry instead start full
algebraic entry; as long as your formula begins with a digit you can
omit the apostrophe.  Open parentheses and square brackets also begin
algebraic entry.  You can still do RPN calculations in this mode, but
you will have to press RET to terminate every number: `2 RET 3 RET * 4
RET +' would accomplish the same thing as `2*3+4 RET'.

If you give a numeric prefix argument like `C-u' to the `m a'
command, it enables Incomplete Algebraic mode; this is like regular
Algebraic mode except that it applies to the `(' and `[' keys
only.  Numeric keys still begin a numeric entry in this mode.

The `m t' (`calc-total-algebraic-mode') gives you an even
stronger algebraic-entry mode, in which *all* regular letter and
punctuation keys begin algebraic entry.  Use this if you prefer typing
`sqrt( )' instead of `Q', `factor( )' instead of
`a f', and so on.  To type regular Calc commands when you are in
"total" algebraic mode, hold down the META key.  Thus `M-q'
is the command to quit Calc, `M-p' sets the precision, and
`M-m t' (or `M-m M-t', if you prefer) turns total algebraic
mode back off again.  Meta keys also terminate algebraic entry, so
that `2+3 M-S' is equivalent to `2+3 RET M-S'.  The symbol
`Alg*' will appear in the mode line whenever you are in this mode.

Pressing `'' (the apostrophe) a second time re-enters the previous
algebraic formula.  You can then use the normal Emacs editing keys to
modify this formula to your liking before pressing RET.

Within a formula entered from the keyboard, the symbol `$' represents
the number on the top of the stack.  If an entered formula contains any
`$' characters, the Calculator replaces the top of stack with that
formula rather than simply pushing the formula onto the stack.  Thus, `'
1+2 RET' pushes 3 on the stack, and `$*2 RET' replaces it with 6.  Note
that the `$' key always initiates algebraic entry; the `'' is
unnecessary if `$' is the first character in the new formula.

Higher stack elements can be accessed from an entered formula with the
symbols `$$', `$$$', and so on.  The number of stack elements removed
(to be replaced by the entered values) equals the number of dollar signs
in the longest such symbol in the formula.  For example, `$$+$$$' adds
the second and third stack elements, replacing the top three elements
with the answer.  (All information about the top stack element is thus
lost since no single `$' appears in this formula.)

A slightly different way to refer to stack elements is with a dollar
sign followed by a number:  `$1', `$2', and so on are much
like `$', `$$', etc., except that stack entries referred
to numerically are not replaced by the algebraic entry.  That is, while
`$+1' replaces 5 on the stack with 6, `$1+1' leaves the 5
on the stack and pushes an additional 6.

If a sequence of formulas are entered separated by commas, each formula
is pushed onto the stack in turn.  For example, `1,2,3' pushes
those three numbers onto the stack (leaving the 3 at the top), and
`$+1,$-1' replaces a 5 on the stack with 4 followed by 6.  Also,
`$,$$' exchanges the top two elements of the stack, just like the
TAB key.

If you finish your algebraic entry by pressing `LFD' (or `C-j')
instead of RET, Calc disables the default simplifications
(as if by `m O'; *Note Simplification Modes::) while the entry
is being pushed on the stack.  Thus `' 1+2 RET' pushes 3
on the stack, but `' 1+2 LFD' pushes the formula `1+2';
you might then press `=' when it is time to evaluate this formula.


File: calc.info  Node: Quick Calculator, Prev: Algebraic Entry, Up: Introduction, Next: Prefix Arguments

"Quick Calculator" Mode
=======================

There is another way to invoke the Calculator if all you need to do
is make one or two quick calculations.  Type `M-# q' (or
`M-x quick-calc'), then type any formula as an algebraic entry.
The Calculator will compute the result and display it in the echo
area, without ever actually putting up a Calculator window.

You can use the `$' character in a Quick Calculator formula to
refer to the previous Quick Calculator result.  Older results are
not retained; the Quick Calculator has no effect on the full
Calculator's stack or trail.  If you compute a result and then
forget what it was, just run `M-# q' again and enter
`$' as the formula.

If this is the first time you have used the Calculator in this Emacs
session, the `M-# q' command will create the `*Calculator*'
buffer and perform all the usual initializations; it simply will
refrain from putting that buffer up in a new window.  The Quick
Calculator refers to the `*Calculator*' buffer for all mode
settings.  Thus, for example, to set the precision that the Quick
Calculator uses, simply run the full Calculator momentarily and use
the regular `p' command.

If you use `M-# q' from inside the Calculator buffer, the
effect is the same as pressing the apostrophe key (algebraic entry).

The result of a Quick calculation is placed in the Emacs "kill ring"
as well as being displayed.  A subsequent `C-y' command will
yank the result into the editing buffer.  You can also use this
to yank the result into the next `M-# q' input line as a more
explicit alternative to `$' notation, or to yank the result
into the Calculator stack after typing `M-# c'.

If you finish your formula by typing LFD (or `C-j') instead
of RET, the result is inserted immediately into the buffer
rather than going into the kill ring.

Quick Calculator results are actually evaluated as if by the `='
key (which replaces variable names by their stored values, if any).
If the formula you enter is an assignment to a variable using the
`:=' operator, say, `foo := 2 + 3' or `foo := foo + 1',
then the result of the evaluation is stored in that Calc variable.
*Note Store and Recall::.

If the result is an integer and the current display radix is decimal,
the number will also be displayed in hex and octal formats.  If the
integer is in the range from 1 to 126, it will also be displayed as
an ASCII character.

For example, the quoted character `"x"' produces the vector
result `[120]' (because 120 is the ASCII code of the lower-case
`x'; *Note Strings::).  Since this is a vector, not an integer, it
is displayed only according to the current mode settings.  But
running Quick Calc again and entering `120' will produce the
result `120 (16#78, 8#170, x)' which shows the number in its
decimal, hexadecimal, octal, and ASCII forms.

Please note that the Quick Calculator is not any faster at loading
or computing the answer than the full Calculator; the name "quick"
merely refers to the fact that it's much less hassle to use for
small calculations.


File: calc.info  Node: Prefix Arguments, Prev: Quick Calculator, Up: Introduction, Next: Undo

Numeric Prefix Arguments
========================

Many Calculator commands use numeric prefix arguments.  Some, such as `d
s' (`calc-sci-notation'), set a parameter to the value of the prefix
argument or use a default if you don't use a prefix.  Others (like `d f'
(`calc-fix-notation') require an argument and prompt for a number if you
don't give one as a prefix.

As a rule, stack-manipulation commands accept a numeric prefix argument
which is interpreted as an index into the stack.  A positive argument
operates on the top N stack entries; a negative argument operates
on the Nth stack entry in isolation; and a zero argument operates
on the entire stack.

Most commands that perform computations (such as the arithmetic and
scientific functions) accept a numeric prefix argument that allows the
operation to be applied across many stack elements.  For unary operations
(that is, functions of one argument like absolute value or complex
conjugate), a prefix argument applies that function to the top N
stack entries simultaneously.  For binary operations (functions of two
arguments like addition, GCD, and vector concatenation), a positive
prefix argument "reduces" the function across the top N
stack elements (for example, `C-u 5 +' sums the top 5 stack entries;
*Note Reducing and Mapping::), and a negative argument maps the next-to-top
N stack elements with the top stack element as a second argument
(for example, `7 c-u -5 +' adds 7 to the top 5 stack elements).
This feature is not available for operations which use the numeric prefix
argument for some other purpose.

Numeric prefixes are specified the same way as always in Emacs: Press a
sequence of META-digits, or press ESC followed by digits, or press `C-u'
followed by digits.

You can type `~' (`calc-num-prefix') to pop an integer from the top of
the stack and enter it as the numeric prefix for the next command.  For
example, `C-u 16 p' sets the precision to 16 digits; an alternate
(silly) way to do this would be `2 RET 4 ^ ~ p', i.e., compute 2 to the
fourth power and set the precision to that value.

Conversely, if you have typed a numeric prefix argument the `~' key
pushes it onto the stack in the form of an integer.


File: calc.info  Node: Undo, Prev: Prefix Arguments, Up: Introduction, Next: Error Messages

Undoing Mistakes
================

The shift-`U' key (`calc-undo') undoes the most recent operation.
If that operation added or dropped objects from the stack, those objects
are removed or restored.  If it was a `store' operation, you are
queried whether or not to restore the variable to its original value.
The `U' key may be pressed any number of times to undo successively
farther back in time; with a numeric prefix argument it undoes a
specified number of operations.  The undo history is cleared only by the
`q' (`calc-quit') command.  (Recall that `M-# c' is usually
made synonymous with `calc-quit' while inside the Calculator; this
also clears the undo history.)

Currently the mode-setting commands (like `calc-precision') are not
undoable.  You can undo past a point where you changed a mode, but you
will need to reset the mode yourself.

The shift-`D' key (`calc-redo') redoes an operation that was
mistakenly undone.  Pressing `U' with a negative prefix argument is
equivalent to executing `calc-redo'.  You can redo any number of
times, up to the number of recent consecutive undo commands.  Redo
information is cleared whenever you give any command that adds new undo
information, i.e., if you undo, then enter a number on the stack or make
any other change, then it will be too late to redo.

The `M-RET' key (`calc-last-args') is like undo in that
it restores the arguments of the most recent command onto the stack;
however, it does not remove the result of that command.  Given a numeric
prefix argument, this command applies to the `n'th most recent
command which removed items from the stack; it pushes those items back
onto the stack.

The `K' (`calc-keep-args') command provides a related function
to `M-RET'.  *Note Stack and Trail::.

It is also possible to recall previous results or inputs using the trail.
*Note Trail Commands::.

The standard Emacs `C-_' undo key is recognized as a synonym for `U'.


File: calc.info  Node: Error Messages, Prev: Undo, Up: Introduction, Next: Multiple Calculators

Error Messages
==============

Many situations that would produce an error message in other calculators
simply create unsimplified formulas in the Emacs Calculator.  For example,
`1 RET 0 /' pushes the formula `1 / 0'; `0 L' pushes
the formula `ln(0)'.  Floating-point overflow and underflow are also
reasons for this to happen.

When a function call must be left in symbolic form, Calc usually
produces a message explaining why.  Messages that are probably
surprising or indicative of user errors are displayed automatically.
Other messages are simply kept in Calc's memory and are displayed only
if you type `w' (`calc-why').  You can also press `w' if
the same computation results in several messages.  (The first message
will end with `[w=more]' in this case.)

The `d w' (`calc-auto-why') command controls when error messages
are displayed automatically (Calc effectively presses `w' for you
after your computation finishes).  By default, this occurs only for
"important" messages.  The other modes are to report *all* messages
automatically, or to report none automatically (so that you must press
`w' yourself to see the messages).


File: calc.info  Node: Multiple Calculators, Prev: Error Messages, Up: Introduction, Next: Troubleshooting Commands

Multiple Calculators
====================

It is possible to have any number of Calc Mode buffers at once.
Usually this is done by executing `M-x another-calc', which
is similar to `M-# c' except that if a `*Calculator*'
buffer already exists, a new, independent one with a name of the
form `*Calculator*<N>' is created.  You can also use the
command `calc-mode' to put any buffer into Calculator mode, but
this would ordinarily never be done.

The `q' (`calc-quit') command does not destroy a Calculator buffer;
it only closes its window.  Use `M-x kill-buffer' to destroy a
Calculator buffer.

Each Calculator buffer keeps its own stack, undo list, and mode settings
such as precision, angular mode, and display formats.  In Emacs terms,
variables such as `calc-stack' are buffer-local variables.  The
global default values of these variables are used only when a new
Calculator buffer is created.  The `calc-quit' command saves
the stack and mode settings of the buffer being quit as the new defaults.

There is only one trail buffer, `*Calc Trail*', used by all
Calculator buffers.


File: calc.info  Node: Troubleshooting Commands, Prev: Multiple Calculators, Up: Introduction

Troubleshooting Commands
========================

This section describes commands you can use in case a computation
incorrectly fails or gives the wrong answer.

*Note Reporting Bugs::, if you find a problem that appears to be due
to a bug or deficiency in Calc.

* Menu:

* Recursion Depth::
* Caches::
* Debugging Calc::


File: calc.info  Node: Recursion Depth, Prev: Troubleshooting Commands, Up: Troubleshooting Commands, Next: Caches

Recursion Depth
---------------

Calc uses recursion in many of its calculations.  Emacs Lisp keeps a
variable `max-lisp-eval-depth' which limits the amount of recursion
possible in an attempt to recover from program bugs.  If a calculation
ever halts incorrectly with the message "Computation got stuck or ran
too long," use the `M' command (`calc-more-recursion-depth') to increase
this limit.

The limit is always increased (multiplied) by a factor of two.  There
is also an `I M' (`calc-less-recursion-depth') command which
decreases this limit by a factor of two, down to a minimum value of 200.
The default value is 1000.

These commands also double or halve `max-specpdl-size', another
internal Lisp recursion limit.  The minimum value for this limit is 600.


File: calc.info  Node: Caches, Prev: Recursion Depth, Up: Troubleshooting Commands, Next: Debugging Calc

Caches
------

Calc saves certain values after they have been computed once.  For
example, the `P' (`calc-pi') command initially "knows" the
constant `pi' to about 20 decimal places; if the current precision
is greater than this, it will recompute `pi' using a series
approximation.  This value will not need to be recomputed ever again
unless you raise the precision still further.  Many operations such as
logarithms and sines make use of similarly cached values such as
`pi/4' and `ln(2)'.  The visible effect of caching is that
high-precision computations may be especially slow the first time.
Other things cached include powers of two (for the binary arithmetic
functions), matrix inverses and determinants, symbolic integrals, and
data computed by the graphing commands.

If you suspect a Calculator cache has become corrupt, you can use the
`calc-flush-caches' command to reset all caches to the empty state.
(This should only be necessary in event of bugs in the Calculator.)
The `M-# 0' (with the zero key) command also resets caches along
with all other aspects of the Calculator's state.


File: calc.info  Node: Debugging Calc, Prev: Caches, Up: Troubleshooting Commands

Debugging Calc
--------------

A few commands exist to help in the debugging of Calc commands.
*Note Programming::, to see the various ways that you can write
your own Calc commands.

The `Z T' (`calc-timing') command turns on and off a mode
in which the timing of slow commands is reported in the Trail.
Any Calc command that takes two seconds or longer writes a line
to the Trail showing how many seconds it took.  This value is
accurate only to within one second.

All steps of executing a command are included; in particular, time
taken to format the result for display in the stack and trail is
counted.  Some prompts also count time taken waiting for them to
be answered, while others do not; this depends on the exact
implementation of the command.  For best results, if you are timing
a sequence that includes prompts or multiple commands, define a
keyboard macro to run the whole sequence at once.  Calc's `X'
command (*Note Keyboard Macros::) will then report the time taken
to execute the whole macro.

Another advantage of the `X' command is that while it is
executing, the stack and trail are not updated from step to step.
So if you expect the output of your test sequence to leave a result
that may take a long time to format and you don't wish to count
this formatting time, end your sequence with a DEL keystroke
to clear the result from the stack.  When you run the sequence with
`X', Calc will never bother to format the large result.

Another thing `Z T' does is to increase the Emacs variable
`gc-cons-threshold' to a much higher value (two million; the
usual default in Calc is 250,000) for the duration of each command.
This generally prevents garbage collection during the timing of
the command, though it may cause your Emacs process to grow
abnormally large.  (Garbage collection time is a major unpredictable
factor in the timing of Emacs operations.)

Another command that is useful when debugging your own Lisp
extensions to Calc is `M-x calc-pass-errors', which disables
the error handler that changes the "`max-lisp-eval-depth'
exceeded" message to the much more friendly "Computation got
stuck or ran too long."  This handler interferes with the Emacs
Lisp debugger's `debug-on-error' mode.  Errors are reported
in the handler itself rather than at the true location of the
error.  After you have executed `calc-pass-errors', Lisp
errors will be reported correctly but the user-friendly message
will be lost.


File: calc.info  Node: Data Types, Prev: Introduction, Up: Top, Next: Stack and Trail

Data Types
**********

This chapter discusses the various types of objects that can be placed
on the Calculator stack, how they are displayed, and how they are
entered.  (*Note Data Type Formats::, for information on how these data
types are represented as Lisp objects.)

Integers, fractions, and floats are various ways of describing real
numbers.  HMS forms also for many purposes act as real numbers.  These
types can be combined to form complex numbers, modulo forms, error forms,
or interval forms.  (But these last four types cannot be combined with
each other: error forms may not contain modulo forms, for example.)
Finally, all these types of numbers may be combined into vectors,
matrices, or algebraic formulas.

* Menu:

* Integers::                The most basic data type.
* Fractions::               This and above are called "rationals".
* Floats::                  This and above are called "reals".
* Complex Numbers::         This and above are called "numbers".
* Infinities::
* Vectors and Matrices::
* Strings::
* HMS Forms::
* Date Forms::
* Modulo Forms::
* Error Forms::
* Interval Forms::
* Incomplete Objects::
* Variables::
* Formulas::


File: calc.info  Node: Integers, Prev: Data Types, Up: Data Types, Next: Fractions

Integers
========

The Calculator stores integers to arbitrary precision.  Addition,
subtraction, and multiplication of integers always yields an exact
integer result.  (If the result of a division or exponentiation of
integers is not an integer, it is expressed in fractional or
floating-point form according to the current Fraction Mode.
*Note Fraction Mode::.)

A decimal integer is represented as an optional sign followed by a
sequence of digits.  Grouping (*Note Grouping Digits::) can be used to
insert a comma at every third digit for display purposes, but such
commas are not allowed during the entry of numbers.

A non-decimal integer is represented as an optional sign, a radix
between 2 and 36, a `#' symbol, and one or more digits.  For radix 11
and above, the letters A through Z (upper- or lower-case) count as
digits and do not terminate numeric entry mode.  *Note Radix Modes::,
for how to set the default radix for display of integers.  Numbers of
any radix may be entered at any time.  If you press `#' at the beginning
of a number, the current display radix is used.


File: calc.info  Node: Fractions, Prev: Integers, Up: Data Types, Next: Floats

Fractions
=========

A "fraction" is a ratio of two integers.  Fractions are traditionally
written "2/3" but Calc uses the notation `2:3'.  (The `/' key performs
RPN division; the following two sequences push the number `2:3' on the
stack: `2 : 3 RET', `2 RET 3 /', assuming Fraction Mode has been
enabled.)  When the Calculator produces a fractional result it always
reduces it to simplest form, which may in fact be an integer.

Fractions may also be entered in a three-part form, where `2:3:4'
represents two-and-three-quarters.  *Note Fraction Formats::, for
fraction display formats.

Non-decimal fractions are entered and displayed as `RADIX#NUM:DENOM' (or
in the analogous three-part form).  The numerator and denominator always
use the same radix.


File: calc.info  Node: Floats, Prev: Fractions, Up: Data Types, Next: Complex Numbers

Floats
======

A floating-point number or "float" is a number stored in scientific
notation.  The number of significant digits in the fractional part is
governed by the current floating precision (*Note Precision::).  The
range of acceptable values is from `10^-4000000' to `10^4000000',
plus zero and corresponding negative values.

Calculations that would exceed the allowable range of values (such
as `exp(exp(20))') are left in symbolic form by the Calculator.
The messages "floating-point overflow" or "floating-point underflow"
indicate that during the calculation, a number would have been produced
that was too large or too close to zero, respectively, to be represented
by Calc.  This does not necessarily mean the final result would have
overflowed, just that an overflow occurred while computing the result.

If a rational number and a float are mixed in a calculation, the result
will in general be expressed as a float.  Commands that require an integer
value (such as `calc-gcd') will also accept integer-valued floats,
i.e., a floating-point number with nothing after the decimal point.

Floats are identified by the presence of a decimal point and/or an
exponent.  In general a float consists of an optional sign, digits
including an optional decimal point, and an optional exponent consisting
of an `e', an optional sign, and one to seven exponent digits.
For example, `23.5e-2' is 23.5 times ten to the minus-second power,
or 0.235.

Floating-point numbers are normally displayed in decimal notation with
all significant figures shown.  Exceedingly large or small numbers are
displayed in scientific notation.  Various other display options are
available.  *Note Float Formats::.

Floating-point numbers are stored in decimal, not binary.  The result of
each operation is rounded to the nearest value representable in the
number of significant digits specified by the current precision,
rounding away from zero in the case of a tie.  Thus (in the default
display mode) what you see is exactly what you get.  Some operations
such as square roots and transcendental functions are performed with
several digits of extra precision and then rounded down, in an effort to
make the final result accurate to the full requested precision.
However, accuracy is not rigorously guaranteed.  If you suspect the
validity of a result, try doing the same calculation in a higher
precision.  The Calculator's arithmetic is not intended to be
IEEE-conformant in any way.

While floats are always *stored* in decimal, they can be entered
and displayed in any radix just like integers and fractions.  The
notation `RADIX#DDD.DDD' is a floating-point
number whose digits are in the specified radix.  Note that the `.'
is usually referred to as a "radix point" rather than a decimal
point in this case.  The number `8#123.4567' is defined as
`8#1234567 * 8^-4'.  If the radix is 14 or less, you can use
`e' notation to write a non-decimal number in scientific notation.
The exponent is written in decimal, and is considered to be a power
of the radix: `8#1234567e-4'.  If the radix is 15 or above, the
letter `e' is a digit, so scientific notation must be written
out, e.g., `16#123.4567*16^2'.  The first two exercises of the
Modes Tutorial explore some of the properties of non-decimal floats.


File: calc.info  Node: Complex Numbers, Prev: Floats, Up: Data Types, Next: Infinities

Complex Numbers
===============

There are two supported formats for complex numbers: rectangular and
polar.  The default format is rectangular, displayed in the form
`(REAL,IMAG)' where REAL is the real part and IMAG is the imaginary
part, each of which may be any real number.  Rectangular complex numbers
can also be displayed in `A+Bi' notation; *Note Complex Formats::.

Polar complex numbers are displayed in the form `(R;THETA)' where R is
the nonnegative magnitude and THETA is the argument or phase angle.  The
range of THETA depends on the current angular mode (*Note Angular
Modes::); it is generally between -180 and +180 degrees or the
equivalent range in radians.

Complex numbers are entered in stages using incomplete objects.
*Note Incomplete Objects::.

Operations on rectangular complex numbers yield rectangular complex
results, and similarly for polar complex numbers.  Where the two types
are mixed, or where new complex numbers arise (as for the square root of
a negative real), the current "Polar Mode" is used to determine the
type.  *Note Polar Mode::.

A complex result in which the imaginary part is zero (or the phase angle
is 0 or 180 degrees or `pi' radians) is automatically converted to a real
number.


File: calc.info  Node: Infinities, Prev: Complex Numbers, Up: Data Types, Next: Vectors and Matrices

Infinities
==========

The word `inf' represents the mathematical concept of "infinity".
Calc actually has three slightly different infinity-like values:
`inf', `uinf', and `nan'.  These are just regular
variable names (*Note Variables::); you should avoid using these
names for your own variables because Calc gives them special
treatment.  Infinities, like all variable names, are normally
entered using algebraic entry.

Mathematically speaking, it is not rigorously correct to treat
"infinity" as if it were a number, but mathematicians often do
so informally.  When they say that `1 / inf = 0', what they
really mean is that `1 / x', as `x' becomes larger and
larger, becomes arbitrarily close to zero.  So you can imagine
that if `x' got "all the way to infinity," then `1 / x'
would go all the way to zero.  Similarly, when they say that
`exp(inf) = inf', they mean that `exp(x)' grows without
bound as `x' grows.  The symbol `-inf' likewise stands
for an infinitely negative real value; for example, we say that
`exp(-inf) = 0'.  You can have an infinity pointing in any
direction on the complex plane:  `sqrt(-inf) = i inf'.

The same concept of limits can be used to define `1 / 0'.  We
really want the value that `1 / x' approaches as `x'
approaches zero.  But if all we have is `1 / 0', we can't
tell which direction `x' was coming from.  If `x' was
positive and decreasing toward zero, then we should say that
`1 / 0 = inf'.  But if `x' was negative and increasing
toward zero, the answer is `1 / 0 = -inf'.  In fact, `x'
could be an imaginary number, giving the answer `i inf' or
`-i inf'.  Calc uses the special symbol `uinf' to mean
"undirected infinity", i.e., a value which is infinitely
large but with an unknown sign (or direction on the complex plane).

Calc actually has three modes that say how infinities are handled.
Normally, infinities never arise from calculations that didn't
already have them.  Thus, `1 / 0' is treated simply as an
error and left unevaluated.  The `m i' (`calc-infinite-mode')
command (*Note Infinite Mode::) enables a mode in which
`1 / 0' evaluates to `uinf' instead.  There is also
an alternative type of infinite mode which says to treat zeros
as if they were positive, so that `1 / 0 = inf'.  While this
is less mathematically correct, it may be the answer you want in
some cases.

Since all infinities are "as large" as all others, Calc simplifies,
e.g., `5 inf' to `inf'.  Another example is
`5 - inf = -inf', where the `-inf' is so large that
adding a finite number like five to it does not affect it.
Note that `a - inf' also results in `-inf'; Calc assumes
that variables like `a' always stand for finite quantities.
Just to show that infinities really are all the same size,
note that `sqrt(inf) = inf^2 = exp(inf) = inf' in Calc's
notation.

It's not so easy to define some formulas like `0 * inf' and
`inf / inf'.  Depending on where these zeros and infinities
came from, the answer could be literally anything.  The latter
formula could be the limit of `x / x' (giving a result of one),
or `2 x / x' (giving two), or `x^2 / x' (giving `inf'),
or `x / x^2' (giving zero).  Calc uses the symbol `nan'
to represent such an "indeterminate" value.  (The name "nan"
comes from analogy with the "NAN" concept of IEEE standard
arithmetic; it stands for "Not A Number."  This is somewhat of a
misnomer, since `nan' *does* stand for some number or
infinity, it's just that *which* number it stands for
cannot be determined.)  In Calc's notation, `0 * inf = nan'
and `inf / inf = nan'.  A few other common indeterminate
expressions are `inf - inf' and `inf ^ 0'.  Also,
`0 / 0 = nan' if you have turned on "infinite mode"
(as described above).

Infinities are especially useful as parts of "intervals".
*Note Interval Forms::.


File: calc.info  Node: Vectors and Matrices, Prev: Infinities, Up: Data Types, Next: Strings

Vectors and Matrices
====================

The "vector" data type is flexible and general.  A vector is simply a
list of zero or more data objects.  When these objects are numbers, the
whole is a vector in the mathematical sense.  When these objects are
themselves vectors of equal (nonzero) length, the whole is a "matrix".
A vector which is not a matrix is referred to here as a "plain vector".

A vector is displayed as a list of comma-separated values enclosed in
square brackets:  `[1, 2, 3]'.  Thus the following is a 2 row by
3 column matrix:  `[[1, 2, 3], [4, 5, 6]]'.  Vectors, like complex
numbers, are entered as incomplete objects.  *Note Incomplete Objects::.
During algebraic entry, vectors are entered all at once in the usual
brackets-and-commas form.  Matrices may be entered algebraically as nested
vectors, or using the shortcut notation `[1, 2, 3; 4, 5, 6]',
with rows separated by semicolons.  The commas may usually be omitted
when entering vectors:  `[1 2 3]'.  Curly braces may be used in
place of brackets: `{1, 2, 3}', but the commas are required in
this case.

Traditional vector and matrix arithmetic is also supported; *Note Basic
Arithmetic:: and *Note Matrix Functions::.  Many other operations are
applied to vectors element-wise.  For example, the complex conjugate of
a vector is a vector of the complex conjugates of its elements.

Algebraic functions for building vectors include `vec(a, b, c)'
to build `[a, b, c]', `cvec(a, n, m)' to build an NxM
matrix of `a's, and `index(n)' to build a vector of integers
from 1 to `n'.


File: calc.info  Node: Strings, Prev: Vectors and Matrices, Up: Data Types, Next: HMS Forms

Strings
=======

Character strings are not a special data type in the Calculator.
Rather, a string is represented simply as a vector all of whose
elements are integers in the range 0 to 255.  You can enter a string
at any time by pressing the `"' key.  Quotation marks and
backslashes are written `\"' and `\\', respectively,
inside strings.  Other notations introduced by backslashes are:

     \a     7
     \b     8
     \e     27
     \f     12
     \n     10
     \r     13
     \t     9
     \^    0
     \^a-z  1-26
     \^[    27
     \^\\   28
     \^]    29
     \^^    30
     \^_    31
     \^?    127

Finally, a backslash followed by three octal digits produces any
character from its ASCII code.

Strings are normally displayed in vector-of-integers form.  The
`d "' (`calc-display-strings') command toggles a mode in
which any vectors of the appropriate form are displayed as quoted
strings instead.

The backslash notations shown above are also used for displaying
strings.  Characters 128 and above are not translated by Calc; unless
you have an Emacs modified for 8-bit fonts, these will show up in
backslash-octal-digits notation.  But for characters below 32, and
for character 127, Calc uses the backslash-letter combination if
there is one, or otherwise uses a `\^' sequence.

The only Calc feature that uses strings is "compositions";
*Note Compositions::.  Strings also provide a convenient
way to do conversions between ASCII characters and integers.

There is a `string' function which provides a different display
format for strings.  Basically, `string(S)', where S
is a vector of integers in the proper range, is displayed as the
corresponding string of characters with no surrounding quotations
marks or other modifications.  Thus `string("ABC")' (or
`string([65 66 67])') will look like `ABC' on the stack.
This happens regardless of whether `d "' has been used.  The
only way to turn it off is to use `d U' (unformatted language
mode) which will display `string("ABC")' instead.

Control characters are displayed somewhat differently by `string'.
Characters below 32, and character 127, are shown using `^' notation
(same as shown above, but without the backslash).  The quote and
backslash characters are left alone, as are characters 128 and above.

The `bstring' function is just like `string' except that
the resulting string is breakable across multiple lines if it doesn't
fit all on one line.  Potential break points occur at every space
character in the string.


File: calc.info  Node: HMS Forms, Prev: Strings, Up: Data Types, Next: Date Forms

HMS Forms
=========

"HMS" stands for Hours-Minutes-Seconds; when used as an angular
argument, the interpretation is Degrees-Minutes-Seconds.  All functions
that operate on angles accept HMS forms.  These are interpreted as
degrees regardless of the current angular mode.  It is also possible to
use HMS as the angular mode so that calculated angles are expressed in
degrees, minutes, and seconds.

The default format for HMS values is `HOURS@ MINS' SECS"'.  During
entry, the letters `h' (for "hours") or `o' (approximating the "degrees"
symbol) are accepted as well as `@', `m' is accepted in place of `'',
and `s' is accepted in place of `"'.  The HOURS value is an integer (or
integer-valued float).  The MINS value is an integer or integer-valued
float between 0 and 59.  The SECS value is a real number between 0
(inclusive) and 60 (exclusive).  A positive HMS form is interpreted as
HOURS + MINS/60 + SECS/3600.  A negative HMS form is interpreted as -
HOURS - MINS/60 - SECS/3600.  Display format for HMS forms is quite
flexible.  *Note HMS Formats::.

HMS forms can be added and subtracted.  When they are added to numbers,
the numbers are interpreted according to the current angular mode.  HMS
forms can also be multiplied and divided by real numbers.  Dividing
two HMS forms produces a real-valued ratio of the two angles.

Just for kicks, `calc-time' pushes the current time of day on
the stack as an HMS form.


File: calc.info  Node: Date Forms, Prev: HMS Forms, Up: Data Types, Next: Modulo Forms

Date Forms
==========

A "date form" represents a date and possibly an associated time.
Simple date arithmetic is supported:  Adding a number to a date
produces a new date shifted by that many days; adding an HMS form to
a date shifts it by that many hours.  Subtracting two date forms
computes the number of days between them (represented as a simple
number).  Many other operations, such as multiplying two date forms,
are nonsensical and are not allowed by Calc.

Date forms are entered and displayed enclosed in `< >' brackets.
The default format is, e.g., `<Wed Jan 9, 1991>' for dates,
or `<3:32:20pm Wed Jan 9, 1991>' for dates with times.
Input is flexible; date forms can be entered in any of the usual
notations for dates and times.  *Note Date Formats::.

Date forms are stored internally as numbers, specifically the number
of days since midnight on the morning of January 1 of the year 1 AD.
If the internal number is an integer, the form represents a date only;
if the internal number is a fraction or float, the form represents
a date and time.  For example, `<6:00am Wed Jan 9, 1991>'
is represented by the number 726842.25.  The standard precision of
12 decimal digits is enough to ensure that a (reasonable) date and
time can be stored without roundoff error.

If the current precision is greater than 12, date forms will keep
additional digits in the seconds portion.  For example, if the
precision is 15, the seconds will keep three digits after the
decimal point.  Decreasing the precision below 12 may cause the
time part of a date form to become inaccurate.  This can also happen
if astronomically high years are used, though this will not be an
issue in everyday (or even everymillenium) use.  Note that date
forms without times are stored as exact integers, so roundoff is
never an issue for them.

You can use the `calc-pack' and `calc-unpack' commands
to get at the numerical representation of a date form.
*Note Packing and Unpacking::.

Date forms can go arbitrarily far into the future or past.  Negative
year numbers represent years BC.  Calc uses a combination of the
Gregorian and Julian calendars, following the history of Great
Britain and the British colonies.  This is the same calendar that
is used by the `cal' program in most Unix implementations.

Some historical background:  The Julian calendar was created by
Julius Caesar in the year 46 BC as an attempt to fix the gradual
drift caused by the lack of leap years in the calendar used
until that time.  The Julian calendar introduced an extra day in
all years divisible by four.  After some initial confusion, the
calendar was adopted around the year we call 8 AD.  Some centuries
later it became apparent that the Julian year of 365.25 days was
itself not quite right.  In 1582 Pope Gregory XIII introduced the
Gregorian calendar, which added the new rule that years divisible
by 100, but not by 400, were not to be considered leap years
despite being divisible by four.  Many countries delayed adoption
of the Gregorian calendar because of religious differences;
in Britain it was put off until the year 1752, by which time
the Julian calendar had fallen eleven days behind the true
seasons.  So the switch to the Gregorian calendar in early
September 1752 introduced a discontinuity:  The day after
Sep 2, 1752 is Sep 14, 1752.  Calc follows this convention.
To take another example, Russia waited until 1918 before
adopting the new calendar, and thus needed to remove thirteen
days (between Feb 1, 1918 and Feb 14, 1918).  This means that
Calc's reckoning will be inconsistent with Russian history between
1752 and 1918, and similarly for various other countries.

Today's timekeepers introduce an occasional "leap second" as
well, but Calc does not take these minor effects into account.
(If it did, it would have to report a non-integer number of days
between, say, `<12:00am Mon Jan 1, 1900>' and
`<12:00am Sat Jan 1, 2000>'.)

Calc uses the Julian calendar for all dates before the year 1752,
including dates BC when the Julian calendar technically had not
yet been invented.  Thus the claim that day number -10000 is
called "August 16, 28 BC" should be taken with a grain of salt.

Please note that there is no "year 0"; the day before
`<Sat Jan 1, +1>' is `<Fri Dec 31, -1>'.  These are
days 0 and -1 respectively in Calc's internal numbering scheme.

Another day counting system in common use is, confusingly, also
called "Julian."  It was invented in 1583 by Joseph Justus
Scaliger, who named it in honor of his father Julius Caesar
Scaliger.  For obscure reasons he chose to start his day
numbering on Jan 1, 4713 BC at noon, which in Calc's scheme
is -1721423.5 (recall that Calc starts at midnight instead
of noon).  Thus to convert a Calc date code obtained by
unpacking a date form into a Julian day number, simply add
1721423.5.  The Julian code for `6:00am Jan 9, 1991'
is 2448265.75.  The built-in `t J' command performs
this conversion for you.

The Unix operating system measures time as an integer number of
seconds since midnight, Jan 1, 1970.  To convert a Calc date
value into a Unix time stamp, first subtract 719164 (the code
for `<Jan 1, 1970>'), then multiply by 86400 (the number of
seconds in a day) and press `R' to round to the nearest
integer.  If you have a date form, you can simply subtract the
day `<Jan 1, 1970>' instead of unpacking and subtracting
719164.  Likewise, divide by 86400 and add `<Jan 1, 1970>'
to convert from Unix time to a Calc date form.  (Note that
Unix normally maintains the time in the GMT time zone; you may
need to subtract five hours to get New York time, or eight hours
for California time.  The same is usually true of Julian day
counts.)  The built-in `t U' command performs these
conversions.


File: calc.info  Node: Modulo Forms, Prev: Date Forms, Up: Data Types, Next: Error Forms

Modulo Forms
============

A "modulo form" is a real number which is taken modulo (i.e., within an
integer multiple of) some value `M'.  Arithmetic modulo `M' often arises
in number theory.  Modulo forms are written `a mod M', where `a' and `M'
are real numbers or HMS forms, and `0 <= a < M'.  In many applications
`a' and `M' will be integers but this is not required.

Modulo forms are not to be confused with the modulo operator `%'.
The expression `27 % 10' means to compute 27 modulo 10 to produce
the result 7.  Further computations treat this 7 as just a regular integer.
The expression `27 mod 10' produces the result `7 mod 10';
further computations with this value are again reduced modulo 10 so that
the result always lies in the desired range.

When two modulo forms with identical `M''s are added or multiplied,
the Calculator simply adds or multiplies the values, then reduces modulo
`M'.  If one argument is a modulo form and the other a plain number,
the plain number is treated like a compatible modulo form.  It is also
possible to raise modulo forms to powers; the result is the value raised
to the power, then reduced modulo `M'.  (When all values involved
are integers, this calculation is done much more efficiently than
actually computing the power and then reducing.)

Two modulo forms `a mod M' and `b mod M' can be divided if `a', `b', and
`M' are all integers.  The result is the modulo form which, when
multiplied by `b mod M', produces `a mod M'.  If there is no solution to
this equation (which can happen only when `M' is non-prime), or if any
of the arguments are non-integers, the division is left in symbolic
form.  Other operations, such as square roots, are not yet supported for
modulo forms.  (Note that, although `(a mod M)^.5' will compute a
"modulo square root" in the sense of reducing `sqrt(a)' modulo `M', this
is not a useful definition from the number-theoretical point of view.)

To create a modulo form during numeric entry, press the shift-`M' key to
enter the word `mod'.  As a special convenience, pressing shift-`M' a
second time automatically enters the value of `M' that was most recently
used before.  During algebraic entry, either type `mod' by hand or press
`M-m' (that's `META-m').  Once again, pressing this a second time enters
the current modulo.

You can also use `calc-pack' and `%' to modify modulo forms.
*Note Building Vectors::.  *Note Basic Arithmetic::.

It is possible to mix HMS forms and modulo forms.  For example, an
HMS form modulo 24 could be used to manipulate clock times; an HMS
form modulo 360 would be suitable for angles.  Making the modulo `M'
also be an HMS form eliminates troubles that would arise if the angular
mode were inadvertently set to Radians, in which case
`2@ 0' 0" mod 24' would be interpreted as two degrees modulo
24 radians!

Modulo forms cannot have variables or formulas for components.  If you
enter the formula `(x + 2) mod 5', Calc propagates the modulus
to each of the coefficients:  `(1 mod 5) x + (2 mod 5)'.

The algebraic function `makemod(a, m)' builds the modulo form
`a mod m'.


