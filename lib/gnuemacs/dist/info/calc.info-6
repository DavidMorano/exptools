Info file: calc.info,    -*-Text-*-
produced by texinfo-format-buffer
from file: calc.texinfo





This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the author instead of in the
original English.



File: calc.info  Node: Types Answer 5, Prev: Types Answer 4, Up: Answers to Exercises, Next: Types Answer 6

Types Tutorial Exercise 5
-------------------------

Let's suppose it's January 14, 1991.  The easiest thing to do is
to keep trying 13ths of months until Calc reports a Friday.
We can do this by manually entering dates, or by using `t I':

     1:  <Wed Feb 13, 1991>    1:  <Wed Mar 13, 1991>   1:  <Sat Apr 13, 1991>
         .                         .                        .

         ' <2/13> RET       DEL    ' <3/13> RET             t I

(Calc assumes the current year if you don't say otherwise.)

This is getting tedious---we can keep advancing the date by typing
`t I' over and over again, but let's automate the job by using
vector mapping.  The `t I' command actually takes a second
"how-many-months" argument, which defaults to one.  This
argument is exactly what we want to map over:

     2:  <Sat Apr 13, 1991>     1:  [<Mon May 13, 1991>, <Thu Jun 13, 1991>,
     1:  [1, 2, 3, 4, 5, 6]          <Sat Jul 13, 1991>, <Tue Aug 13, 1991>,
         .                           <Fri Sep 13, 1991>, <Sun Oct 13, 1991>]
                                    .

         v x 6 RET                  V M t I

Et voila, September 13, 1991 is a Friday.

     1:  242
         .

     ' <sep 13> - <jan 14> RET

And the answer to our original question:  242 days to go.


File: calc.info  Node: Types Answer 6, Prev: Types Answer 5, Up: Answers to Exercises, Next: Types Answer 7

Types Tutorial Exercise 6
-------------------------

The full rule for leap years is that they occur in every year divisible
by four, except that they don't occur in years divisible by 100, except
that they *do* in years divisible by 400.  We could work out the
answer by carefully counting the years divisible by four and the
exceptions, but there is a much simpler way that works even if we
don't know the leap year rule.

Let's assume the present year is 1991.  Years have 365 days, except
that leap years (whenever they occur) have 366 days.  So let's count
the number of days between now and then, and compare that to the
number of years times 365.  The number of extra days we find must be
equal to the number of leap years there were.

     1:  <Mon Jan 1, 10001>     2:  <Mon Jan 1, 10001>     1:  2925593
         .                      1:  <Tue Jan 1, 1991>          .
                                    .

       ' <jan 1 10001> RET         ' <jan 1 1991> RET          -

     3:  2925593       2:  2925593     2:  2925593     1:  1943
     2:  10001         1:  8010        1:  2923650         .
     1:  1991              .               .
         .

       10001 RET 1991      -               365 *           -

There will be 1943 leap years before the year 10001.  (Assuming,
of course, that the algorithm for computing leap years remains
unchanged for that long.  *Note Date Forms::, for some interesting
background information in that regard.)


File: calc.info  Node: Types Answer 7, Prev: Types Answer 6, Up: Answers to Exercises, Next: Types Answer 8

Types Tutorial Exercise 7
-------------------------

The relative errors must be converted to absolute errors so that
`+/-' notation may be used.

     1:  1.              2:  1.
         .               1:  0.2
                             .

         20 RET .05 *        4 RET .05 *

Now we simply chug through the formula.

     1:  19.7392088022    1:  394.78 +/- 19.739    1:  6316.5 +/- 706.21
         .                    .                        .

         2 P 2 ^ *            20 p 1 *                 4 p .2 RET 2 ^ *

It turns out the `v u' command will unpack an error form as
well as a vector.  This saves us some retyping of numbers.

     3:  6316.5 +/- 706.21     2:  6316.5+/- 706.21
     2:  6316.5                1:  0.1118
     1:  706.21                    .
         .

         RET v u                   TAB /

Thus the volume is 6316 cubic centimeters, within about 11 percent.


File: calc.info  Node: Types Answer 8, Prev: Types Answer 7, Up: Answers to Exercises, Next: Types Answer 9

Types Tutorial Exercise 8
-------------------------

The first answer is pretty simple:  `1 / (0 .. 10) = (0.1 .. inf)'.
Since a number in the interval `(0 .. 10)' can get arbitrarily
close to zero, its reciprocal can get arbitrarily large, so the answer
is an interval that effectively means, "any number greater than 0.1"
but with no upper bound.

The second answer, similarly, is `1 / (-10 .. 0) = (-inf .. -0.1)'.

Calc normally treats division by zero as an error, so that the formula
`1 / 0' is left unsimplified.  Our third problem,
`1 / [0 .. 10]', also (potentially) divides by zero because zero
is now a member of the interval.  So Calc leaves this one unevaluated, too.

If you turn on "infinite" mode by pressing `m i', you will
instead get the answer `[0.1 .. inf]', which includes infinity
as a possible value.

The fourth calculation, `1 / (-10 .. 10)', has the same problem.
Zero is buried inside the interval, but it's still a possible value.
It's not hard to see that the actual result of `1 / (-10 .. 10)'
will be either greater than 0.1, or less than -0.1.  Thus
the interval goes from minus infinity to plus infinity, with a "hole"
in it from -0.1 to 0.1.  Calc doesn't have any way to
represent this, so it just reports `[-inf .. inf]' as the answer.
It may be disappointing to hear "the answer lies somewhere between
minus infinity and plus infinity, inclusive," but that's the best
that interval arithmetic can do in this case.


File: calc.info  Node: Types Answer 9, Prev: Types Answer 8, Up: Answers to Exercises, Next: Types Answer 10

Types Tutorial Exercise 9
-------------------------

     1:  [-3 .. 3]       2:  [-3 .. 3]     2:  [0 .. 9]
         .               1:  [0 .. 9]      1:  [-9 .. 9]
                             .                 .

         [ 3 n .. 3 ]        RET 2 ^           TAB RET *

In the first case the result says, "if a number is between -3 and
3, its square is between 0 and 9."  The second case says, "the product
of two numbers each between -3 and 3 is between -9 and 9."

An interval form is not a number; it is a symbol that can stand for
many different numbers.  Two identical-looking interval forms can stand
for different numbers.

The same issue arises when you try to square an error form.


File: calc.info  Node: Types Answer 10, Prev: Types Answer 9, Up: Answers to Exercises, Next: Types Answer 11

Types Tutorial Exercise 10
--------------------------

Testing the first number, we might arbitrarily choose 17 for `x'.

     1:  17 mod 811749613   2:  17 mod 811749613   1:  533694123 mod 811749613
         .                      811749612              .
                                .

         17 M 811749613 RET     811749612              ^

Since 533694123 is (considerably) different from 1, the number 811749613
must not be prime.

It's awkward to type the number in twice as we did above.  There are
various ways to avoid this, and algebraic entry is one.  In fact, using
a vector mapping operation we can perform several tests at once.  Let's
use this method to test the second number.

     2:  [17, 42, 100000]               1:  [1 mod 15485863, 1 mod ... ]
     1:  15485863                           .
         .

      [17 42 100000] 15485863 RET           V M ' ($$ mod $)^($-1) RET

The result is three ones (modulo `n'), so it's very probable that
15485863 is prime.  (In fact, this number is the millionth prime.)

Note that the functions `($$^($-1)) mod $' or `$$^($-1) % $'
would have been hopelessly inefficient, since they would have calculated
the power using full integer arithmetic.

Calc has a `k p' command that does primality testing.  For small
numbers it does an exact test; for large numbers it uses a variant
of the Fermat test we used here.  You can use `k p' repeatedly
to prove that a large integer is prime with any desired probability.


File: calc.info  Node: Types Answer 11, Prev: Types Answer 10, Up: Answers to Exercises, Next: Types Answer 12

Types Tutorial Exercise 11
--------------------------

There are several ways to insert a calculated number into an HMS form.
One way to convert a number of seconds to an HMS form is simply to
multiply the number by an HMS form representing one second:

     1:  31415926.5359     2:  31415926.5359     1:  8726@ 38' 46.5359"
         .                 1:  0@ 0' 1"              .
                               .

         P 1e7 *               0@ 0' 1"              *

     2:  8726@ 38' 46.5359"             1:  6@ 6' 2.5359" mod 24@ 0' 0"
     1:  15@ 27' 16" mod 24@ 0' 0"          .
         .

         x time RET                         +

It will be just after six in the morning.

The algebraic `hms' function can also be used to build an
HMS form:

     1:  hms(0, 0, 10000000. pi)       1:  8726@ 38' 46.5359"
         .                                 .

       ' hms(0, 0, 1e7 pi) RET             =

The `=' key is necessary to evaluate the symbol `pi' to
the actual number 3.14159...


File: calc.info  Node: Types Answer 12, Prev: Types Answer 11, Up: Answers to Exercises, Next: Types Answer 13

Types Tutorial Exercise 12
--------------------------

As we recall, there are 17 songs of about 2 minutes and 47 seconds
each.

     2:  0@ 2' 47"                    1:  [0@ 3' 7" .. 0@ 3' 47"]
     1:  [0@ 0' 20" .. 0@ 1' 0"]          .
         .

         [ 0@ 20" .. 0@ 1' ]              +

     1:  [0@ 52' 59." .. 1@ 4' 19."]
         .

         17 *

No matter how long it is, the album will fit nicely on one CD.


File: calc.info  Node: Types Answer 13, Prev: Types Answer 12, Up: Answers to Exercises, Next: Types Answer 14

Types Tutorial Exercise 13
--------------------------

Type `' 1 yr RET u c s RET'.  The answer is 31557600 seconds.


File: calc.info  Node: Types Answer 14, Prev: Types Answer 13, Up: Answers to Exercises, Next: Types Answer 15

Types Tutorial Exercise 14
--------------------------

How long will it take for a signal to get from one end of the computer
to the other?

     1:  m / c         1:  3.3356 ns
         .                 .

      ' 1 m / c RET        u c ns RET

(Recall, `c' is a "unit" corresponding to the speed of light.)

     1:  3.3356 ns     1:  0.81356 ns / ns     1:  0.81356
     2:  4.1 ns            .                       .
         .

       ' 4.1 ns RET        /                       u s

Thus a signal could take up to 81 percent of a clock cycle just to
go from one place to another inside the computer, assuming the signal
could actually attain the full speed of light.  Pretty tight!


File: calc.info  Node: Types Answer 15, Prev: Types Answer 14, Up: Answers to Exercises, Next: Algebra Answer 1

Types Tutorial Exercise 15
--------------------------

The speed limit is 55 miles per hour on most highways.  We want to
find the ratio of Sam's speed to the US speed limit.

     1:  55 mph         2:  55 mph           3:  11 hr mph / yd
         .              1:  5 yd / hr            .
                            .

       ' 55 mph RET       ' 5 yd/hr RET          /

The `u s' command doesn't figure out how to simplify this,
but `u b' (convert to base units) does.  Now we take the
logarithm base two to find the final answer, assuming that each
successive pill doubles his speed.

     1:  19360.       2:  19360.       1:  14.24
         .            1:  2                .
                          .

         u b              2                B

Thus Sam can take up to 14 pills without a worry.


File: calc.info  Node: Algebra Answer 1, Prev: Types Answer 15, Up: Answers to Exercises, Next: Algebra Answer 2

Algebra Tutorial Exercise 1
---------------------------

The result `sqrt(x)^2' is simplified back to `x' by the
Calculator, but `sqrt(x^2)' is not.  (Consider what happens
if `x = -4'.)  If `x' is real, this formula could be
simplified to `abs(x)', but for general complex arguments even
that is not safe.  (*Note Declarations::, for a way to tell Calc
that `x' is known to be real.)


File: calc.info  Node: Algebra Answer 2, Prev: Algebra Answer 1, Up: Answers to Exercises, Next: Algebra Answer 3

Algebra Tutorial Exercise 2
---------------------------

It is easiest to use `a P x RET' to get a list of solutions.

     1:  17 x^2 - 6 x^4 + 3 = 0   2:  17 x^2 - 6 x^4 + 3 = 0
     2:  17 x^2 - 6 x^4 + 3 = 0   1:  [(0, 0.408), (0, -0.408), 1.732, -1.732]
         .                            .

         RET                          a P x RET

Now we can substitute these into the original formula.

     4:  17 x^2 - 6 x^4 + 3 = 0
     3:  [(0., 0.408), (0., -0.408), 1.732, -1.732]
     2:  [(0., 0.408), (0., -0.408), 1.732, -1.732]
     1:  17 x^2 - 6 x^4 + 3
         .

         M-2 RET TAB   v u DEL

The `v u' command unpacks `a = 0' to `a' and 0; we then
delete the 0.

     3:  17 x^2 - 6 x^4 + 3 = 0
     2:  [(0., 0.408), (0., -0.408), 1.732, -1.732]
     1:  [1e-11, 1e-11, -1e-10, -1e-10]
         .

         V M $ RET

These numbers are reasonable approximations to zero, considering
the precision to which we computed the solutions.


File: calc.info  Node: Algebra Answer 3, Prev: Algebra Answer 2, Up: Answers to Exercises, Next: Algebra Answer 4

Algebra Tutorial Exercise 3
---------------------------

     1:  x sin(pi x)         1:  (sin(pi x) - pi x cos(pi x)) / pi^2
         .                       .

       ' x sin(pi x) RET   m r   a i x RET

     1:  [y, 1]
     2:  (sin(pi x) - pi x cos(pi x)) / pi^2
         .

       ' [y,1] RET TAB

     1:  [(sin(pi y) - pi y cos(pi y)) / pi^2, (sin(pi) - pi cos(pi)) / pi^2]
         .

         V M $ RET

     1:  (sin(pi y) - pi y cos(pi y)) / pi^2 + (pi cos(pi) + sin(pi)) / pi^2
         .

         V R -

     1:  (sin(3.14159 y) - 3.14159 y cos(3.14159 y)) / 9.8696 - 0.3183
         .

         =

     1:  [0., -0.95493, 0.63662, -1.5915, 1.2732]
         .

         v x 5 RET  TAB  V M $ RET


File: calc.info  Node: Algebra Answer 4, Prev: Algebra Answer 3, Up: Answers to Exercises, Next: Rewrites Answer 1

Algebra Tutorial Exercise 4
---------------------------

The hard part is that `V R +' is no longer sufficient to add up all
the contributions from the slices, since the slices have varying
coefficients.  So first we must come up with a vector of these
coefficients.  Here's one way:

     2:  -1                 2:  3                    1:  [4, 2, ..., 4]
     1:  [1, 2, ..., 9]     1:  [-1, 1, ..., -1]         .
         .                      .

         1 n v x 9 RET          V M ^  3 TAB             -

     1:  [4, 2, ..., 4, 1]      1:  [1, 4, 2, ..., 4, 1]
         .                          .

         1 |                        1 TAB |

Now we compute the function values.  Note that for this method we need
eleven values, including both endpoints of the desired interval.

     2:  [1, 4, 2, ..., 4, 1]
     1:  [1, 1.1, 1.2,  ...  , 1.8, 1.9, 2.]
         .

      11 RET 1 RET .1 RET  C-u v x

     2:  [1, 4, 2, ..., 4, 1]
     1:  [0., 0.084941, 0.16993, ... ]
         .

         ' sin(x) ln(x) RET   m r  p 5 RET   V M $ RET

Once again this calls for `V M * V R +'; a simple `*' does the
same thing.

     1:  11.22      1:  1.122      1:  0.374
         .              .              .

         *              .1 *           3 /

Wow!  That's even better than the result from the Taylor series method.


File: calc.info  Node: Rewrites Answer 1, Prev: Algebra Answer 4, Up: Answers to Exercises, Next: Rewrites Answer 2

Rewrites Tutorial Exercise 1
----------------------------

We'll use Big mode to make the formulas more readable.

                                                    ___
                                               2 + V 2
     1:  (2 + sqrt(2)) / (1 + sqrt(2))     1:  --------
         .                                          ___
                                               1 + V 2

                                               .

       ' (2+sqrt(2)) / (1+sqrt(2)) RET         d B

Multiplying by the conjugate helps because `(a+b) (a-b) = a^2 - b^2'.

               ___    ___
     1:  (2 + V 2 ) (V 2  - 1)
         .

       a r a/(b+c) := a*(b-c) / (b^2-c^2) RET

              ___                         ___
     1:  2 + V 2  - 2                1:  V 2
         .                               .

       a r a*(b+c) := a*b + a*c          a s

(We could have used `a x' instead of a rewrite rule for the
second step.)

The multiply-by-conjugate rule turns out to be useful in many
different circumstances, such as when the denominator involves
sines and cosines or the imaginary constant `i'.


File: calc.info  Node: Rewrites Answer 2, Prev: Rewrites Answer 1, Up: Answers to Exercises, Next: Rewrites Answer 3

Rewrites Tutorial Exercise 2
----------------------------

Here is the rule set:

     [ fib(n) := fib(n, 1, 1) :: integer(n) :: n >= 1,
       fib(1, x, y) := x,
       fib(n, x, y) := fib(n-1, y, x+y) ]

The first rule turns a one-argument `fib' that people like to write
into a three-argument `fib' that makes computation easier.  The
second rule converts back from three-argument form once the computation
is done.  The third rule does the computation itself.  It basically
says that if `x' and `y' are two consecutive Fibonacci numbers,
then `y' and `x+y' are the next (overlapping) pair of Fibonacci
numbers.

Notice that because the number `n' was "validated" by the
conditions on the first rule, there is no need to put conditions on
the other rules because the rule set would never get that far unless
the input were valid.  That further speeds computation, since no
extra conditions need to be checked at every step.

Actually, a user with a nasty sense of humor could enter a bad
three-argument `fib' call directly, say, `fib(0, 1, 1)',
which would get the rules into an infinite loop.  One thing that would
help keep this from happening by accident would be to use something like
`ZzFib' instead of `fib' as the name of the three-argument
function.


File: calc.info  Node: Rewrites Answer 3, Prev: Rewrites Answer 2, Up: Answers to Exercises, Next: Rewrites Answer 4

Rewrites Tutorial Exercise 3
----------------------------

He got an infinite loop.  First, Calc did as expected and rewrote
`2 + 3 x' to `f(2, 3, x)'.  Then it looked for ways to
apply the rule again, and found that `f(2, 3, x)' looks like
`a + b x' with `a = 0' and `b = 1', so it rewrote to
`f(0, 1, f(2, 3, x))'.  It then wrapped another `f(0, 1, ...)'
around that, and so on, ad infinitum.  Joe should have used `M-1 a r'
to make sure the rule applied only once.

(Actually, even the first step didn't work as he expected.  What Calc
really gives for `M-1 a r' in this situation is `f(3 x, 1, 2)',
treating 2 as the "variable," and `3 x' as a constant being added
to it.  While this may seem odd, it's just as valid a solution as the
"obvious" one.  One way to fix this would be to add the condition
`:: variable(x)' to the rule, to make sure the thing that matches
`x' is indeed a variable, or to change `x' to `quote(x)'
on the lefthand side, so that the rule matches the actual variable
`x' rather than letting `x' stand for something else.)


File: calc.info  Node: Rewrites Answer 4, Prev: Rewrites Answer 3, Up: Answers to Exercises, Next: Rewrites Answer 5

Rewrites Tutorial Exercise 4
----------------------------

Here is a suitable set of rules to solve the first part of the problem:

     [ seq(n, c) := seq(n/2,  c+1) :: n%2 = 0,
       seq(n, c) := seq(3n+1, c+1) :: n%2 = 1 :: n > 1 ]

Given the initial formula `seq(6, 0)', application of these
rules produces the following sequence of formulas:

     seq( 3, 1)
     seq(10, 2)
     seq( 5, 3)
     seq(16, 4)
     seq( 8, 5)
     seq( 4, 6)
     seq( 2, 7)
     seq( 1, 8)

whereupon neither of the rules match, and rewriting stops.

We can pretty this up a bit with a couple more rules:

     [ seq(n) := seq(n, 0),
       seq(1, c) := c,
       ... ]

Now, given `seq(6)' as the starting configuration, we get 8
as the result.

The change to return a vector is quite simple:

     [ seq(n) := seq(n, []) :: integer(n) :: n > 0,
       seq(1, v) := v | 1,
       seq(n, v) := seq(n/2,  v | n) :: n%2 = 0,
       seq(n, v) := seq(3n+1, v | n) :: n%2 = 1 ]

Given `seq(6)', the result is `[6, 3, 10, 5, 16, 8, 4, 2, 1]'.

Notice that the `n > 1' guard is no longer necessary on the last
rule since the `n = 1' case is now detected by another rule.
But a guard has been added to the initial rule to make sure the
initial value is suitable before the computation begins.

While still a good idea, this guard is not as vitally important as it
was for the `fib' function, since calling, say, `seq(x, [])'
will not get into an infinite loop.  Calc will not be able to prove
the symbol `x' is either even or odd, so none of the rules will
apply and the rewrites will stop right away.


File: calc.info  Node: Rewrites Answer 5, Prev: Rewrites Answer 4, Up: Answers to Exercises, Next: Rewrites Answer 6

Rewrites Tutorial Exercise 5
----------------------------

If `x' is the sum `a + b', then `nterms(x)' must
be `nterms(a)' plus `nterms(b)'.  If `x'
is not a sum, then `nterms(x)' = 1.

     [ nterms(a + b) := nterms(a) + nterms(b),
       nterms(x)     := 1 ]

Here we have taken advantage of the fact that earlier rules always
match before later rules; `nterms(x)' will only be tried if we
already know that `x' is not a sum.


File: calc.info  Node: Rewrites Answer 6, Prev: Rewrites Answer 5, Up: Answers to Exercises, Next: Programming Answer 1

Rewrites Tutorial Exercise 6
----------------------------

Here is a rule set that will do the job:

     [ a*(b + c) := a*b + a*c,
       opt(a) O(x^n) + opt(b) O(x^m) := O(x^n) :: n <= m
          :: constant(a) :: constant(b),
       opt(a) O(x^n) + opt(b) x^m := O(x^n) :: n <= m
          :: constant(a) :: constant(b),
       a O(x^n) := O(x^n) :: constant(a),
       x^opt(m) O(x^n) := O(x^(n+m)),
       O(x^n) O(x^m) := O(x^(n+m)) ]

If we really want the `+' and `*' keys to operate naturally
on power series, we should put these rules in `EvalRules'.  For
testing purposes, it is better to put them in a different variable,
say, `O', first.

The first rule just expands products of sums so that the rest of the
rules can assume they have an expanded-out polynomial to work with.
Note that this rule does not mention `O' at all, so it will
apply to any product-of-sum it encounters---this rule may surprise
you if you put it into `EvalRules'!

In the second rule, the sum of two O's is changed to the smaller O.
The optional constant coefficients are there mostly so that
`O(x^2) - O(x^3)' and `O(x^3) - O(x^2)' are handled
as well as `O(x^2) + O(x^3)'.

The third rule absorbs higher powers of `x' into O's.

The fourth rule says that a constant times a negligible quantity
is still negligible.  (This rule will also match `O(x^3) / 4',
with `a = 1/4'.)

The fifth rule rewrites, for example, `x^2 O(x^3)' to `O(x^5)'.
(It is easy to see that if one of these forms is negligible, the other
is, too.)  Notice the `x^opt(m)' to pick up terms like
`x O(x^3)'.  Optional powers will match `x' as `x^1'
but not 1 as `x^0'.  This turns out to be exactly what we want here.

The sixth rule is the corresponding rule for products of two O's.

Another way to solve this problem would be to create a new "data type"
that represents truncated power series.  We might represent these as
function calls `series(COEFS, X)' where COEFS is
a vector of coefficients for `x^0', `x^1', `x^2', and so
on.  Rules would exist for sums and products of such `series'
objects, and as an optional convenience could also know how to combine a
`series' object with a normal polynomial.  (With this, and with a
rule that rewrites `O(x^n)' to the equivalent `series' form,
you could still enter power series in exactly the same notation as
before.)  Operations on such objects would probably be more efficient,
although the objects would be a bit harder to read.

Some other symbolic math programs provide a power series data type
similar to this.  Mathematica, for example, has an object that looks
like `PowerSeries[X, X0, COEFS, NMIN,
NMAX, DEN]', where X0 is the point about which the
power series is taken (we've been assuming this was always zero),
and NMIN, NMAX, and DEN allow pseudo-power-series
with fractional or negative powers.  Also, the `PowerSeries'
objects have a special display format that makes them look like
`2 x^2 + O(x^4)' when they are printed out.  (*Note Compositions::,
for a way to do this in Calc, although for something as involved as
this it would probably be better to write the formatting routine
in Lisp.)


File: calc.info  Node: Programming Answer 1, Prev: Rewrites Answer 6, Up: Answers to Exercises, Next: Programming Answer 2

Programming Tutorial Exercise 1
-------------------------------

Just enter the formula `ninteg(cos(pi t^2/2), t, 0, x)', type
`Z F', and answer the questions.  Since this formula contains two
variables, the default argument list will be `(t x)'.  We want to
change this to `(x)' since `t' is really a dummy variable
to be used within `ninteg'.

The exact keystrokes are `Z F c fresC RET RET C-b C-b DEL DEL RET y'.
(The `C-b C-b DEL DEL' are what fix the argument list.)

While this definition works, you'll find the `erf'-based definition
described afterwards to be much more efficient; `erf' is also defined
by an integral (involving `exp(-t^2)'), but Calc has good algorithms
for computing it that don't rely on brute-force numerical integration.
The `Z F' formula would be `re((i+1) erf(sqrt(pi) (1-i) x / 2) / 2)',
where `re' is the function that extracts the real part of a complex
number.  Actually, you'd want to type `=' on this formula first to
evaluate the `pi' and `i' variables in it; otherwise your
`z c' function will return a formula that needs to have `='
typed on it each time.


File: calc.info  Node: Programming Answer 2, Prev: Programming Answer 1, Up: Answers to Exercises, Next: Programming Answer 3

Programming Tutorial Exercise 2
-------------------------------

One way is to move the number to the top of the stack, operate on
it, then move it back:  `C-x ( M-TAB n M-TAB M-TAB C-x )'.

Another way is to negate the top three stack entries, then negate
again the top two stack entries:  `C-x ( M-3 n M-2 n C-x )'.

Finally, it turns out that a negative prefix argument causes a
command like `n' to operate on just the specified stack entry,
which is just what we want:  `C-x ( M-- 3 n C-x )'.

Just for kicks, let's also do it algebraically:
`C-x ( ' -$$$, $$, $ RET C-x )'.


File: calc.info  Node: Programming Answer 3, Prev: Programming Answer 2, Up: Answers to Exercises, Next: Programming Answer 4

Programming Tutorial Exercise 3
-------------------------------

Each of these functions can be computed using the stack, or using
algebraic entry, whichever way you prefer:

Computing `sin(x) / x':

Using the stack:  `C-x (  RET S TAB /  C-x )'.

Using algebraic entry:  `C-x (  ' sin($)/$ RET  C-x )'.

Computing the logarithm:

Using the stack:  `C-x (  TAB B  C-x )'

Using algebraic entry:  `C-x (  ' log($,$$) RET  C-x )'.

Computing the vector of integers:

Using the stack:  `C-x (  1 RET 1  C-u v x  C-x )'.  (Recall that
`C-u v x' takes the vector size, starting value, and increment
from the stack.)

Alternatively:  `C-x (  ~ v x  C-x )'.  (The `~' key pops a
number from the stack and uses it as the prefix argument for the
next command.)

Using algebraic entry:  `C-x (  ' index($) RET  C-x )'.


File: calc.info  Node: Programming Answer 4, Prev: Programming Answer 3, Up: Answers to Exercises, Next: Programming Answer 5

Programming Tutorial Exercise 4
-------------------------------

Here's one way:  `C-x ( RET V R + TAB v l / C-x )'.


File: calc.info  Node: Programming Answer 5, Prev: Programming Answer 4, Up: Answers to Exercises, Next: Programming Answer 6

Programming Tutorial Exercise 5
-------------------------------

     2:  1              1:  1.61803398502         2:  1.61803398502
     1:  20                 .                     1:  1.61803398875
         .                                            .

        1 RET 20         Z < & 1 + Z >                I H P

This answer is quite accurate.


File: calc.info  Node: Programming Answer 6, Prev: Programming Answer 5, Up: Answers to Exercises, Next: Programming Answer 7

Programming Tutorial Exercise 6
-------------------------------

Here is the matrix:

     [ [ 0, 1 ]   * [a, b] = [b, a + b]
       [ 1, 1 ] ]

Thus `[0, 1; 1, 1]^n * [1, 1]' computes Fibonacci numbers `n+1'
and `n+2'.  Here's one program that does the job:

     C-x ( ' [0, 1; 1, 1] ^ ($-1) * [1, 1] RET v u DEL C-x )

This program is quite efficient because Calc knows how to raise a
matrix (or other value) to the power `n' in only `log(n,2)'
steps.  For example, this program can compute the 1000th Fibonacci
number (a 209-digit integer!) in about 10 steps; even though the
`Z < ... Z >' solution had much simpler steps, it would have
required so many steps that it would not have been practical.


File: calc.info  Node: Programming Answer 7, Prev: Programming Answer 6, Up: Answers to Exercises, Next: Programming Answer 8

Programming Tutorial Exercise 7
-------------------------------

The trick here is to compute the harmonic numbers differently, so that
the loop counter itself accumulates the sum of reciprocals.  We use
a separate variable to hold the integer counter.

     1:  1          2:  1       1:  .
         .          1:  4
                        .

         1 t 1       1 RET 4      Z ( t 2 r 1 1 + s 1 & Z )

The body of the loop goes as follows:  First save the harmonic sum
so far in variable 2.  Then delete it from the stack; the for loop
itself will take care of remembering it for us.  Next, recall the
count from variable 1, add one to it, and feed its reciprocal to
the for loop to use as the step value.  The for loop will increase
the "loop counter" by that amount and keep going until the
loop counter exceeds 4.

     2:  31                  3:  31
     1:  3.99498713092       2:  3.99498713092
         .                   1:  4.02724519544
                                 .

         r 1 r 2                 RET 31 & +

Thus we find that the 30th harmonic number is 3.99, and the 31st
harmonic number is 4.02.


File: calc.info  Node: Programming Answer 8, Prev: Programming Answer 7, Up: Answers to Exercises, Next: Programming Answer 9

Programming Tutorial Exercise 8
-------------------------------

The first step is to compute the derivative `f'(x)' and thus
the formula `x - f(x)/f'(x)'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.  While you are
entering a `Z ` Z '' body in a macro, Calc simply collects
keystrokes without executing them.  In the following diagrams we'll
pretend Calc actually executed the keystrokes as you typed them,
just for purposes of illustration.)

     2:  sin(cos(x)) - 0.5            3:  4.5
     1:  4.5                          2:  sin(cos(x)) - 0.5
         .                            1:  -(sin(x) cos(cos(x)))
                                          .

     ' sin(cos(x))-0.5 RET 4.5  m r  C-x ( Z `  TAB RET a d x RET

     2:  4.5
     1:  x + (sin(cos(x)) - 0.5) / sin(x) cos(cos(x))
         .

         /  ' x RET TAB -   t 1

Now, we enter the loop.  We'll use a repeat loop with a 20-repetition
limit just in case the method fails to converge for some reason.
(Normally, the `Z /' command will stop the loop before all 20
repetitions are done.)

     1:  4.5         3:  4.5                     2:  4.5
         .           2:  x + (sin(cos(x)) ...    1:  5.24196456928
                     1:  4.5                         .
                         .

       20 Z <          RET r 1 TAB                 s l x RET

This is the new guess for `x'.  Now we compare it with the
old one to see if we've converged.

     3:  5.24196     2:  5.24196     1:  5.24196     1:  5.26345856348
     2:  5.24196     1:  0               .               .
     1:  4.5             .
         .

       RET M-TAB         a =             Z /             Z > Z ' C-x )

The loop converges in just a few steps to this value.  To check
the result, we can simply substitute it back into the equation.

     2:  5.26345856348
     1:  0.499999999997
         .

      RET ' sin(cos($)) RET

Let's test the new definition again:

     2:  x^2 - 9           1:  3.
     1:  1                     .
         .

       ' x^2-9 RET 1           X

Once again, here's the full Newton's Method definition:

     C-x ( Z `  TAB RET a d x RET  /  ' x RET TAB -  t 1
                20 Z <  RET r 1 TAB  s l x RET
                        RET M-TAB  a =  Z /
                   Z >
           Z '
     C-x )

It turns out that Calc has a built-in command for applying a formula
repeatedly until it converges to a number.  *Note Nesting and Fixed Points::,
to see how to use it.

Also, of course, `a R' is a built-in command that uses Newton's
method (among others) to look for numerical solutions to any equation.
*Note Root Finding::.


File: calc.info  Node: Programming Answer 9, Prev: Programming Answer 8, Up: Answers to Exercises, Next: Programming Answer 10

Programming Tutorial Exercise 9
-------------------------------

The first step is to adjust `z' to be greater than 5.  A simple
"for" loop will do the job here.  If `z' is less than 5, we
reduce the problem using `psi(z) = psi(z+1) - 1/z'.  We go
on to compute `psi(z+1)', and remember to add back a factor of
`-1/z' when we're done.  This step is repeated until `z > 5'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.  While you are
entering a `Z ` Z '' body in a macro, Calc simply collects
keystrokes without executing them.  In the following diagrams we'll
pretend Calc actually executed the keystrokes as you typed them,
just for purposes of illustration.)

     1:  1.             1:  1.
         .                  .

      1.0 RET       C-x ( Z `  s 1  0 t 2

Here, variable 1 holds `z' and variable 2 holds the adjustment
factor.  If `z < 5', we use a loop to increase it.

(By the way, we started with `1.0' instead of the integer 1 because
otherwise the calculation below will try to do exact fractional arithmetic,
and will never converge because fractions compare equal only if they
are exactly equal, not just the same to within the current precision.)

     3:  1.      2:  1.       1:  6.
     2:  1.      1:  1            .
     1:  5           .
         .

       RET 5        a <    Z [  5 Z (  & s + 2  1 s + 1  1 Z ) r 1  Z ]

Now we compute the initial part of the sum:  `ln(z) - 1/2z'
minus the adjustment factor.

     2:  1.79175946923      2:  1.7084261359      1:  -0.57490719743
     1:  0.0833333333333    1:  2.28333333333         .
         .                      .

         L  r 1 2 * &           -  r 2                -

Now we evaluate the series.  We'll use another "for" loop counting
up the value of `2 n'.  (Calc does have a summation command,
`a +', but we'll use loops just to get more practice with them.)

     3:  -0.5749       3:  -0.5749        4:  -0.5749      2:  -0.5749
     2:  2             2:  1:6            3:  1:6          1:  2.3148e-3
     1:  40            1:  2              2:  2                .
         .                 .              1:  36.
                                              .

        2 RET 40        Z ( RET k b TAB     RET r 1 TAB ^      * /

     3:  -0.5749       3:  -0.5772      2:  -0.5772     1:  -0.577215664892
     2:  -0.5749       2:  -0.5772      1:  0               .
     1:  2.3148e-3     1:  -0.5749          .
         .                 .

       TAB RET M-TAB       - RET M-TAB      a =     Z /    2  Z )  Z ' C-x )

This is the value of `- gamma', with a slight bit of roundoff error.
To get a full 12 digits, let's use a higher precision:

     2:  -0.577215664892      2:  -0.577215664892
     1:  1.                   1:  -0.577215664901532

         1. RET                   p 16 RET X

Here's the complete sequence of keystrokes:

     C-x ( Z `  s 1  0 t 2
                RET 5 a <  Z [  5 Z (  & s + 2  1 s + 1  1 Z ) r 1  Z ]
                L r 1 2 * & - r 2 -
                2 RET 40  Z (  RET k b TAB RET r 1 TAB ^ * /
                               TAB RET M-TAB - RET M-TAB a = Z /
                       2  Z )
           Z '
     C-x )


File: calc.info  Node: Programming Answer 10, Prev: Programming Answer 9, Up: Answers to Exercises, Next: Programming Answer 11

Programming Tutorial Exercise 10
--------------------------------

Taking the derivative of a term of the form `x^n' will produce
a term like `n x^(n-1)'.  Taking the derivative of a constant
produces zero.  From this it is easy to see that the `n'th
derivative of a polynomial, evaluated at `x = 0', will equal the
coefficient on the `x^n' term times `n!'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.  While you are
entering a `Z ` Z '' body in a macro, Calc simply collects
keystrokes without executing them.  In the following diagrams we'll
pretend Calc actually executed the keystrokes as you typed them,
just for purposes of illustration.)

     2:  5 x^4 + (x + 1)^2          3:  5 x^4 + (x + 1)^2
     1:  6                          2:  0
         .                          1:  6
                                        .

       ' 5 x^4 + (x+1)^2 RET 6        C-x ( Z `  [ ] t 1  0 TAB

Variable 1 will accumulate the vector of coefficients.

     2:  0              3:  0                  2:  5 x^4 + ...
     1:  5 x^4 + ...    2:  5 x^4 + ...        1:  1
         .              1:  1                      .
                            .

        Z ( TAB         RET 0 s l x RET            M-TAB ! /  s | 1

Note that `s | 1' appends the top-of-stack value to the vector
in a variable; it is completely analogous to `s + 1'.  We could
have written instead, `r 1 TAB | t 1'.

     1:  20 x^3 + 2 x + 2      1:  0         1:  [1, 2, 1, 0, 5, 0, 0]
         .                         .             .

         a d x RET                 1 Z )         DEL r 1  Z ' C-x )

To convert back, a simple method is just to map the coefficients
against a table of powers of `x'.

     2:  [1, 2, 1, 0, 5, 0, 0]    2:  [1, 2, 1, 0, 5, 0, 0]
     1:  6                        1:  [0, 1, 2, 3, 4, 5, 6]
         .                            .

         6 RET                        1 + 0 RET 1 C-u v x

     2:  [1, 2, 1, 0, 5, 0, 0]    2:  1 + 2 x + x^2 + 5 x^4
     1:  [1, x, x^2, x^3, ... ]       .
         .

         ' x RET TAB V M ^            *

Once again, here are the whole polynomial to/from vector programs:

     C-x ( Z `  [ ] t 1  0 TAB
                Z (  TAB RET 0 s l x RET M-TAB ! /  s | 1
                     a d x RET
              1 Z ) r 1
           Z '
     C-x )

     C-x (  1 + 0 RET 1 C-u v x ' x RET TAB V M ^ *  C-x )


File: calc.info  Node: Programming Answer 11, Prev: Programming Answer 10, Up: Answers to Exercises, Next: Programming Answer 12

Programming Tutorial Exercise 11
--------------------------------

First we define a dummy program to go on the `z s' key.  The true
`z s' key is supposed to take two numbers from the stack and
return one number, so `DEL' as a dummy definition will make
sure the stack comes out right.

     2:  4          1:  4                         2:  4
     1:  2              .                         1:  2
         .                                            .

       4 RET 2       C-x ( DEL C-x )  Z K s RET       2

The last step replaces the 2 that was eaten during the creation
of the dummy `z s' command.  Now we move on to the real
definition.  The recurrence needs to be rewritten slightly,
to the form `s(n,m) = s(n-1,m-1) - (n-1) s(n-1,m)'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.)

     2:  4        4:  4       3:  4       2:  4
     1:  2        3:  2       2:  2       1:  2
         .        2:  4       1:  0           .
                  1:  2           .
                      .

       C-x (       M-2 RET        a =         Z [  DEL DEL 1  Z :

     4:  4       2:  4                     2:  3      4:  3    4:  3    3:  3
     3:  2       1:  2                     1:  2      3:  2    3:  2    2:  2
     2:  2           .                         .      2:  3    2:  3    1:  3
     1:  0                                            1:  2    1:  1        .
         .                                                .        .

       RET 0   a = Z [  DEL DEL 0  Z :  TAB 1 - TAB   M-2 RET     1 -      z s

(Note that the value 3 that our dummy `z s' produces is not correct;
it is merely a placeholder that will do just as well for now.)

     3:  3               4:  3           3:  3       2:  3      1:  -6
     2:  3               3:  3           2:  3       1:  9          .
     1:  2               2:  3           1:  3           .
         .               1:  2               .
                             .

      M-TAB M-TAB     TAB RET M-TAB         z s          *          -

     1:  -6                          2:  4          1:  11      2:  11
         .                           1:  2              .       1:  11
                                         .                          .

       Z ] Z ] C-x )   Z K s RET      DEL 4 RET 2       z s      M-RET k s

Even though the result that we got during the definition was highly
bogus, once the definition is complete the `z s' command gets
the right answers.

Here's the full program once again:

     C-x (  M-2 RET a =
            Z [  DEL DEL 1
            Z :  RET 0 a =
                 Z [  DEL DEL 0
                 Z :  TAB 1 - TAB M-2 RET 1 - z s
                      M-TAB M-TAB TAB RET M-TAB z s * -
                 Z ]
            Z ]
     C-x )

You can read this definition using `M-# m' (`read-kbd-macro')
followed by `Z K s', without having to make a dummy definition
first, because `read-kbd-macro' doesn't need to execute the
definition as it reads it in.  For this reason, `M-# m' is often
the easiest way to create recursive programs in Calc.


File: calc.info  Node: Programming Answer 12, Prev: Programming Answer 11, Up: Answers to Exercises

Programming Tutorial Exercise 12
--------------------------------

This turns out to be a much easier way to solve the problem.  Let's
denote Stirling numbers as calls of the function `s'.

First, we store the rewrite rules corresponding to the definition of
Stirling numbers in a convenient variable:

     s e StirlingRules RET
     [ s(n,n) := 1  :: n >= 0,
       s(n,0) := 0  :: n > 0,
       s(n,m) := s(n-1,m-1) - (n-1) s(n-1,m) :: n >= m :: m >= 1 ]
     C-c C-c

Now, it's just a matter of applying the rules:

     2:  4          1:  s(4, 2)              1:  11
     1:  2              .                        .
         .

       4 RET 2       C-x (  ' s($$,$) RET     a r StirlingRules RET  C-x )

As in the case of the `fib' rules, it would be useful to put these
rules in `EvalRules' and to add a `:: remember' condition to
the last rule.




File: calc.info  Node: Introduction, Prev: Tutorial, Up: Top, Next: Data Types

Introduction
************

This chapter is the beginning of the Calc reference manual.
It covers basic concepts such as the stack, algebraic and
numeric entry, undo, numeric prefix arguments, etc.


* Menu:

* Basic Commands::
* Help Commands::
* Stack Basics::
* Numeric Entry::
* Algebraic Entry::
* Quick Calculator::
* Keypad Mode::
* Prefix Arguments::
* Undo::
* Error Messages::
* Multiple Calculators::
* Troubleshooting Commands::


File: calc.info  Node: Basic Commands, Prev: Introduction, Up: Introduction, Next: Help Commands

Basic Commands
==============

To start the Calculator in its standard interface, type `M-x calc'.  By
default this creates a pair of small windows, `*Calculator*' and `*Calc
Trail*'.  The former displays the contents of the Calculator stack and
is manipulated exclusively through Calc commands.  It is possible
(though not usually necessary) to create several Calc Mode buffers each
of which has an independent stack, undo list, and mode settings.  There
is exactly one Calc Trail buffer; it records a list of the results of
all calculations that have been done.  The Calc Trail buffer uses a
variant of Calc Mode, so Calculator commands still work when the trail
buffer's window is selected.  It is possible to turn the trail window
off, but the `*Calc Trail*' buffer still exists and is updated silently.
*Note Trail Commands::.

In most installations, the `M-#' (Meta-Shift-3) keystroke is a more
convenient way to start the Calculator.  If you don't have a Meta key,
press ESC, then `#'.  Follow `M-#' with a letter key
that says which Calc interface or function you desire.  `M-# c'
is equivalent to `M-x calc'.  `M-# M-#' or `M-# #' is
also generally equivalent to `M-x calc'.  *Note Other M-# Commands::.

Most Calc commands use one or two keystrokes.  Lower- and upper-case
letters are distinct.  Commands may also be entered in `M-x' form; for
some commands this is the only form.  As a convenience, the `x' key
(`calc-execute-extended-command') is like `M-x' except that it enters
the initial string `calc-' for you.  For example, the following key
sequences are equivalent: `S', `M-x calc-sin RET', `x sin RET'.

The Calculator exists in many parts.  When you type `M-x calc', the
Emacs "auto-load" mechanism will bring in only the first part, which
contains the basic arithmetic functions.  The other parts will be
auto-loaded the first time you use the more advanced commands like trig
functions or matrix operations.  This is done to improve the response
time of the Calculator in the common case when all you need to do is a
little arithmetic.  If for some reason the Calculator fails to load an
extension module automatically, you can force it to load all the
extensions by using the `m X' or `M-# L' (`calc-load-everything')
command.  *Note Mode Settings::.

If you type `M-x calc' or `M-# c' with any numeric prefix argument, the
Calculator is loaded if necessary, but it is not actually started.  If
the argument is positive, the extensions are also loaded if necessary.
User-written Lisp code that wishes to make use of Calc's arithmetic
routines can use `(calc 0)' or `(calc 1)' to auto-load the Calculator.

If you type `M-# b', then next time you use `M-# c' you
will get a Calculator that uses the full height of the Emacs screen.
When full-screen mode is on, `M-# c' runs the `full-calc'
command instead of `calc'.  From the Unix shell you can type
`emacs -f full-calc' to start a new Emacs specifically for use
as a calculator.  When Calc is started from the Emacs command line
like this, Calc's normal "quit" commands actually quit Emacs itself.

The `M-# o' command is like `M-# c' except that the Calc
window is not actually selected.  If you are already in the Calc
window, `M-# o' switches you out of it.  (The regular Emacs
`C-x o' command would also work for this, but it has a
tendency to drop you into the Calc Trail window instead, which
`M-# o' takes care not to do.)

For one quick calculation, you can type `M-# q' (`quick-calc')
which prompts you for a formula (like `2+3/4').  The result is
displayed at the bottom of the Emacs screen without ever creating
any special Calculator windows.  *Note Quick Calculator::.

Finally, if you are using the X window system you may want to try
`M-# k' (`calc-keypad') which runs Calc with a
"calculator keypad" picture as well as a stack display.  Click on
the keys with the mouse to operate the calculator.  *Note Keypad Mode::.

The `q' key (`calc-quit') exits Calc Mode and closes the Calculator's
window(s).  It does not delete the Calculator buffers.  If you type `M-x
calc' again, the Calculator will reappear with the contents of the stack
intact.  Typing `M-# c' or `M-# M-#' again from inside the Calculator
buffer is equivalent to executing `calc-quit'; you can think of `M-#
M-#' as toggling the Calculator on and off.

The `M-# x' key also turns the Calculator off, no matter which
user interface (standard, Keypad, or Embedded) is current active.
It also cancels `calc-edit' mode if used from there.

The `d SPC' key sequence (`calc-refresh') redraws the contents
of the Calculator buffer from memory.  Use this if the contents of the
buffer have been damaged somehow.  The `d ~' key is also bound to
`calc-refresh'.

The `o' key (`calc-realign') moves the cursor back to its
"home" position at the bottom of the Calculator buffer.

The `<' and `>' keys are bound to `calc-scroll-left' and
`calc-scroll-right'.  These are just like the normal horizontal
scrolling commands except that they scroll one half-screen at a time by
default.  (Calc formats its output to fit within the bounds of the
window whenever it can.)

The `{' and `}' keys are bound to `calc-scroll-down' and
`calc-scroll-up'.  They scroll up or down by one-half the height of the
Calc window.

The `calc-version' command displays the current version number
of Calc and the name of the person who installed it on your system.
(This information is also present in the `*Calc Trail*' buffer,
and in the output of the `h h' command.)


File: calc.info  Node: Help Commands, Prev: Basic Commands, Up: Introduction, Next: Stack Basics

Help Commands
=============

The `?' key (`calc-help') displays a series of brief help messages.
Some keys (such as `b' and `d') are prefix keys, like Emacs'
ESC and `C-x' prefixes.  You can type
`?' after a prefix to see a list of commands beginning with that
prefix.  (If the message includes `[MORE]', press `?' again
to see additional commands for that prefix.)

The `h h' (`calc-full-help') command displays all the `?'
responses at once.  When printed, this makes a nice, compact (three pages)
summary of Calc keystrokes.

In general, the `h' key prefix introduces various commands that
provide help within Calc.  Many of the `h' key functions are
Calc-specific analogues to the `C-h' functions for Emacs help.

The `h i' (`calc-info') command runs the Emacs Info system
to read this manual on-line.  This is basically the same as typing
`C-h i' (the regular way to run the Info system), then, if Info
is not already in the Calc manual, selecting the beginning of the
manual.  The `M-# i' command is another way to read the Calc
manual; it is different from `h i' in that it works any time,
not just inside Calc.  The plain `i' key is also equivalent to
`h i', though this key is obsolete and may be replaced with a
different command in a future version of Calc.

The `h t' (`calc-tutorial') command runs the Info system on
the Tutorial section of the Calc manual.  It is like `h i',
except that it selects the starting node of the tutorial rather
than the beginning of the whole manual.  (It actually selects the
node `Interactive Tutorial' which tells a few things about
using the Info system before going on to the actual tutorial.)
The `M-# t' key is equivalent to `h t' (but it works at
all times).

The `h s' (`calc-info-summary') command runs the Info system
on the Summary node of the Calc manual.  *Note Summary::.  The `M-# s'
key is equivalent to `h s'.

The `h k' (`calc-describe-key') command looks up a key
sequence in the Calc manual.  For example, `h k H a S' looks
up the documentation on the `H a S' (`calc-solve-for')
command.  This works by looking up the textual description of
the keys you press in the `Key Index' of the manual, then
jumping to the node indicated by the index.

Most Calc commands do not have traditional Emacs documentation
strings, since the `h k' command is both more convenient and
more instructive.  This means the regular Emacs `C-h k'
(`describe-key') command will not be useful for Calc keystrokes.

The `h c' (`calc-describe-key-briefly') command reads a
key sequence and displays a brief one-line description of it at
the bottom of the screen.  It looks for the key sequence in the
Summary node of the Calc manual; if it doesn't find the sequence
there, it acts just like its regular Emacs counterpart `C-h c'
(`describe-key-briefly').  For example, `h c H a S'
gives the description:

     H a S runs calc-solve-for:  a `H a S' v  => fsolve(a,v)  (?=notes)

which means the command `H a S' or `H M-x calc-solve-for'
takes a value `a' from the stack, prompts for a value `v',
then applies the algebraic function `fsolve' to these values.
The `?=notes' message means you can now type `?' to see
additional notes from the summary that apply to this command.

The `h f' (`calc-describe-function') command looks up an
algebraic function or a command name in the Calc manual.  The
prompt initially contains `calcFunc-'; follow this with an
algebraic function name to look up that function in the
`Function Index'.  Or, backspace and enter a command name
beginning with `calc-' to look it up in the `Command Index'.
This command will also look up operator symbols that can appear
in algebraic formulas, like `%' and `=>'.

The `h v' (`calc-describe-variable') command looks up a
variable in the Calc manual.  The prompt initially contains the
`var-' prefix; just add a variable name like `pi' or
`PlotRejects'.

The `h b' (`calc-describe-bindings') command is just like
`C-h b', except that only local (Calc-related) key bindings are
listed.

The `h n' or `h C-n' (`calc-view-news') command displays
the "news" or change history of Calc.  This is kept in the file
`README', which Calc looks for in the same directory as the Calc
source files.

The `h C-c', `h C-d', and `h C-w' keys display copying,
distribution, and warranty information about Calc.  These work by
pulling up the appropriate parts of the `Copying' or
`Reporting Bugs' sections of the manual.


