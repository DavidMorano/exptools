.\" #ident "@(#) /sable/sdb/ra/sblib/error/s.error.3"
.\"
.PH "'ERROR(3SB)'SBLIB C++ Library'ERROR(3SB)'"
.PF "'10/91'All Rights Reserved'Page %'"
.OF "'ra2'Copyright \(co 1991 AT&T'ra910004'"
.EF "'ra2'Copyright \(co 1991 AT&T'ra910004'"
.SK
.VL 7 0
.LI "\fBNAME\fP"
.br
Error - System V Release 4.0 Style Error Handling
.LI "\fBSYNOPSIS\fP"
.br
.EX
\#include <sblib.h>

.SO error.dd
.EE
.P
.LI "\fBDESCRIPTION\fR"
.br
The \*(Er class provides error message capabilities similar to the System
V Release 4.0 standard.  Error objects are constructed with the address
(\fIerrlist\fP) and size (\fInerrs\fP) of an array of error strings.
Each entry in the array is of type Error_message, and has a \fItag\fP,
an \fIerror_class\fP, a \fIseverity\fP, a \fItext\fP and an \fIaction\fP.
The application environment has control over where the error message
is shown and which parts of the Error_message structure are actually generated.
.P
\fIError_message STRUCTURE\fP
.P
The \fIError_message.tag\fP is a short name for the error, and it typically
resembles the name of the symbolic constant identifying the error.  For example,
error number 1 in syserr has the tag name "EPERM" and is identified by
the #define EPERM.
.P
The \fIError_message.error_class\fP contains bits that further describe the
error.  An error is either MM_HARD (hardware), MM_SOFT (software) or
MM_FIRM (firmware).  It is either MM_RECOVER (recoverable) or MM_NRECOV
(non-recoverable).  It was generated by MM_APPL (application) code, MM_UTIL
(utility) code or MM_OPSYS (operating system) code.  Each Error_message
structure specifies one bit from the first set (MM_HARD, MM_SOFT or MM_FIRM),
one bit from the second set (MM_RECOVER or MM_NRECOV),
and one bit from the third set (MM_APPL, MM_UTIL or MM_OPSYS).  The bits are
concatenated using the bitwise OR operator, e.g. MM_SOFT|MM_RECOVER|MM_APPL.
.P
The \fIError_message.severity\fP contains bits that indicate how serious
the error is.
An error is either MM_NOSEV (unknown or don't care),
MM_HALT (fatal to the process), MM_ERROR (serious but not fatal to the process),
MM_WARNING (unusual but not serious) or
MM_INFO (information only, not really an error).
An MM_HALT error causes \fIError::error()\fP to exit(2) with a non-zero value.
The other severity bits only affect the contents of the error message.
These severity bits are translated into appropriate strings for printing by 
the \fIError::error()\fP function.
.P
The \fIError_message.text\fP contains a description of the error.
The \fItag\fP is a short description and the \fItext\fP provides a more
complete description.
.P
The \fIError_message.action\fP describes the action needed to fix the error.
It appears after the "TO FIX:" string of the error message.  If action is
NULL, the "TO FIX:" string is not printed.
.P
\fIENVIRONMENT VARIABLES\fP
.P
By setting the environment variable PRINT_ERROR_TO,
the application can control where error messages are printed.
PRINT_ERROR_TO can contain a colon separated list of the following
names: \fIcommand\fP, \fIconsole\fP, \fImail\fP and \fIstderr\fP.
If PRINT_ERROR_TO contains the name \fIconsole\fP, error messages will be
sent to the device specified in the environment variable CONSOLE_DEV,
(/dev/console by default).  If PRINT_ERROR_TO contains the name \fIcommand\fP,
the error messages will be piped to the command specified in the environment
variable ERRORCMD.  ERRORCMD must contain a fully qualified pathname from
root (i.e.  the pathname must start with a '/').
If PRINT_ERROR_TO contains the name \fImail\fP, error messages are mailed
to the owner of the process (by default).
If PRINT_ERROR_TO contains the name \fIstderr\fP, the error messages are
printed on standard error.
For example,
.DS I
PRINT_ERROR_TO=command:console:stderr
.DE
says that all error messages are to be piped to the command specified in
ERRORCMD, and printed to CONSOLE_DEV and standard error.  The error messages
would not be mailed to any one.
If PRINT_ERROR_TO is not set, or is explicitly
set to NULL, then all error messages will be printed to standard error.
If PRINT_ERROR_TO contains invalid names, the invalid names are
ignored.
.P
An error message can be broken into pieces called \fItag\fP, \fIseverity\fP,
\fItext\fP, \fIaction\fP and \fIlabel\fP.  The \fItag\fP, \fIseverity\fP,
\fItext\fP and \fIaction\fP are obtained from the original \fIerrlist\fP
array passed to \fIError::Error()\fP.
The \fIlabel\fP is obtained from the \fIfile\fP
and \fIline\fP arguments to \fIError::error()\fP, the \fIcommand\fP variable,
the current date and time of day, and the process id (pid).
If \fIcommand\fP is set, the label is of the form
\fIcommand\fP(\fIfile\fP:\fIline\fP) \fIdate timeOfDay PID=\fPpid
If \fIcommand\fP is not set, the label is of the form
(\fIfile\fP:\fIline\fP) \fIdate timeOfDay PID=\fPpid.
.P
An application can select
which pieces of the error messages are shown by setting the
environment variables CMDVERB, CONVERB, MAILVERB and STDERRVERB.
These VERBs control the error message verbosity.
CMDVERB controls the verbosity of error messages sent to ERRORCMD.
CONVERB controls the verbosity of error messages sent to CONSOLE_DEV.
MAILVERB controls the verbosity of error messages sent to an electronic mail
program.
STDERRVERB controls the verbosity of error messages sent to standard error.
All of these VERBs can contain a colon-separated
list of the names of the pieces.  For example,
.DS I
STDERRVERB=severity:text:action:label 
.DE
would print the severity, text, action and label pieces of the error message to
standard error, but the tag piece would not be printed.  This assumes that
PRINT_ERROR_TO contained \fIstderr\fP.
If any of the VERBs are not set or are set to NULL (e.g. STDERRVERB=""),
all pieces of the error message are printed to those locations designated in
PRINT_ERROR_TO.
If any of the VERBs contain invalid names, the invalid names are ignored.
.P
The \fIcommand\fP variable is used as part of the error message's label.
It must be set by the application code (typically in main() to argv[0]).
.P
\fIERROR CLASS MEMBERS\fP
.P
The \fIError::error()\fP function is used to print error messages.  It is
roughly comparable to the standard perror(3) function.  Error::error()
always returns FALSE.  This is a convenience that allows statements like
"return syserr.error(errno,__FILE__,__LINE__);".
The \fIerrnum\fP argument is the number of the error message in the error list
passed to Error::Error().
It is similar to the global variable errno in the standard C library.
However, each error object can independently
number its errors since each has its own \fIerrlist\fP.
The \fIfile\fP and \fIline\fP arguments are
used as part of the error message's label.
The \fIsuffix\fP argument is printed after the text of the error message,
assuming the appropriate VERB specified text.
The application can use \fIsuffix\fP to provide more information about the
error.
.P
\fIError::errFile()\fP attempts to open its err_file argument as file
descriptor 2 (standard error).  It returns TRUE if it is successful,
and FALSE if it fails.  If the file does not exist, it is created.
If the file exists, the errors are appended to it.
.P
\fIError::identifier()\fP accepts a pointer to a string that will be printed
after the label portion of an error message.  This assumes that the
appropriate VERB specified label.  If identifier() is called with out
any arguments, the error message identifier is set to NULL, and 
is not printed with the error message.
.P
The \fIError::mailTo()\fP function accepts a NULL terminated,
space separated list of users to whom the error messages will be mailed,
when a VERB specifies mail.  This list is validated by the electronic mail
program.  If this function is not called and a VERB specifies mail, error
messages will be mailed to the user running the process.
.P
\fIError::errno\fP is the error number passed to \fIError::error()\fP as
errnum.
.P
The most recently printed error is uniquely identified by \fIError::lasterr\fP.
For example, an application can access the number of the last error by
referencing X.lasterr->errno, assuming that X is an Error object.
.P
\fIERROR OBJECTS\fP
.P
The extern variable syserr is an Error object that defines messages for the
standard system call errors (errno).  It also contains the additional errors
NO_FREE_STORE (dynamic allocation failure), UNEXPECTED_ERROR and NULL_POINTER.
These are common errors even though they are not tied to system calls and errno.
.P
Additional Error objects may be defined by utility or application code.
.P
\fIERROR MACROS\fP
.P
The NPcheck and NScheck macros are used to check if function arguments are
NULL pointers (i.e. (char *)0 ) or null strings (i.e. "").  Both macros
generate errors which will cause the process to halt.
The NPNScheck macro can be used as short hand for specifying both checks.
.P
The SYSreturn preprocessor macro calls
syserr.error with the system's errno (not Error::errno),
the current file name and the current line number.
The False check (Fc), System check (Sc), and System ok (So) preprocessor
macros provide standard routine error checking so that the code is
not cluttered with if tests on subroutine calls.
The FALSEreturn macro should be defined locally by the function(s)
using these macros.
.P
The Trace and TraceStmt macros are used for general purpose code tracing.
Trace is used if you just want a simple
trace statement.  TraceStmt is used if you want a complex statement executed
as part of the tracing.
The environment variables TRACELEVEL and TRACEFILE are used to control the
amount of trace information that is generated.
TRACELEVEL should be set to an integer specifying
the desired level of tracing.  In general, the higher the number, the larger
the quantity of trace information.  By default it is initialized to 0.
TRACEFILE can contain the name of the file to be traced.  This will filter
out trace information that is not within the specified file.  By default
it is set to all.  For example, if TRACELEVEL was set to 5 and TRACEFILE was
set to test.c, then all the trace statements in test.c, whose level is less
than or equal to 5 would be printed.  All other trace statements in the system
would be ignored.
.LI "\fBDIAGNOSTICS\fP"
.br
The \*(Er class constructor will print an error message,
abort and exit under the following conditions:
.VL 15 0
.LI "[E_BAD_ERRCMD]"
PRINT_ERROR_TO specified \fIcommand\fP, but the command string in ERRORCMD did
not start with a slash ('/').  ERRORCMD must
contain a fully qualified pathname from root (i.e. /usr/local/bin/program).
.LI "[E_BAD_LENGTH]"
The calculation of the label's length was not equal to the number of
characters copied into the label's array.  Be sure that the calculation
includes all the literals in the string being copied into the label's array.
.LI "[E_NO_CONSOLE_DEV]"
PRINT_ERROR_TO specified \fIconsole\fP, but the device specified in CONSOLE_DEV
(default /dev/console) could not be opened.  Be sure that the device is
plugged in, powered on and accessible to the user running the program.
.LI "[E_NULL_ERRLIST]"
The errlist array passed to Error::Error was NULL.
.LI "errno"
PRINT_ERROR_TO specified \fIconsole\fP, but CONSOLE_DEV is not writable.
.LI "errno"
PRINT_ERROR_TO specified \fIcommand\fP and ERRORCMD is the name of a command
that is not available to this process.
.LE
.P
The \*(Er class will print an error message and continue executing under
the following conditions:
.VL 10 0
.LI "[E_NO_ERRCMD]"
PRINT_ERROR_TO specified \fIcommand\fP, but ERRORCMD was not set or is NULL;
\fIcommand\fP is ignored.
To correct, remove \fIcommand\fP from PRINT_ERROR_TO, or set and export
ERRORCMD.
.LI "[E_UNKNOWN_ERROR]"
Error::error() was called with an errnum that is greater than the number
of errors passed in the errlist array.
.LI "[NULL_POINTER]"
Error::mailTo() was called with a NULL pointer, i.e. no addressees.
.LE                                      \" end VL for DIAGNOSTICS
.LI "\fBEXAMPLE\fP"
.br
.EX
\/* shell:  STDERRVERB=text:severity:action; export STDERRVERB */
\/* shell:  PRINT_ERROR_TO=console:stderr; export PRINT_ERROR_TO */

.SO errorE.ex 
.EE
.LI "\fBWARNINGS\fP"
.br
The options to pipe to ERRORCMD and to send mail are not part of the
SVR4.0 error handling.
.P
Currently, MM_HALT indicates a non-recoverable error.  MM_RECOVER and MM_NRECOV 
have no effect.  They are included to maintain SVR4.0 compatibility.
.P
Do not expect a precise emulation of SVR4.0 error handling.  At the time of
this implementation, SVR4 error handling was not complete.
.LI "\fBSEE ALSO\fP"
.br
\fBintro(3SB)\fR, exit(2), abort(3C), perror(3C).
.LE
