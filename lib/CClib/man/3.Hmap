


     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



     NNNNAAAAMMMMEEEE
          H-map - hashed associative array classes

     SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
          ####iiiinnnncccclllluuuuddddeeee <<<<HHHHmmmmaaaapppp....hhhh>>>>

          HHHHmmmmaaaappppddddeeeeccccllllaaaarrrreeee((((SSSS,,,,TTTT))))
          HHHHmmmmaaaappppiiiimmmmpppplllleeeemmmmeeeennnntttt((((SSSS,,,,TTTT))))

          ssssttttaaaattttiiiicccc TTTT HHHHmmmmaaaappppddddeeeeffffaaaauuuulllltttt((((SSSS,,,,TTTT))));;;;

          ccccllllaaaassssssss HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))) {{{{
          ppppuuuubbbblllliiiicccc::::
               HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))((((ccccoooonnnnsssstttt TTTT&&&& iiiinnnniiiitttt____vvvvaaaallll ==== HHHHmmmmaaaappppddddeeeeffffaaaauuuulllltttt((((SSSS,,,,TTTT)))),,,,
                      uuuunnnnssssiiiiggggnnnneeeedddd ssssiiiizzzzeeee ==== 666600000000,,,, ffffllllooooaaaatttt mmmmaaaaxxxx____llllffff ==== 3333....0000,,,,
                      uuuunnnnssssiiiiggggnnnneeeedddd bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt ==== _a _l_a_r_g_e _s_y_s_t_e_m _d_e_p_e_n_d_e_n_t _v_a_l_u_e,,,,
                      uuuunnnnssssiiiiggggnnnneeeedddd sssshhhhoooorrrrtttt ggggrrrroooowwwwtttthhhh____eeeexxxxpppp ==== 4444))));;;;
               HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))((((ccccoooonnnnsssstttt HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))&&&& hhhhmmmmaaaapppp))));;;;
               ~~~~HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))(((())));;;;
               HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))&&&& ooooppppeeeerrrraaaattttoooorrrr==== ((((ccccoooonnnnsssstttt HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))&&&& hhhhmmmmaaaapppp))));;;;
               TTTT&&&& ooooppppeeeerrrraaaattttoooorrrr[[[[ ]]]] ((((ccccoooonnnnsssstttt SSSS&&&& kkkkeeeeyyyy))));;;;
               iiiinnnntttt rrrreeeemmmmoooovvvveeee ((((ccccoooonnnnsssstttt SSSS&&&& kkkkeeeeyyyy))));;;;
               iiiinnnntttt ssssiiiizzzzeeee(((()))) ccccoooonnnnsssstttt;;;;
               iiiinnnntttt ccccoooonnnnttttaaaaiiiinnnnssss ((((ccccoooonnnnsssstttt SSSS&&&& kkkkeeeeyyyy))));;;;
               vvvvooooiiiidddd cccclllleeeeaaaarrrr(((())));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) eeeelllleeeemmmmeeeennnntttt ((((ccccoooonnnnsssstttt SSSS&&&& kkkkeeeeyyyy))));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) ffffiiiirrrrsssstttt(((())));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) llllaaaasssstttt(((())));;;;
               vvvvooooiiiidddd ffffrrrreeeeeeeezzzzeeee(((())));;;;
               vvvvooooiiiidddd tttthhhhaaaawwww(((())));;;;
          }}}};;;;

          ccccllllaaaassssssss HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) {{{{
          ppppuuuubbbblllliiiicccc::::
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) ((((HHHHmmmmaaaapppp((((SSSS,,,,TTTT))))&&&& hhhhmmmmaaaapppp))));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) ((((ccccoooonnnnsssstttt HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& iiiitttteeeerrrr))));;;;
               ~~~~HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))(((())));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& ooooppppeeeerrrraaaattttoooorrrr==== ((((ccccoooonnnnsssstttt HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& iiiitttteeeerrrr))))
               ooooppppeeeerrrraaaattttoooorrrr iiiinnnntttt(((())));;;;
               ccccoooonnnnsssstttt SSSS&&&& kkkkeeeeyyyy(((())));;;;
               TTTT&&&& vvvvaaaalllluuuueeee(((())));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& ooooppppeeeerrrraaaattttoooorrrr++++++++(((())));;;;
               HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& ooooppppeeeerrrraaaattttoooorrrr--------(((())));;;;
               iiiinnnntttt ooooppppeeeerrrraaaattttoooorrrr======== ((((ccccoooonnnnsssstttt HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& iiiitttteeeerrrr))));;;;
               iiiinnnntttt ooooppppeeeerrrraaaattttoooorrrr!!!!==== ((((ccccoooonnnnsssstttt HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT))))&&&& iiiitttteeeerrrr))));;;;
               iiiinnnntttt rrrreeeemmmmoooovvvveeee(((())));;;;
          }}}};;;;

     DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN
          An _h-_m_a_p is an implementation of an associative array by
          means of a hash table.  An associative array consists of a
          collection of _e_l_e_m_e_n_t_s, where each element is a pair



     Page 1                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



          containing a _k_e_y and its associated _v_a_l_u_e.  Each key appears
          in at most one element, so there is a well defined mapping
          from keys to values.  An h-map is similar to a map (see
          MMMMAAAAPPPP((((3333++++))))), the main functional difference being that maps
          provide a way to enumerate the keys in sorted order, while
          the keys in an h-map are enumerated in an arbitrary order.
          When the number of elements is large the principal
          operations of adding, deleting, and looking up elements are
          usually faster for h-maps than for maps.  However, h-maps
          have a larger start-up overhead than maps, in terms of both
          time and space.

          An h-map that maps keys of type SSSS to values of type TTTT has
          the type name HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))).  For example, HHHHmmmmaaaapppp((((ddddoooouuuubbbblllleeee,,,,SSSSttttrrrriiiinnnngggg))))
          is the type of an h-map that maps keys of type ddddoooouuuubbbblllleeee to
          values of type SSSSttttrrrriiiinnnngggg.  Because this type name is currently
          created by means of macros it must not have any imbedded
          spaces.  Also, SSSS and TTTT must be single identifiers.
          Complicated type names can be handled by using ttttyyyyppppeeeeddddeeeeffff to
          equate them to single identifiers.

          Types SSSS and TTTT must satisfy the following conditions:

          1.  If TTTT is a class it must have a constructor that takes no
              arguments.

          2.  It must be possible to initialize a variable of type TTTT
              to a value of type TTTT, and to assign to a variable of
              type TTTT a value of type TTTT.  Type TTTT must have _v_a_l_u_e
              _s_e_m_a_n_t_i_c_s, i.e., assignment and initialization must have
              the effect of copying the value.  The definitions of
              initialization and assignment must specify a type of TTTT
              or ccccoooonnnnsssstttt TTTT&&&& for the argument being copied (e.g., the
              right hand side of the ==== operator).

          3.  If SSSS is a class it must have a constructor that takes no
              arguments.

          4.  It must be possible to initialize a variable of type SSSS
              to a value of type SSSS.  Type SSSS must have value semantics.
              The definition of initialization must specify a type of
              SSSS or ccccoooonnnnsssstttt SSSS&&&& for the argument being copied.

          5.  There must be a test for equality (========) among values of
              type SSSS.  The arguments of the equality operator must be
              of type SSSS or ccccoooonnnnsssstttt SSSS&&&&.  (Unlike the case for maps, it is
              not necessary for an ordering to be defined on keys.)

          6.  A hash function called hhhhaaaasssshhhh____vvvvaaaalllluuuueeee must be defined that
              takes a key and returns an uuuunnnnssssiiiiggggnnnneeeedddd iiiinnnntttt.  Its argument
              must be of type SSSS or ccccoooonnnnsssstttt SSSS&&&&.  The function hhhhaaaasssshhhh____vvvvaaaalllluuuueeee
              is overloaded and is already defined for the fundamental



     Page 2                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



              types iiiinnnntttt, lllloooonnnngggg, uuuunnnnssssiiiiggggnnnneeeedddd iiiinnnntttt, uuuunnnnssssiiiiggggnnnneeeedddd lllloooonnnngggg, vvvvooooiiiidddd****,
              ffffllllooooaaaatttt, and ddddoooouuuubbbblllleeee.  (Types sssshhhhoooorrrrtttt and uuuunnnnssssiiiiggggnnnneeeedddd sssshhhhoooorrrrtttt are
              automatically coerced to type iiiinnnntttt, so hhhhaaaasssshhhh____vvvvaaaalllluuuueeee is
              effectively defined for these types as well.)  If the
              file SSSSttttrrrriiiinnnngggg....hhhh is included before HHHHmmmmaaaapppp....hhhh then hhhhaaaasssshhhh____vvvvaaaalllluuuueeee
              will also be defined for keys of type SSSSttttrrrriiiinnnngggg.

          Keys of pointer type should be used only in those cases
          where it suffices to copy and compare the pointers alone,
          not the objects they point to.  In particular, you generally
          do not want to use character pointers as keys.  If you think
          you need a character pointer you probably really want a
          SSSSttttrrrriiiinnnngggg, which has value semantics (see SSSSTTTTRRRRIIIINNNNGGGG((((3333++++))))).

          The classes HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))) and HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) (described later)
          are declared by the macro HHHHmmmmaaaappppddddeeeeccccllllaaaarrrreeee((((SSSS,,,,TTTT)))), and are
          implemented by the macro HHHHmmmmaaaappppiiiimmmmpppplllleeeemmmmeeeennnntttt((((SSSS,,,,TTTT)))).
          HHHHmmmmaaaappppddddeeeeccccllllaaaarrrreeee((((SSSS,,,,TTTT)))) must appear in every file where h-maps of
          type HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))) are used and HHHHmmmmaaaappppiiiimmmmpppplllleeeemmmmeeeennnntttt((((SSSS,,,,TTTT)))) must appear
          in exactly one file, after the corresponding declarations.
          The appropriate declaration of hhhhaaaasssshhhh____vvvvaaaalllluuuueeee must appear before
          HHHHmmmmaaaappppiiiimmmmpppplllleeeemmmmeeeennnntttt((((SSSS,,,,TTTT)))) if SSSS isn't one of the types for which
          hhhhaaaasssshhhh____vvvvaaaalllluuuueeee is pre-defined.

          The main constructor for h-maps is:

          HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))) ((((iiiinnnniiiitttt____vvvvaaaallll,,,, ssssiiiizzzzeeee,,,, mmmmaaaaxxxx____llllffff,,,, bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt,,,, ggggrrrroooowwwwtttthhhh____eeeexxxxpppp))))
                    Create an h-map with default value iiiinnnniiiitttt____vvvvaaaallll,
                    suggested size ssssiiiizzzzeeee, maximum load factor mmmmaaaaxxxx____llllffff,
                    bucket limit bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt, and growth exponent
                    ggggrrrroooowwwwtttthhhh____eeeexxxxpppp.

          Every one of the above parameters is optional, and
          reasonable defaults ensure that you often don't need to
          specify any of them.  In fact, it is recommended that you
          avoid using the last three parameters since they deal with
          inner workings of h-maps that you shouldn't normally be
          concerned with.  In more detail, the first two parameters
          are:

          iiiinnnniiiitttt____vvvvaaaallllA value of type TTTT that serves as the value for
                  uninitialized elements.  If there is not yet an
                  element with key kkkk in h-map mmmm then the expression
                  mmmm[[[[kkkk]]]] causes an element to be created with key kkkk and
                  value iiiinnnniiiitttt____vvvvaaaallll.  The default for iiiinnnniiiitttt____vvvvaaaallll is the
                  value that a ssssttttaaaattttiiiicccc variable of type TTTT has when it
                  hasn't been explicitly initialized.  The macro
                  HHHHmmmmaaaappppddddeeeeffffaaaauuuulllltttt((((SSSS,,,,TTTT)))) yields a constant of type TTTT with
                  this default value.  It can be used as a placeholder
                  when you want to specify parameters other than
                  iiiinnnniiiitttt____vvvvaaaallll.




     Page 3                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



          ssssiiiizzzzeeee    An uuuunnnnssssiiiiggggnnnneeeedddd iiiinnnntttt giving the maximum number of
                  elements you expect to put in the h-map.  This
                  provides a hint about how large the hash table ought
                  to be, so as to save space (by not making it too
                  large) and time (by not making it so small that
                  resizing is necessary).  You are guaranteed to be
                  able to put ssssiiiizzzzeeee elements into the hash table
                  without any resizing taking place.  If the actual
                  number of elements exceeds ssssiiiizzzzeeee the hash table may
                  be resized upward, a fairly time consuming
                  operation.  However, everything will still work.
                  The default for ssssiiiizzzzeeee is 600.

          To understand the remaining parameters it is necessary to
          know a bit about the internal workings of h-maps.  Each
          element in an h-map is put into one of a number of _b_u_c_k_e_t_s,
          with the bucket being determined by hashing the element's
          key and taking the result modulo the number of buckets.  The
          elements in a given bucket are strung together in a
          sequential list, and there is an array called the _h_a_s_h
          _v_e_c_t_o_r containing pointers to the head of each bucket list.
          So to look up an element its key is hashed to determine the
          bucket number, the corresponding bucket list is found by
          indexing into the hash vector, and then the list is scanned
          sequentially.  The _l_o_a_d _f_a_c_t_o_r is defined to be the ratio of
          elements to buckets, i.e, the average number of elements in
          each bucket.  For a given number of elements a larger load
          factor results in a smaller hash table (since there are
          fewer buckets) but longer search times.  Here are the
          parameters for tweaking the hash table:

          mmmmaaaaxxxx____llllffff  A ffffllllooooaaaatttt specifying the maximum load factor before
                  resizing occurs.  When the load factor exceeds
                  mmmmaaaaxxxx____llllffff more buckets are created - a new, larger hash
                  vector is allocated and all elements are rehashed
                  into their new buckets.  The default value of mmmmaaaaxxxx____llllffff
                  is 3.0.  The maximum load factor may be set to any
                  positive number; in particular, values less than 1
                  are valid.

          bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt
                  An uuuunnnnssssiiiiggggnnnneeeedddd iiiinnnntttt giving the maximum number of buckets
                  allowed.  The number of buckets will never exceed
                  bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt no matter how large the load factor
                  gets.  Thus, once this limit is reached resizing no
                  longer occurs.  The default is some large system
                  dependent value.  In general you may set
                  bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt to a value larger as well as smaller
                  than the default.

          ggggrrrroooowwwwtttthhhh____eeeexxxxpppp
                  An uuuunnnnssssiiiiggggnnnneeeedddd sssshhhhoooorrrrtttt specifying the _g_r_o_w_t_h _e_x_p_o_n_e_n_t.



     Page 4                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



                  When resizing occurs the number of buckets is
                  increased by a factor of approximately 2 to the
                  power ggggrrrroooowwwwtttthhhh____eeeexxxxpppp/4.  (The actual number of buckets
                  is always a prime number, to make hashing work
                  better.)  The default for ggggrrrroooowwwwtttthhhh____eeeexxxxpppp is 4,
                  corresponding to a growth factor of 2.  The growth
                  exponent must be between 1 and 12.

          Setting any of ssssiiiizzzzeeee, mmmmaaaaxxxx____llllffff, bbbbuuuucccckkkkeeeetttt____lllliiiimmmmiiiitttt, or ggggrrrroooowwwwtttthhhh____eeeexxxxpppp to
          0 results in its default value being used instead.  You will
          probably find that fiddling with mmmmaaaaxxxx____llllffff or ggggrrrroooowwwwtttthhhh____eeeexxxxpppp has
          surprisingly little effect on your program's performance.

          A new h-map can be initialized from some pre-existing h-map,
          mmmm:

          HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))) ((((mmmm))))
                    Create an h-map whose elements are copies of the
                    elements in mmmm and whose default value, maximum
                    load factor, bucket limit, and growth exponent are
                    the same as for mmmm.

          Here are the operations defined for h-maps (mmmm and nnnn are h-
          maps, vvvv is an expression of type TTTT, and kkkk is an expression
          of type SSSS):

          nnnn ==== mmmm     All elements in nnnn are deleted and then copies of
                    the elements in mmmm are added to nnnn.  The default
                    value, maximum load factor, bucket limit, and
                    growth exponent of nnnn are all left unchanged.  The
                    result is the new value of nnnn.

          mmmm[[[[kkkk]]]]      A reference to the value of the element in mmmm with
                    key kkkk.  If no such element exists one is created,
                    with its value set to the default value for mmmm.

          mmmm....ssssiiiizzzzeeee(((())))  An iiiinnnntttt equal to the number of elements in mmmm.

          mmmm....ccccoooonnnnttttaaaaiiiinnnnssss((((kkkk))))
                    One if mmmm contains an element with key kkkk, and 0 if
                    it doesn't.

          mmmm....rrrreeeemmmmoooovvvveeee((((kkkk))))
                    If there is an element with key kkkk in mmmm, it is
                    deleted and 0 is returned.  Otherwise mmmm is not
                    changed and 1 is returned.

          mmmm....cccclllleeeeaaaarrrr(((()))) Delete all elements from mmmm.  The number of buckets
                    is left unchanged.

          mmmm....eeeelllleeeemmmmeeeennnntttt((((kkkk))))
                    An iterator referring to the element in mmmm with key



     Page 5                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



                    kkkk, if such an element exists, otherwise a vacuous
                    iterator for mmmm.  (See below.)

          mmmm....ffffiiiirrrrsssstttt(((()))) An iterator obtained by incrementing a vacuous
                    iterator for mmmm.  (See below.)  Since iterators
                    traverse through the elements of an h-map in an
                    arbitrary order, there is nothing special about
                    the key referred to (in particular, it is not
                    necessarily the smallest key in mmmm).  This is
                    mainly provided for compatibility with maps.

          mmmm....llllaaaasssstttt(((())))  An iterator obtained by decrementing a vacuous
                    iterator for mmmm.  (See below.)  Since iterators
                    traverse through the elements of an h-map in an
                    arbitrary order, there is nothing special about
                    the key referred to (in particular, it is not
                    necessarily the largest key in mmmm).  This is mainly
                    provided for compatibility with maps.

          mmmm....ffffrrrreeeeeeeezzzzeeee(((())))
                    Disables the use of the move-to-front rule when
                    accessing elements in mmmm, thereby ensuring that
                    successive iterations return elements in a
                    consistent order.  (See below.)

          mmmm....tttthhhhaaaawwww(((())))  Re-enables the use of the move-to-front rule when
                    accessing the elements in mmmm.  (See below.)

        HHHH----mmmmaaaapppp iiiitttteeeerrrraaaattttoooorrrrssss
          An _i_t_e_r_a_t_o_r is an object that can be used to refer to, and
          enumerate, elements of an h-map.  The iterators associated
          with an h-map of class HHHHmmmmaaaapppp((((SSSS,,,,TTTT)))) are of the class
          HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))).  An iterator always refers to some h-map, and
          may also refer to some element within the h-map.  An
          iterator that does not refer to any element is said to be
          _v_a_c_u_o_u_s.  The following constructors are defined for
          iterators (iiii and jjjj denote iterators):

          HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) ((((mmmm))))
                    Create a vacuous iterator refering to h-map mmmm.

          HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSS,,,,TTTT)))) ((((iiii))))
                    Create an iterator referring to the same h-map and
                    element as iterator iiii.

          For purposes of enumeration it is useful to think of the
          elements of an h-map as being arranged in a circle that
          includes an extra ``vacuous'' element.  The ordering within
          the circle is arbitrary.  The operators and functions for
          iterators are:

          iiii ==== jjjj     Iterator iiii is set to refer to the same h-map and



     Page 6                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



                    element as jjjj.  The result is the new value of iiii.

          iiii....kkkkeeeeyyyy(((())))   A const reference to the key of the element
                    referred to by iiii.  You can not assign any value to
                    iiii....kkkkeeeeyyyy(((()))).  If iiii is vacuous, this is a const
                    reference to a ssssttttaaaattttiiiicccc variable of type SSSS that has
                    not been explicitly initialized.

          iiii....vvvvaaaalllluuuueeee(((()))) A reference to the value of the element referred
                    to by iiii.  Assigning to iiii....vvvvaaaalllluuuueeee(((()))) changes the value
                    of the element in the h-map.  If iiii is vacuous,
                    iiii....vvvvaaaalllluuuueeee(((()))) is a reference to a ssssttttaaaattttiiiicccc variable that
                    has been set to the value of HHHHmmmmaaaappppddddeeeeffffaaaauuuulllltttt((((SSSS,,,,TTTT)))).
                    (Assigning to this reference does not change the
                    value of HHHHmmmmaaaappppddddeeeeffffaaaauuuulllltttt((((SSSS,,,,TTTT)))).)

          ++++++++iiii       Causes iiii to refer to the next element in its
                    corresponding h-map.  I.e., iiii moves one step
                    ``clockwise'' in the circle of elements.  If iiii was
                    vacuous it is set to the element that is clockwise
                    from the vacuous element.  If iiii referred to the
                    element counter-clockwise from the vacuous
                    element, iiii becomes vacuous.  The value is the
                    incremented iterator.

          --------iiii       Causes iiii to refer to the previous element in its
                    corresponding h-map.  I.e., iiii moves one step
                    ``counter-clockwise'' in the circle of elements.
                    If iiii was vacuous it is set to the element that is
                    counter-clockwise from the vacuous element.  If iiii
                    referred to the element clockwise from the vacuous
                    element, iiii becomes vacuous.  The value is the
                    decremented iterator.

          iiii ======== jjjj    Iterators iiii and jjjj are equal if they refer the the
                    same h-map and either both iterators are vacuous
                    or they refer to the same element in the h-map.

          iiii !!!!==== jjjj    Equivalent to !!!!((((iiii ======== jjjj)))).

          iiii....rrrreeeemmmmoooovvvveeee(((())))
                    If iiii is non-vacuous it is decremented, the element
                    that iiii had referred to before being decremented is
                    deleted, and 0 is returned.  Otherwise the h-map
                    that iiii refers to is left unmodified and 1 is
                    returned.

          Not only is the order of enumeration arbitrary, but there is
          no guarantee that successive enumerations over the same h-
          map will produce its elements in the same order each time,
          even if no elements have been added or deleted in between.
          This is because accesses to elements normally rearrange



     Page 7                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



          bucket lists using the move-to-front rule (in order to take
          advantage of locality of reference).  The only guarantee is
          that the ordering for an h-map will remain fixed so long as
          some iterator for that h-map is non-vacuous.  In particular,
          if you start with a vacuous iterator and keep incrementing
          (or decrementing) it until it becomes vacuous again, it will
          refer to each element exactly once.  Occasionally it is
          desirable to ensure that the order of enumeration is the
          same in each of several successive enumerations.  This can
          be done by applying the ffffrrrreeeeeeeezzzzeeee operation to the h-map after
          its elements have been inserted but before doing the
          enumerations.

          If an element is added to an h-map the iterators for that
          h-map continue to refer to the same elements as before, but
          the effect on the ordering of the elements is undefined.
          For example, a single addition can cause a resizing
          operation that completely reorders the elements.  (Freezing
          an h-map does not disable resizing.)  If an element is
          removed the value of any iterator that referred to it
          becomes undefined, and the only safe operation that can be
          performed on such an iterator is to assign a well defined
          iterator to it.  However, iterators that refer to elements
          in the same h-map other than the one removed are unaffected
          and the order of enumeration remains well defined - the
          deleted element is removed from the circle of elements
          without rearranging any other elements.

          An iterator can be coerced to an iiiinnnntttt; the result is 0 if the
          iterator is vacuous and 1 otherwise.

     NNNNOOOOTTTTEEEESSSS
          H-maps are copied when passed as parameters; use references
          to h-maps instead to avoid this high overhead operation.

          You can clear an existing iterator (i.e., make it vacuous)
          by setting it to an h-map:

           iiii ==== mmmm;;;;  //////// mmmm is coerced to a vacuous iterator.

          One way to test if key kkkk is in h-map mmmm is to say:

           iiiiffff ((((mmmm....eeeelllleeeemmmmeeeennnntttt((((kkkk)))))))) .... .... ....

          because the iterator returned will be vacuous (and thus
          coerced to 0) if kkkk is not in mmmm and non-vacuous (and thus
          coerced to 1) otherwise.  Another way to do the same thing
          is to say:

           iiiiffff ((((mmmm....ccccoooonnnnttttaaaaiiiinnnnssss((((kkkk)))))))) .... .... ....

          which is faster because it doesn't create and destroy an



     Page 8                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



          iterator.

          The rrrreeeemmmmoooovvvveeee function for iterators has been designed to make
          it easy to delete all elements of an h-map having a certain
          property in a single _f_o_r_w_a_r_d sweep of the h-map.  For
          example, if iiii is an initially vacuous iterator of type
          HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSSttttrrrriiiinnnngggg,,,,ffffllllooooaaaatttt)))), the following code will delete all
          elements with positive values in iiii's h-map:

           wwwwhhhhiiiilllleeee ((((++++++++iiii)))) iiiiffff ((((iiii....vvvvaaaalllluuuueeee(((()))) >>>> 0000....0000)))) iiii....rrrreeeemmmmoooovvvveeee(((())));;;;

          Using HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSSttttrrrriiiinnnngggg,,,,ffffllllooooaaaatttt))))::::::::rrrreeeemmmmoooovvvveeee is both faster and more
          convenient than saving the key, decrementing the iterator,
          and then deleting the element with
          HHHHmmmmaaaapppp((((SSSSttttrrrriiiinnnngggg,,,,ffffllllooooaaaatttt))))::::::::rrrreeeemmmmoooovvvveeee.

          Occasionally a situation will arise where you want to fix
          the number of buckets ahead of time and disable resizing
          entirely, either to avoid the occasional _O(_n) cost of
          resizing or to prevent the possibility of a memory
          allocation failure caused by trying to get a large block of
          storage for a new hash vector.  This can be achieved by
          setting the maximum load factor to 1 and using the number of
          buckets you want as both the bucket limit and the size.
          (The actual number of buckets used might be as much as 17%
          smaller than the specified bucket limit, because bucket
          counts come from a predetermined set of primes.)

     PPPPEEEERRRRFFFFOOOORRRRMMMMAAAANNNNCCCCEEEE
          Each operation on a single element takes _O(1) time on
          average, provided that the bucket limit hasn't been reached.
          Occasionally adding an element will take _O(_n) time, due to
          resizing, but the amortized cost of the resizing operations
          is still _O(1) per insertion.  The constant inside the ``_O''
          depends on the maximum load factor and the growth exponent.
          Hashing depends heavily on the law of averages; if that law
          is repealed in your application each operation might take as
          much as _O(_n) time.  In the current implementation
          incrementing an iterator (++++++++) is faster than decrementing it
          (--------).

     EEEEXXXXAAAAMMMMPPPPLLLLEEEE
          This example program uses an h-map to count how many times
          each word appears in standard input and then lists the
          counts on standard output.  (Essentially the same program,
          using a map rather than an h-map, is given in _A_s_s_o_c_i_a_t_i_v_e
          _A_r_r_a_y_s _i_n _C++ by Andrew Koenig.)








     Page 9                                          (printed 5/14/91)






     HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))                    CCCCCCCClllliiiibbbb                    HHHHMMMMAAAAPPPP((((3333CCCC++++++++))))



               ####iiiinnnncccclllluuuuddddeeee <<<<iiiioooossssttttrrrreeeeaaaammmm....hhhh>>>>
               ####iiiinnnncccclllluuuuddddeeee <<<<SSSSttttrrrriiiinnnngggg....hhhh>>>>
               ####iiiinnnncccclllluuuuddddeeee <<<<HHHHmmmmaaaapppp....hhhh>>>>

               HHHHmmmmaaaappppddddeeeeccccllllaaaarrrreeee((((SSSSttttrrrriiiinnnngggg,,,,iiiinnnntttt))))
               HHHHmmmmaaaappppiiiimmmmpppplllleeeemmmmeeeennnntttt((((SSSSttttrrrriiiinnnngggg,,,,iiiinnnntttt))))

               mmmmaaaaiiiinnnn(((())))
               {{{{
                 HHHHmmmmaaaapppp((((SSSSttttrrrriiiinnnngggg,,,,iiiinnnntttt)))) ffffrrrreeeeqqqquuuueeeennnnccccyyyy;;;;
                 SSSSttttrrrriiiinnnngggg wwwwoooorrrrdddd;;;;
                 wwwwhhhhiiiilllleeee ((((cccciiiinnnn >>>>>>>> wwwwoooorrrrdddd))))  ffffrrrreeeeqqqquuuueeeennnnccccyyyy[[[[wwwwoooorrrrdddd]]]]++++++++;;;;

                 HHHHmmmmaaaappppiiiitttteeeerrrr((((SSSSttttrrrriiiinnnngggg,,,,iiiinnnntttt)))) iiii((((ffffrrrreeeeqqqquuuueeeennnnccccyyyy))));;;;
                 wwwwhhhhiiiilllleeee ((((++++++++iiii))))  ccccoooouuuutttt <<<<<<<< sssseeeettttwwww((((4444)))) <<<<<<<< iiii....vvvvaaaalllluuuueeee(((()))) <<<<<<<< """"  """" <<<<<<<< iiii....kkkkeeeeyyyy(((()))) <<<<<<<< """"\\\\nnnn"""";;;;
               }}}}


          Note that use is made of the fact that the default value for
          iiiinnnntttt is 0, so that there is no need to explicitly initialize
          ffffrrrreeeeqqqquuuueeeennnnccccyyyy.  Here we use the pre-defined version of
          hhhhaaaasssshhhh____vvvvaaaalllluuuueeee that hashes SSSSttttrrrriiiinnnnggggs, so no explicit definition of
          hhhhaaaasssshhhh____vvvvaaaalllluuuueeee is needed.  If maps were used the list would come
          out sorted by word.  But since h-maps are used the words are
          output in an arbitrary order.

     SSSSEEEEEEEE AAAALLLLSSSSOOOO
          MAP(3+)

     BBBBUUUUGGGGSSSS
          It is the user's responsibility to avoid using a non-vacuous
          iterator if the element it refers to has been deleted, and
          to stop using any iterator whose map has disappeared.
          Ambiguities can occur if the type name SSSS contains an
          underscore.  A core dump is likely if memory is exhausted
          unless someone has provided an error handler for ooooppppeeeerrrraaaattttoooorrrr
          nnnneeeewwww.

          FFFFrrrreeeeeeeezzzzeeee and tttthhhhaaaawwww are ugly.
















     Page 10                                         (printed 5/14/91)



