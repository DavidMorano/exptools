curses.h:#define ACS_BBSS (acs_map['k'])
curses.h:#define ACS_BLOCK (acs_map['0']) /* solid square block */
curses.h:#define ACS_BOARD (acs_map['h']) /* board of squares */
curses.h:#define ACS_BSBS (acs_map['q'])
curses.h:#define ACS_BSSB (acs_map['l'])
curses.h:#define ACS_BSSS (acs_map['w'])
curses.h:#define ACS_BTEE ACS_SSBS
curses.h:#define ACS_BULLET (acs_map['~']) /* bullet */
curses.h:#define ACS_CKBOARD (acs_map['a']) /* checker board (stipple) */
curses.h:#define ACS_DARROW (acs_map['.']) /* arrow pointing down */
curses.h:#define ACS_DEGREE (acs_map['f']) /* degree symbol */
curses.h:#define ACS_DIAMOND (acs_map['`']) /* diamond */
curses.h:#define ACS_HLINE ACS_BSBS
curses.h:#define ACS_LANTERN (acs_map['i']) /* lantern symbol */
curses.h:#define ACS_LARROW (acs_map[',']) /* arrow pointing left */
curses.h:#define ACS_LLCORNER ACS_SSBB
curses.h:#define ACS_LRCORNER ACS_SBBS
curses.h:#define ACS_LTEE ACS_SSSB
curses.h:#define ACS_PLMINUS (acs_map['g']) /* plus/minus */
curses.h:#define ACS_PLUS ACS_SSSS
curses.h:#define ACS_RARROW (acs_map['+']) /* arrow pointing right */
curses.h:#define ACS_RTEE ACS_SBSS
curses.h:#define ACS_S1 (acs_map['o']) /* scan line 1 */
curses.h:#define ACS_S9 (acs_map['s']) /* scan line 9 */
curses.h:#define ACS_SBBS (acs_map['j'])
curses.h:#define ACS_SBSB (acs_map['x'])
curses.h:#define ACS_SBSS (acs_map['u'])
curses.h:#define ACS_SSBB (acs_map['m'])
curses.h:#define ACS_SSBS (acs_map['v'])
curses.h:#define ACS_SSSB (acs_map['t'])
curses.h:#define ACS_SSSS (acs_map['n'])
curses.h:#define ACS_TTEE ACS_BSSS
curses.h:#define ACS_UARROW (acs_map['-']) /* arrow pointing up */
curses.h:#define ACS_ULCORNER ACS_BSSB
curses.h:#define ACS_URCORNER ACS_BBSS
curses.h:#define ACS_VLINE ACS_SBSB
limits.h:#define ARG_MAX 5120 /* max length of arguments to exec */
curses.h:#define A_ALTCHARSET 000100000000L
curses.h:#define A_ATTRIBUTES 037777600000L /* 0xFFFF0000 */
curses.h:#define A_BLINK 000002000000L
curses.h:#define A_BOLD 000010000000L
curses.h:#define A_CHARTEXT 000000177777L /* 0x0000FFFF */
curses.h:#define A_DIM 000004000000L
curses.h:#define A_INVIS 000020000000L
curses.h:#define A_NORMAL 000000000000L
curses.h:#define A_PROTECT 000040000000L
curses.h:#define A_REVERSE 000001000000L
curses.h:#define A_STANDOUT 000000200000L
curses.h:#define A_UNDERLINE 000000400000L
sys/termio.h:#define B0 0
sys/termio.h:#define B110 0000003
sys/termio.h:#define B1200 0000011
sys/termio.h:#define B134 0000004
sys/termio.h:#define B150 0000005
sys/termio.h:#define B1800 0000012
sys/termio.h:#define B19200 0000016
sys/termio.h:#define B200 0000006
sys/termio.h:#define B2400 0000013
sys/termio.h:#define B300 0000007
sys/termio.h:#define B38400 0000017
sys/termio.h:#define B4800 0000014
sys/termio.h:#define B50 0000001
sys/termio.h:#define B600 0000010
sys/termio.h:#define B75 0000002
sys/termio.h:#define B9600 0000015
values.h:#define BITS(type) (BITSPERBYTE * (int)sizeof(type))
values.h:#define BITSPERBYTE 8
sys/termio.h:#define BRKINT 0000002
sys/termio.h:#define BS0 0
sys/termio.h:#define BS1 0020000
sys/termio.h:#define BSDLY 0020000
stdio.h:#define BUFSIZ ???? 1024
regexp.h:#define CBACK 36
sys/termio.h:#define CBAUD 0000017
regexp.h:#define CBRA 2
regexp.h:#define CCEOF 22
regexp.h:#define CCHR 4
regexp.h:#define CCL 12
sys/param.h:#define CDLIMIT (1L<<11) /* default max write address */
regexp.h:#define CDOL 20
regexp.h:#define CDOT 8
limits.h:#define CHAR_BIT 8 /* # of bits in a "char" */
limits.h:#define CHAR_MAX 255 /* max integer value of a "char" */
limits.h:#define CHAR_MIN 0 /* min integer value of a "char" */
limits.h:#define CHILD_MAX 25 /* max # of processes per user id */
regexp.h:#define CKET 24
limits.h:#define CLK_TCK 100 /* # of clock ticks per second */
sys/termio.h:#define CLOCAL 0004000
sys/termio.h:#define CR0 0
sys/termio.h:#define CR1 0001000
sys/termio.h:#define CR2 0002000
sys/termio.h:#define CR3 0003000
sys/termio.h:#define CRDLY 0003000
sys/termio.h:#define CREAD 0000200
sys/termio.h:#define CS5 0
sys/termio.h:#define CS6 0000020
sys/termio.h:#define CS7 0000040
sys/termio.h:#define CS8 0000060
sys/termio.h:#define CSIZE 0000060
sys/termio.h:#define CSTOPB 0000100
term.h:#define CUR cur_term->
term.h:#define CURB cur_bools->
term.h:#define CURN cur_nums->
term.h:#define CURS cur_strs->
regexp.h:#define CXCL 16
sys/jioctl.h:#define C_DEFUNCT 6 /* Send terminate signal to proc. group */
sys/jioctl.h:#define C_DELETE 4 /* Delete layer process group */
sys/jioctl.h:#define C_EXIT 5 /* Exit */
sys/jioctl.h:#define C_NEW 2 /* Create new layer process group */
sys/jioctl.h:#define C_RESHAPE 8 /* Layer has been reshaped */
sys/jioctl.h:#define C_RUN 9 /* Run command in layer */
sys/jioctl.h:#define C_SENDCHAR 1 /* Send character to layer process */
sys/jioctl.h:#define C_SENDNCHARS 7 /* Send several characters to layer proc. */
sys/jioctl.h:#define C_UNBLK 3 /* Unblock layer process */
limits.h:#define DBL_DIG 15 /* digits of precision of a "double" */
limits.h:#define DBL_MAX 1.79769313486231470e+308 /*max decimal value of a "double"*/
limits.h:#define DBL_MIN 4.94065645841246544e-324 /*min decimal value of a "double"*/
macros.h:#define DEBUG(variable,type) fprintf(stderr,"variable = %typen",variable)
strselect.h:#define DEFAULT } else WoRD(/)WoRD(*) WoRD(*)WoRD(/) {
sys/ioctl.h:#define DIOC ('d'<<8)
sys/ioctl.h:#define DIOCGETB (DIOC|2)
sys/ioctl.h:#define DIOCGETC (DIOC|1)
sys/ioctl.h:#define DIOCSETE (DIOC|3)
values.h:#define DMAXEXP ((1 << _DEXPLEN - 1) - 1 + _IEEE)
values.h:#define DMAXPOWTWO ((double)(1L << BITS(long) - 2) * 
DMINEXP	values.h:#define DMINEXP (-(DMAXEXP + DSIGNIF - _HIDDENBIT - 3))
values.h:#define DSIGNIF (BITS(double) - _DEXPLEN + _HIDDENBIT - 1)
sys/errno.h:#define E2BIG 7 /* Arg list too long */
sys/errno.h:#define EACCES 13 /* Permission denied */
sys/errno.h:#define EADV 68 /* advertise error */
sys/errno.h:#define EAGAIN 11 /* No more processes */
sys/errno.h:#define EBADE 50 /* invalid exchange */
sys/errno.h:#define EBADF 9 /* Bad file number */
sys/errno.h:#define EBADFD 81 /* f.d. invalid for this operation */
sys/errno.h:#define EBADMSG 77 /* trying to read unreadable message */
sys/errno.h:#define EBADR 51 /* invalid request descriptor */
sys/errno.h:#define EBADRQC 54 /* invalid request code */
sys/errno.h:#define EBADSLT 55 /* invalid slot */
sys/errno.h:#define EBFONT 57 /* bad font file fmt */
sys/errno.h:#define EBUSY 16 /* Mount device busy */
sys/errno.h:#define ECHILD 10 /* No children */
sys/termio.h:#define ECHO 0000010
sys/termio.h:#define ECHOE 0000020
sys/termio.h:#define ECHOK 0000040
sys/termio.h:#define ECHONL 0000100
sys/errno.h:#define ECHRNG 37 /* Channel number out of range */
sys/errno.h:#define ECOMM 70 /* Communication error on send */
sys/errno.h:#define EDEADLK 45 /* Deadlock condition. */
sys/errno.h:#define EDEADLOCK 56 /* file locking deadlock error */
sys/errno.h:#define EDOM 33 /* Math arg out of domain of func */
sys/errno.h:#define EDOTDOT 76 /* Cross mount point (not really error)*/
sys/errno.h:#define EEXIST 17 /* File exists */
sys/errno.h:#define EFAULT 14 /* Bad address */
sys/errno.h:#define EFBIG 27 /* File too large */
sys/errno.h:#define EIDRM 36 /* Identifier removed */
sys/errno.h:#define EINTR 4 /* interrupted system call */
sys/errno.h:#define EINVAL 22 /* Invalid argument */
sys/errno.h:#define EIO 5 /* I/O error */
sys/errno.h:#define EISDIR 21 /* Is a directory */
sys/errno.h:#define EL2HLT 44 /* Level 2 halted */
sys/errno.h:#define EL2NSYNC 38 /* Level 2 not synchronized */
sys/errno.h:#define EL3HLT 39 /* Level 3 halted */
sys/errno.h:#define EL3RST 40 /* Level 3 reset */
sys/errno.h:#define ELIBACC 83 /* Can't access a needed shared lib. */
sys/errno.h:#define ELIBBAD 84 /* Accessing a corrupted shared lib. */
sys/errno.h:#define ELIBEXEC 87 /* Attempting to exec a shared library. */
sys/errno.h:#define ELIBMAX 86 /* Attempting to link in too many libs. */
sys/errno.h:#define ELIBSCN 85 /* .lib section in a.out corrupted. */
sys/errno.h:#define ELNRNG 41 /* Link number out of range */
sys/errno.h:#define EMFILE 24 /* Too many open files */
sys/errno.h:#define EMLINK 31 /* Too many links */
sys/errno.h:#define EMULTIHOP 74 /* multihop attempted */
strselect.h:#define ENDSEL } WoRD(/)WoRD(*) WoRD(*)WoRD(/) }
sys/errno.h:#define ENFILE 23 /* File table overflow */
sys/errno.h:#define ENOANO 53 /* no anode */
sys/errno.h:#define ENOCSI 43 /* No CSI structure available */
sys/errno.h:#define ENODATA 61 /* no data (for no delay io) */
sys/errno.h:#define ENODEV 19 /* No such device */
sys/errno.h:#define ENOENT 2 /* No such file or directory */
sys/errno.h:#define ENOEXEC 8 /* Exec format error */
sys/errno.h:#define ENOLCK 46 /* No record locks available. */
sys/errno.h:#define ENOLINK 67 /* the link has been severed */
sys/errno.h:#define ENOMEM 12 /* Not enough core */
sys/errno.h:#define ENOMSG 35 /* No message of desired type */
sys/errno.h:#define ENONET 64 /* Machine is not on the network */
sys/errno.h:#define ENOPKG 65 /* Package not installed */
sys/errno.h:#define ENOSPC 28 /* No space left on device */
sys/errno.h:#define ENOSR 63 /* out of streams resources */
sys/errno.h:#define ENOSTR 60 /* Device not a stream */
sys/errno.h:#define ENOTBLK 15 /* Block device required */
sys/errno.h:#define ENOTDIR 20 /* Not a directory */
sys/errno.h:#define ENOTTY 25 /* Not a typewriter */
sys/errno.h:#define ENOTUNIQ 80 /* given log. name not unique */
sys/errno.h:#define ENXIO 6 /* No such device or address */
stdio.h:#define EOF (-1)
sys/errno.h:#define EPERM 1 /* Not super-user */
sys/errno.h:#define EPIPE 32 /* Broken pipe */
sys/errno.h:#define EPROTO 71 /* Protocol error */
sys/errno.h:#define ERANGE 34 /* Math result not representable */
sys/errno.h:#define EREMCHG 82 /* Remote address changed */
sys/errno.h:#define EREMOTE 66 /* The object is remote */
sys/errno.h:#define EROFS 30 /* Read only file system */
macros.h:#define ERRABORT() _error() { abort(); }
sys/errno.h:#define ESPIPE 29 /* Illegal seek */
sys/errno.h:#define ESRCH 3 /* No such process */
sys/errno.h:#define ESRMNT 69 /* srmount error */
sys/errno.h:#define ETIME 62 /* timer expired */
sys/errno.h:#define ETXTBSY 26 /* Text file busy */
sys/errno.h:#define EUNATCH 42 /* Protocol driver not attached */
sys/errno.h:#define EXDEV 18 /* Cross-device link */
sys/errno.h:#define EXFULL 52 /* exchange full */
sys/termio.h:#define EXTA 0000016
sys/termio.h:#define EXTB 0000017
sys/file.h:#define FAPPEND 0x08
limits.h:#define FCHR_MAX 1048576 /* max size of a file in bytes */
sys/file.h:#define FCREAT 0x100
ldfcn.h:#define FEOF(ldptr) feof(IOPTR(ldptr))
ldfcn.h:#define FERROR(ldptr) ferror(IOPTR(ldptr))
sys/file.h:#define FEXCL 0x400
sys/termio.h:#define FF0 0
sys/termio.h:#define FF1 0100000
sys/termio.h:#define FFDLY 0100000
ldfcn.h:#define FGETC(ldptr) fgetc(IOPTR(ldptr))
ldfcn.h:#define FGETS(s,n,ldptr) fgets(s,n,IOPTR(ldptr))
ldfcn.h:#define FILENO(ldptr) fileno(IOPTR(ldptr))
sgtty.h:#define FIOCLEX (('f'<<8)|1)
sgtty.h:#define FIONCLEX (('f'<<8)|2)
limits.h:#define FLT_DIG 7 /* digits of precision of a "float" */
limits.h:#define FLT_MAX 3.40282346638528860e+38 /*max decimal value of a "float" */
limits.h:#define FLT_MIN 1.40129846432481707e-45 /*min decimal value of a "float" */
sys/file.h:#define FMASK 0x7f /* FMASK should be disjoint from FNET */
values.h:#define FMAXEXP ((1 << _FEXPLEN - 1) - 1 + _IEEE)
values.h:#define FMAXPOWTWO ((float)(1L << FSIGNIF - 1))
values.h:#define FMINEXP (-(FMAXEXP + FSIGNIF - _HIDDENBIT - 3))
sys/file.h:#define FNDELAY 0x04
sys/file.h:#define FNET 0x80 /* needed by 3bnet */
sys/file.h:#define FOPEN 0xffffffff
ieeefp.h:#define FP_CLEAR 0 /* exception has not occurred */
ieeefp.h:#define FP_DISABLE 0 /* exception will be ignored */
ieeefp.h:#define FP_ENABLE 1 /* exception will cause SIGFPE */
ieeefp.h:#define FP_SET 1 /* exception has occurred */
ieeefp.h:#define FP_X_DZ 0x02 /* divide-by-zero exception */
ieeefp.h:#define FP_X_IMP 0x01 /* imprecise (loss of precision)*/
ieeefp.h:#define FP_X_INV 0x10 /* invalid operation exception */
ieeefp.h:#define FP_X_OFL 0x08 /* overflow exception */
ieeefp.h:#define FP_X_UFL 0x04 /* underflow exception */
sys/file.h:#define FRCACH 0x20 /* Used for file and record locking cache*/
ldfcn.h:#define FREAD(p,s,n,ldptr) fread(p,s,n,IOPTR(ldptr))
ldfcn.h:#define FSEEK(ldptr,o,p) fseek(IOPTR(ldptr),(p==BEGINNING)?(OFFSET(ldptr)+o):o,p)
values.h:#define FSIGNIF (BITS(float) - _FEXPLEN + _HIDDENBIT - 1)
sys/file.h:#define FSYNC 0x10
ldfcn.h:#define FTELL(ldptr) ftell(IOPTR(ldptr))
sys/file.h:#define FTRUNC 0x200
ftw.h:#define FTW_D 1 /* directory */
ftw.h:#define FTW_DNR 2 /* directory without read permission */
ftw.h:#define FTW_F 0 /* file */
ftw.h:#define FTW_NS 3 /* unknown type, stat failed */
ldfcn.h:#define FWRITE(p,s,n,ldptr) fwrite(p,s,n,IOPTR(ldptr))
sys/fcntl.h:#define F_ALLOCSP 10 /* reserved */
sys/fcntl.h:#define F_CHKFL 8 /* Check legality of file flag changes */
sys/fcntl.h:#define F_DUPFD 0 /* Duplicate fildes */
sys/fcntl.h:#define F_FREESP 11 /* reserved */
sys/fcntl.h:#define F_GETFD 1 /* Get fildes flags */
sys/fcntl.h:#define F_GETFL 3 /* Get file flags */
sys/fcntl.h:#define F_GETLK 5 /* Get file lock */
unistd.h:#define F_LOCK 1 /* Lock a region for exclusive use */
unistd.h:#define F_OK 0 /* Test for existence of File */
sys/fcntl.h:#define F_RDLCK 01
sys/fcntl.h:#define F_SETFD 2 /* Set fildes flags */
sys/fcntl.h:#define F_SETFL 4 /* Set file flags */
sys/fcntl.h:#define F_SETLK 6 /* Set file lock */
sys/fcntl.h:#define F_SETLKW 7 /* Set file lock and wait */
unistd.h:#define F_TEST 3 /* Test a region for other processes locks */
unistd.h:#define F_TLOCK 2 /* Test and lock a region for exclusive use */
unistd.h:#define F_ULOCK 0 /* Unlock a previously locked region */
sys/fcntl.h:#define F_UNLCK 03
sys/fcntl.h:#define F_WRLCK 02
libPW/xalloc.c:	extern char * Freeend;
ldfcn.h:#define GETC(ldptr) getc(IOPTR(ldptr))
nan.h:#define GETNaNPC(dval) (((dnan *)&(dval))->inf_parts.bits << 12 | 
GETW	ldfcn.h:#define GETW(ldptr) getw(IOPTR(ldptr))
values.h:#define HIBITI (1 << BITS(int) - 1)
values.h:#define HIBITL (1L << BITS(long) - 1)
values.h:#define HIBITS ((short)(1 << BITS(short) - 1))
math.h:#define HUGE MAXFLOAT
limits.h:#define HUGE_VAL 3.40282346638528860e+38 /*error value returned by Math lib*/
sys/termio.h:#define HUPCL 0002000
sys/param.h:#define HZ 100 /* 100 ticks/second of the clock */
values.h:#define H_PREC (DSIGNIF % 2 ? (1L << DSIGNIF/2) * M_SQRT2 : 1L << DSIGNIF/2)
sys/termio.h:#define ICANON 0000002
sys/termio.h:#define ICRNL 0000400
sys/termio.h:#define IGNBRK 0000001
sys/termio.h:#define IGNCR 0000200
sys/termio.h:#define IGNPAR 0000004
sys/flock.h:#define IGN_PID 2 /* ignore epid when cleaning locks */
sys/termio.h:#define INLCR 0000100
sys/flock.h:#define INOFLCK 1 /* Inode is locked when reclock() is called. */
sys/termio.h:#define INPCK 0000020
term.h:#define INP_QSIZE 32
limits.h:#define INT_MAX 2147483647 /* max decimal value of an "int" */
limits.h:#define INT_MIN -2147483648 /* min decimal value of an "int" */
sys/ipc.h:#define IPC_ALLOC 0100000 /* entry currently allocated */
sys/ipc.h:#define IPC_CREAT 0001000 /* create entry if key doesn't exist */
sys/ipc.h:#define IPC_EXCL 0002000 /* fail if key exists */
sys/ipc.h:#define IPC_NOWAIT 0004000 /* error if request must wait */
sys/ipc.h:#define IPC_PRIVATE (key_t)0 /* private key */
sys/ipc.h:/* #define IPC_RMID 0 /* remove identifier */
sys/ipc.h:#define IPC_SET 1 /* set options */
sys/ipc.h:#define IPC_STAT 2 /* get options */
sys/termio.h:#define ISIG 0000001
regexp.h:#define ISTHERE(c) (ep[c >> 3] & bittab[c & 07])
sys/termio.h:#define ISTRIP 0000040
sys/termio.h:#define IUCLC 0001000
sys/termio.h:#define IXANY 0004000
sys/termio.h:#define IXOFF 0010000
sys/termio.h:#define IXON 0002000
nan.h:#define IsINF(X) (((dnan *)&(X))->inf_parts.bits == 0 && 
IsNAN	nan.h:#define IsNAN(X) 0
nan.h:#define IsNANorINF(X) (((dnan *)&(X))->nan_parts.exponent == 0x7ff)
nan.h:#define IsNegNAN(X) (((dnan *)&(X))->nan_parts.sign == 1)
nan.h:#define IsPINF(X) 0
nan.h:#define IsPosNAN(X) (((dnan *)&(X))->nan_parts.sign == 0)
sys/jioctl.h:#define JAGENT (JTYPE|9) /* control for both directions */
sys/jioctl.h:#define JBOOT (JTYPE|1)
sys/jioctl.h:#define JMPX (JTYPE|3)
sys/jioctl.h:#define JTERM (JTYPE|2)
sys/jioctl.h:#define JTIMO (JTYPE|4) /* Timeouts in seconds */
sys/jioctl.h:#define JTIMOM (JTYPE|6) /* Timeouts in millisecs */
sys/jioctl.h:#define JTRUN (JTYPE|10) /* send runlayer command to layers*/
sys/jioctl.h:#define JTYPE ('j'<<8)
sys/jioctl.h:#define JWINSIZE (JTYPE|5)
sys/jioctl.h:#define JZOMBOOT (JTYPE|7)
curses.h:#define KEY_A1 0534 /* Upper left of keypad */
curses.h:#define KEY_A3 0535 /* Upper right of keypad */
curses.h:#define KEY_B2 0536 /* Center of keypad */
curses.h:#define KEY_BACKSPACE 0407 /* Sent by backspace key */
curses.h:#define KEY_BEG 0542 /* beg(inning) key */
curses.h:#define KEY_BREAK 0401 /* break key (unreliable) */
curses.h:#define KEY_BTAB 0541 /* Back tab key */
curses.h:#define KEY_C1 0537 /* Lower left of keypad */
curses.h:#define KEY_C3 0540 /* Lower right of keypad */
curses.h:#define KEY_CANCEL 0543 /* cancel key */
curses.h:#define KEY_CATAB 0526 /* Sent by clear-all-tabs key. */
curses.h:#define KEY_CLEAR 0515 /* Sent by clear screen or erase key. */
curses.h:#define KEY_CLOSE 0544 /* close key */
curses.h:#define KEY_COMMAND 0545 /* cmd (command) key */
curses.h:#define KEY_COPY 0546 /* copy key */
curses.h:#define KEY_CREATE 0547 /* create key */
curses.h:#define KEY_CTAB 0525 /* Sent by clear-tab key */
curses.h:#define KEY_DC 0512 /* Sent by delete character key. */
curses.h:#define KEY_DL 0510 /* Sent by delete line key. */
curses.h:#define KEY_DOWN 0402 /* Sent by terminal down arrow key */
curses.h:#define KEY_EIC 0514 /* Sent by rmir or smir in insert mode. */
curses.h:#define KEY_END 0550 /* end key */
curses.h:#define KEY_ENTER 0527 /* Enter/send (unreliable) */
curses.h:#define KEY_EOL 0517 /* Sent by clear-to-end-of-line key. */
curses.h:#define KEY_EOS 0516 /* Sent by clear-to-end-of-screen key. */
curses.h:#define KEY_EXIT 0551 /* exit key */
curses.h:#define KEY_F(n) (KEY_F0+(n)) /* Space for 64 function keys is reserved. */
curses.h:#define KEY_F0 0410 /* function key f0. */
curses.h:#define KEY_FIND 0552 /* find key */
curses.h:#define KEY_HELP 0553 /* help key */
curses.h:#define KEY_HOME 0406 /* Sent by home key. */
curses.h:#define KEY_IC 0513 /* Sent by ins char/enter ins mode key. */
curses.h:#define KEY_IL 0511 /* Sent by insert line. */
curses.h:#define KEY_LEFT 0404 /* Sent by terminal left arrow key */
curses.h:#define KEY_LL 0533 /* Sent by home-down key */
curses.h:#define KEY_MARK 0554 /* mark key */
curses.h:#define KEY_MAX 0777 /* Maximum curses key */
curses.h:#define KEY_MESSAGE 0555 /* message key */
curses.h:#define KEY_MIN 0401 /* Minimum curses key */
curses.h:#define KEY_MOVE 0556 /* move key */
curses.h:#define KEY_NEXT 0557 /* next object key */
curses.h:#define KEY_NPAGE 0522 /* Sent by next-page key */
curses.h:#define KEY_OPEN 0560 /* open key */
curses.h:#define KEY_OPTIONS 0561 /* options key */
curses.h:#define KEY_PPAGE 0523 /* Sent by previous-page key */
curses.h:#define KEY_PREVIOUS 0562 /* previous object key */
curses.h:#define KEY_PRINT 0532 /* print or copy */
curses.h:#define KEY_REDO 0563 /* redo key */
curses.h:#define KEY_REFERENCE 0564 /* ref(erence) key */
curses.h:#define KEY_REFRESH 0565 /* refresh key */
curses.h:#define KEY_REPLACE 0566 /* replace key */
curses.h:#define KEY_RESET 0531 /* reset or hard reset (unreliable) */
curses.h:#define KEY_RESTART 0567 /* restart key */
curses.h:#define KEY_RESUME 0570 /* resume key */
curses.h:#define KEY_RIGHT 0405 /* Sent by terminal right arrow key */
curses.h:#define KEY_SAVE 0571 /* save key */
curses.h:#define KEY_SBEG 0572 /* shifted beginning key */
curses.h:#define KEY_SCANCEL 0573 /* shifted cancel key */
curses.h:#define KEY_SCOMMAND 0574 /* shifted command key */
curses.h:#define KEY_SCOPY 0575 /* shifted copy key */
curses.h:#define KEY_SCREATE 0576 /* shifted create key */
curses.h:#define KEY_SDC 0577 /* shifted delete char key */
curses.h:#define KEY_SDL 0600 /* shifted delete line key */
curses.h:#define KEY_SELECT 0601 /* select key */
curses.h:#define KEY_SEND 0602 /* shifted end key */
curses.h:#define KEY_SEOL 0603 /* shifted clear line key */
curses.h:#define KEY_SEXIT 0604 /* shifted exit key */
curses.h:#define KEY_SF 0520 /* Sent by scroll-forward/down key */
curses.h:#define KEY_SFIND 0605 /* shifted find key */
curses.h:#define KEY_SHELP 0606 /* shifted help key */
curses.h:#define KEY_SHOME 0607 /* shifted home key */
curses.h:#define KEY_SIC 0610 /* shifted input key */
curses.h:#define KEY_SLEFT 0611 /* shifted left arrow key */
curses.h:#define KEY_SMESSAGE 0612 /* shifted message key */
curses.h:#define KEY_SMOVE 0613 /* shifted move key */
curses.h:#define KEY_SNEXT 0614 /* shifted next key */
curses.h:#define KEY_SOPTIONS 0615 /* shifted options key */
curses.h:#define KEY_SPREVIOUS 0616 /* shifted prev key */
curses.h:#define KEY_SPRINT 0617 /* shifted print key */
curses.h:#define KEY_SR 0521 /* Sent by scroll-backward/up key */
curses.h:#define KEY_SREDO 0620 /* shifted redo key */
curses.h:#define KEY_SREPLACE 0621 /* shifted replace key */
curses.h:#define KEY_SRESET 0530 /* soft (partial) reset (unreliable) */
curses.h:#define KEY_SRIGHT 0622 /* shifted right arrow */
curses.h:#define KEY_SRSUME 0623 /* shifted resume key */
curses.h:#define KEY_SSAVE 0624 /* shifted save key */
curses.h:#define KEY_SSUSPEND 0625 /* shifted suspend key */
curses.h:#define KEY_STAB 0524 /* Sent by set-tab key */
curses.h:#define KEY_SUNDO 0626 /* shifted undo key */
curses.h:#define KEY_SUSPEND 0627 /* suspend key */
curses.h:#define KEY_UNDO 0630 /* undo key */
curses.h:#define KEY_UP 0403 /* Sent by terminal up arrow key */
nan.h:#define KILLFPE() (void) kill(getpid(), 8)
nan.h:#define KILLNaN(X) if (NaN(X)) KILLFPE()
sys/termio.h:#define LDCHG (LDIOC|2)
sys/termio.h:#define LDCLOSE (LDIOC|1)
sys/termio.h:#define LDGETT (LDIOC|8)
sys/termio.h:#define LDIOC ('D'<<8)
sys/termio.h:#define LDOPEN (LDIOC|0)
sys/termio.h:#define LDSETT (LDIOC|9)
limits.h:#define LINK_MAX 1000 /* max # of links to a single file */
sys/ioctl.h:#define LIOC ('l'<<8)
sys/ioctl.h:#define LIOCGETP (LIOC|1)
sys/ioctl.h:#define LIOCGETS (LIOC|5)
sys/ioctl.h:#define LIOCSETP (LIOC|2)
sys/ioctl.h:#define LIOCSETS (LIOC|6)
values.h:#define LN_MAXDOUBLE (M_LN2 * DMAXEXP)
values.h:#define LN_MINDOUBLE (M_LN2 * (DMINEXP - 1))
sys/termio.h:#define LOBLK 0040000
limits.h:#define LONG_MAX 2147483647 /* max decimal value of a "long" */
limits.h:#define LONG_MIN -2147483648 /* min decimal value of a "long" */
stdio.h:#define L_ctermid 9
stdio.h:#define L_cuserid 9
stdio.h:#define L_tmpnam (sizeof(P_tmpdir) + 15)
libPW/xalloc.c:	extern unsigned Lastbrk;
values.h:#define MAXBEXP DMAXEXP /* for backward compatibility */
values.h:#define MAXDOUBLE ???? 1.79769313486231470e+308
values.h:#define MAXFLOAT ???? ((float)1.701411733192644299e+38)
values.h:#define MAXINT (~HIBITI)
sys/param.h:#define MAXLINK 1000 /* max links */
values.h:#define MAXLONG (~HIBITL)
sys/param.h:#define MAXPID 30000 /* max process id */
values.h:#define MAXPOWTWO DMAXPOWTWO /* for backward compatibility */
values.h:#define MAXSHORT ((short)~HIBITS)
sys/signal.h:#define MAXSIG 32 /* size of u_signal[], NSIG-1 <= MAXSIG*/
sys/param.h:#define MAXUID 60000 /* max user id */
values.h:#define MINBEXP DMINEXP /* for backward compatibility */
values.h:#define MINDOUBLE ???? (0.01 * 2.938735877055718770e-37)
values.h:#define MINFLOAT ???? ((float)1.40129846432481707e-45)
math.h:#define M_1_PI 0.31830988618379067154
math.h:#define M_2_PI 0.63661977236758134308
math.h:#define M_2_SQRTPI 1.12837916709551257390
math.h:#define M_E 2.7182818284590452354
malloc.h:#define M_GRAIN 3 /* set number of sizes mapped to one, for
malloc.h:#define M_KEEP 4 /* retain contents of block after a free until
math.h:#define M_LN10 2.30258509299404568402
values.h:#define M_LN2 0.69314718055994530942
math.h:#define M_LOG10E 0.43429448190325182765
math.h:#define M_LOG2E 1.4426950408889634074
malloc.h:#define M_MXFAST 1 /* set size of blocks to be fast */
malloc.h:#define M_NLBLKS 2 /* set number of block in a holding block */
values.h:#define M_PI 3.14159265358979323846
math.h:#define M_PI_2 1.57079632679489661923
math.h:#define M_PI_4 0.78539816339744830962
math.h:#define M_SQRT1_2 0.70710678118654752440
values.h:#define M_SQRT2 1.41421356237309504880
limits.h:#define NAME_MAX 14 /* max # of characters in a file name */
regexp.h:#define NBRA 9
sys/param.h:#define NCARGS 5120 /* # characters in exec arglist */
sys/termio.h:#define NCC 8
regexp.h:#define NCCL 40
sys/termio.h:#define NL0 0
sys/termio.h:#define NL1 0000400
sys/termio.h:#define NLDLY 0000400
sys/param.h:#define NOFILE 20
sys/param.h:#define NOFILES_MAX 100
sys/param.h:#define NOFILES_MIN 20
sys/termio.h:#define NOFLSH 0000200
macros.h:#define NONBLANK(p) while (*p==' ' || *p=='t') p++
sys/signal.h:#define NSIG 23 /* The valid signal number is from 1 to NSIG-1 */
stdio.h:#define NULL 0
sys/param.h:#define NZERO 20
nan.h:#define NaN(X) (((dnan *)&(X))->nan_parts.exponent == 0x7ff)
sys/termio.h:#define OCRNL 0000010
sys/termio.h:#define OFDEL 0000200
sys/termio.h:#define OFILL 0000100
sys/termio.h:#define OLCUC 0000002
sys/termio.h:#define ONLCR 0000004
sys/termio.h:#define ONLRET 0000040
sys/termio.h:#define ONOCR 0000020
limits.h:#define OPEN_MAX 20 /* max # of files a process can have open */
sys/termio.h:#define OPOST 0000001
sys/fcntl.h:#define O_APPEND 010 /* append (writes guaranteed at the end) */
sys/fcntl.h:#define O_CREAT 00400 /* open with file create (uses third open arg)*/
sys/fcntl.h:#define O_EXCL 02000 /* exclusive open */
sys/fcntl.h:#define O_NDELAY 04 /* Non-blocking I/O */
sys/fcntl.h:#define O_RDONLY 0
sys/fcntl.h:#define O_RDWR 2
sys/fcntl.h:#define O_SYNC 020 /* synchronous write option */
sys/fcntl.h:#define O_TRUNC 01000 /* open with truncation */
sys/fcntl.h:#define O_WRONLY 1
ieeefp.h:#define P754_NOFAULT 1
sys/termio.h:#define PARENB 0000400
sys/termio.h:#define PARMRK 0000010
sys/termio.h:#define PARODD 0001000
limits.h:#define PASS_MAX 8 /* max # of characters in a password */
limits.h:#define PATH_MAX 256 /* max # of characters in a path name */
sys/param.h:#define PCATCH 0400
sys/param.h:#define PIDLE 127
limits.h:#define PID_MAX 30000 /* max value for a process ID */
sys/param.h:#define PINOD 10
limits.h:#define PIPE_BUF 5120 /* max # bytes atomic in write to a pipe */
limits.h:#define PIPE_MAX 5120 /* max # bytes written to a pipe in a write */
regexp.h:#define PLACE(c) ep[c >> 3] |= bittab[c & 07]
sys/param.h:#define PMASK 0177
sys/param.h:#define PMEM 0
sys/param.h:#define PNOSTOP 01000
sys/param.h:#define PPIPE 26
sys/param.h:#define PRIBIO 20
term.h:#define PROGTTY (cur_term->Nttyb)
sys/param.h:#define PSLEP 39
sys/param.h:#define PSWP 0
sys/param.h:#define PUSER 60
sys/param.h:#define PWAIT 30
sys/param.h:#define PZERO 25
stdio.h:#define P_tmpdir "/usr/tmp/"
sys/termio.h:#define RCV1EN 0010000
ldfcn.h:#define REWIND(ldptr) rewind(IOPTR(ldptr))
regexp.h:#define RNGE 03
macros.h:#define RSTR(name,place) name = place;}
unistd.h:#define R_OK 4 /* Test for Read permission */
macros.h:#define SAVE(name,place) { int place = name;
macros.h:#define SCCSID(arg) static char Sccsid[]="arg"
sys/clock.h:#define SECDAY (24*SECHR) /* seconds/day */
sys/clock.h:#define SECHR (60*60) /* seconds/hr */
sys/clock.h:#define SECYR (365*SECDAY) /* seconds/common year */
unistd.h:#define SEEK_CUR 1 /* Set file pointer to current plus "offset" */
unistd.h:#define SEEK_END 2 /* Set file pointer to EOF plus "offset" */
unistd.h:#define SEEK_SET 0 /* Set file pointer to "offset" */
ldfcn.h:#define SETBUF(ldptr,b) setbuf(IOPTR(ldptr),b)
sys/flock.h:#define SETFLCK 2 /* Set a file lock. */
term.h:#define SHELLTTY (cur_term->Ottyb)
limits.h:#define SHRT_MAX 32767 /* max decimal value of a "short" */
limits.h:#define SHRT_MIN -32768 /* min decimal value of a "short" */
sys/signal.h:#define SIGABRT 6 /* used by abort, replace SIGIOT in the future */
sys/signal.h:#define SIGALRM 14 /* alarm clock */
sys/signal.h:#define SIGBUS 10 /* bus error */
sys/signal.h:#define SIGCLD 18 /* death of a child */
sys/signal.h:#define SIGDEFER 0x100
sys/signal.h:#define SIGEMT 7 /* EMT instruction */
sys/signal.h:#define SIGFPE 8 /* floating point exception */
sys/signal.h:#define SIGHOLD 0x200
sys/signal.h:#define SIGHUP 1 /* hangup */
sys/signal.h:#define SIGIGNORE 0x800
sys/signal.h:#define SIGILL 4 /* illegal instruction (not reset when caught)*/
sys/signal.h:#define SIGINT 2 /* interrupt (rubout) */
sys/signal.h:#define SIGIOT 6 /* IOT instruction */
sys/signal.h:#define SIGKILL 9 /* kill (cannot be caught or ignored) */
sys/signal.h:#define SIGPAUSE 0x1000
sys/signal.h:#define SIGPHONE 21*/ /* handset, line status change */
sys/signal.h:#define SIGPIPE 13 /* write on a pipe with no one to read it */
sys/signal.h:#define SIGPOLL 22 /* pollable event occured */
sys/signal.h:#define SIGPWR 19 /* power-fail restart */
sys/signal.h:#define SIGQUIT 3 /* quit (ASCII FS) */
sys/signal.h:#define SIGRELSE 0x400
sys/signal.h:#define SIGSEGV 11 /* segmentation violation */
sys/signal.h:#define SIGSYS 12 /* bad argument to system call */
sys/signal.h:#define SIGTERM 15 /* software termination signal from kill */
sys/signal.h:#define SIGTRAP 5 /* trace trap (not reset when caught) */
sys/signal.h:#define SIGUSR1 16 /* user defined signal 1 */
sys/signal.h:#define SIGUSR2 17 /* user defined signal 2 */
sys/signal.h:#define SIGWIND 20*/ /* window change */
sys/signal.h:#define SIG_DFL (void(*)())0
sys/signal.h:#define SIG_ERR (void(*)())-1
sys/signal.h:#define SIG_HOLD (void(*)())2
sys/signal.h:#define SIG_IGN (void (*)())1
sys/flock.h:#define SLPFLCK 4 /* Wait if blocked. */
sys/termio.h:#define SSPEED 7 /* default speed: 300 baud */
regexp.h:#define STAR 01
limits.h:#define STD_BLK 1024 /* # bytes in a physical I/O block */
ldfcn.h:#define STROFFSET(ldptr) (HEADER(ldptr).f_symptr + HEADER(ldptr).f_nsyms * 18) /* 18 == SYMESZ */
strselect.h:#define STRSELECT(a) { char *STRSeLeCT; STRSeLeCT = a; WoRD(/)WoRD(*)
limits.h:#define SYS_NMLN 9 /* # of chars in uname-returned strings */
sys/stat.h:#define S_ENFMT S_ISGID /* record locking enforcement flag */
sys/stat.h:#define S_IEXEC 00100 /* execute/search permission, owner */
sys/stat.h:#define S_IFBLK 0060000 /* block special */
sys/stat.h:#define S_IFCHR 0020000 /* character special */
sys/stat.h:#define S_IFDIR 0040000 /* directory */
sys/stat.h:#define S_IFIFO 0010000 /* fifo */
sys/stat.h:#define S_IFMT 0170000 /* type of file */
sys/stat.h:#define S_IFREG 0100000 /* regular */
sys/stat.h:#define S_IREAD 00400 /* read permission, owner */
sys/stat.h:#define S_IRGRP 00040 /* read permission: group */
sys/stat.h:#define S_IROTH 00004 /* read permission: other */
sys/stat.h:#define S_IRUSR 00400 /* read permission: owner */
sys/stat.h:#define S_IRWXG 00070 /* read, write, execute: group */
sys/stat.h:#define S_IRWXO 00007 /* read, write, execute: other */
sys/stat.h:#define S_IRWXU 00700 /* read, write, execute: owner */
sys/stat.h:#define S_ISGID 02000 /* set group id on execution */
sys/stat.h:#define S_ISUID 04000 /* set user id on execution */
sys/stat.h:#define S_ISVTX 01000 /* save swapped text even after use */
sys/stat.h:#define S_IWGRP 00020 /* write permission: group */
sys/stat.h:#define S_IWOTH 00002 /* write permission: other */
sys/stat.h:#define S_IWRITE 00200 /* write permission, owner */
sys/stat.h:#define S_IWUSR 00200 /* write permission: owner */
sys/stat.h:#define S_IXGRP 00010 /* execute permission: group */
sys/stat.h:#define S_IXOTH 00001 /* execute permission: other */
sys/stat.h:#define S_IXUSR 00100 /* execute permission: owner */
sys/termio.h:#define TAB0 0
sys/termio.h:#define TAB1 0004000
sys/termio.h:#define TAB2 0010000
sys/termio.h:#define TAB3 0014000
sys/termio.h:#define TABDLY 0014000
sys/termio.h:#define TCDSET (TIOC|32)
sys/termio.h:#define TCFLSH (TIOC|7)
sys/termio.h:#define TCGETA (TIOC|1)
sys/termio.h:#define TCSBRK (TIOC|5)
sys/termio.h:#define TCSETA (TIOC|2)
sys/termio.h:#define TCSETAF (TIOC|4)
sys/termio.h:#define TCSETAW (TIOC|3)
sys/termio.h:#define TCXONC (TIOC|6)
sys/termio.h:#define TERM_D40 5 /* TTY Mod 40/1 */
sys/termio.h:#define TERM_D42 7 /* TTY Mod 40/2B */
sys/termio.h:#define TERM_H45 6 /* Hewlitt-Packard 45 */
sys/termio.h:#define TERM_NONE 0 /* tty */
sys/termio.h:#define TERM_TEC 1 /* TEC Scope */
sys/termio.h:#define TERM_TEX 4 /* Tektronix 4023 */
sys/termio.h:#define TERM_V10 3 /* DEC VT100 */
sys/termio.h:#define TERM_V61 2 /* DEC VT61 */
sys/termio.h:#define TIOC ('T'<<8)
sgtty.h:#define TIOCEXCL (('t'<<8)|13)
sgtty.h:#define TIOCGETP (('t'<<8)|8)
sgtty.h:#define TIOCHPCL (('t'<<8)|2)
sgtty.h:#define TIOCNXCL (('t'<<8)|14)
sgtty.h:#define TIOCSETP (('t'<<8)|9)
sys/termio.h:#define TM_ANL 0002 /* auto newline on column 80 */
sys/termio.h:#define TM_CECHO 0010 /* echo terminal cursor control */
sys/termio.h:#define TM_CINVIS 0020 /* do not send esc seq to user */
sys/termio.h:#define TM_LCF 0004 /* last col of last row special */
sys/termio.h:#define TM_NONE 0000 /* use default flags */
sys/termio.h:#define TM_SET 0200 /* must be on to set/res flags */
sys/termio.h:#define TM_SNL 0001 /* special newline flag */
sys/termio.h:#define TTYTYPE (TIOC|8)
limits.h:#define UID_MAX 60000 /* max value for a user or group ID */
ldfcn.h:#define UNGETC(c,ldptr) ungetc(c,IOPTR(ldptr))
sys/flock.h:#define USE_PID 1 /* use epid when cleaning locks */
limits.h:#define USI_MAX 4294967295 /* max decimal value of an "unsigned" */
macros.h:#define USXALLOC() char *alloc(n) {return((char *)xalloc((unsigned)n));} free(n) char *n; {xfree(n);} char *malloc(n) unsigned n; {int p; p=xalloc(n); return((char *)(p != -1?p:0));}
sys/termio.h:#define VEOF 4
sys/termio.h:#define VEOL 5
sys/termio.h:#define VEOL2 6
sys/termio.h:#define VERASE 2
sys/termio.h:#define VINTR 0
sys/termio.h:#define VKILL 3
sys/termio.h:#define VMIN 4
sys/termio.h:#define VQUIT 1
sys/termio.h:#define VSWTCH 7
sys/termio.h:#define VT0 0
sys/termio.h:#define VT1 0040000
sys/termio.h:#define VTDLY 0040000
sys/termio.h:#define VTIME 5
strselect.h:#define WHEN(a) } else WoRD(/)WoRD(*) WoRD(*)WoRD(/) 
WHEN2	strselect.h:#define WHEN2(a1,a2) } else WoRD(/)WoRD(*) WoRD(*)WoRD(/)
WHEN3	strselect.h:#define WHEN3(a1,a2,a3) } else WoRD(/)WoRD(*) WoRD(*)WoRD(/)
WHENN	strselect.h:#define WHENN(a) } else WoRD(/)WoRD(*) WoRD(*)WoRD(/)
WHENN2	strselect.h:#define WHENN2(a1,a2) } else WoRD(/)WoRD(*) WoRD(*)WoRD(/)
WHENN3	strselect.h:#define WHENN3(a1,a2,a3) } else WoRD(/)WoRD(*) WoRD(*)WoRD(/)
WORD_BIT	limits.h:#define WORD_BIT 32 /* # of bits in a "word" or "int" */
unistd.h:#define W_OK 2 /* Test for Write permission */
strselect.h:#define WoRD(x)x
sys/termio.h:#define XCASE 0000004
sys/termio.h:#define XMT1EN 0020000
values.h:#define X_EPS (1.0/H_PREC)
unistd.h:#define X_OK 1 /* Test for eXecute permission */
values.h:#define X_PLOSS ((double)(long)(M_PI * H_PREC))
values.h:#define X_TLOSS (M_PI * DMAXPOWTWO)
ctype.h:#define _B 0100 /* Blank */
ctype.h:#define _C 040 /* Control character */
values.h:#define _DEXPLEN 11
values.h:#define _HIDDENBIT 1
values.h:#define _IEEE 1
stdio.h:#define _IOFBF 0000
stdio.h:#define _IOLBF 0100
stdio.h:#define _IONBF 0004
ctype.h:#define _L 02 /* Lower case */
ctype.h:#define _N 04 /* Numeral (digit) */
stdio.h:#define _NFILE 20
ctype.h:#define _P 020 /* Punctuation */
ctype.h:#define _S 010 /* Spacing character */
curses.h:#define _STANDOUT A_STANDOUT /* for compatability with old curses */
ctype.h:#define _U 01 /* Upper case */
ctype.h:#define _X 0200 /* heXadecimal digit */
libPW/regex.c:	int __advance (lp, ep) char *lp, *ep; { int ret; return ret; }
libPW/regex.c:	int __cclass (set, ac, af) char *set; { int ret; return ret; }
libPW/regex.c:	int __execute (addrc,addrl) char *addrc,*addrl; { int ret; return ret; }
libPW/regex.c:	int __getrnge (i,j,k) int *i,*j; char *k; { int ret; return ret; }
libPW/regcmp.c:	int __rpop () { int ret; return ret; }
libPW/regcmp.c:	int __rpush (ptr) char *ptr; { int ret; return ret; }
libPW/regcmp.c:	int __size (strg) char *strg; { int ret; return ret; }
libPW/regex.c:	int __xpop (i) int i; { int ret; return ret; }
libPW/regex.c:	int __xpush (i,p) int i; char *p; { int ret; return ret; }
libc ASSERT(3X):	void _assert (a, f, n) char *a, *f; {}
stdio.h:#define _bufend(p) _bufendtab[(p)->_file]
libc STDIO(3S):	extern unsigned char *_bufendtab[_NFILE];
stdio.h:#define _bufsiz(p) (_bufend(p) - (p)->_base)
libc CTYPE(3C):	char _ctype [129];
libc EXIT(2):	void _exit (s) {}
libc VPRINTF(3S):	int _filbuf (f) FILE *f; { return (0); }
libc VPRINTF(3S):	int _flsbuf (c, f) FILE *f; { return (c); }
libc STDIO(3S):	extern FILE _iob[_NFILE];
libc CONV(3C):ctype.h:#define _tolower(c) ((_ctype + 258)[c])
libc CONV(3C):ctype.h:#define _toupper(c) ((_ctype + 258)[c])
libc A64L(3C):	long a64l (s) char *s; { return (0L); }
libc ABORT(3C):	int abort () { return (0); }
libc ABS(3C):	int abs (i) { return (i); }
libPW/abspath.c:	char * abspath (p) char *p; { char *ret; return ret; }
libc ACCESS(2):	int access (f, m) char *f; { return (m); }
libc ACCT(2):	int acct (f) char *f; { return (0); }
libm TRIG(3M):	double acos (x) double x; { return (x); }
term.h:#define acs_chars CURS strs2._acs_chars
curses.h:#define addch(ch) waddch(stdscr, ch)
curses.h:#define addchnstr(str,n) waddchnstr(stdscr,str,n)
curses.h:#define addchstr(str) waddchstr(stdscr,str)
curses.h:#define addnstr(s,n) waddnstr(stdscr,s,n)
curses.h:#define addstr(str) waddstr(stdscr, str)
libc ALARM(2):	unsigned alarm (s) unsigned s; { return (s); }
libld/allocldptr.c:	LDFILE * allocldptr () { LDFILE *ret; return ret; }
libl/allprint.c:	int allprint (c) char c; { int ret; return ret; }
libPW/any.c:	int any (c,s) char c, *s; { int ret; return ret; }
libPW/anystr.c:	int anystr (s1, s2) char *s1, *s2; { int ret; return ret; }
libplot/arc.c:	int arc (xi,yi,x0,y0,x1,y1) { int ret; return ret; }
libc CTIME(3C):	char * asctime (t) struct tm *t; { return (""); }
libm TRIG(3M):	double asin (x) double x; { return (x); }
assert.h:#define assert(EX) if (EX) ; else _assert("EX", __FILE__, __LINE__)
libm TRIG(3M):	double atan (x) double x; { return (x); }
libm TRIG(3M):	double atan2 (x, y) double x, y; { return (x); }
libc STRTOD(3C):	double atof (s) char *s; { return (0.0); }
libc STRTOL(3C):	int atoi (s) char *s; { return (0); }
libc STRTOL(3C):	long atol (s) char *s; { return (0L); }
curses.h:#define attroff(at) wattroff(stdscr,at)
curses.h:#define attron(at) wattron(stdscr,at)
curses.h:#define attrset(at) wattrset(stdscr,at)
term.h:#define auto_left_margin CUR _b1
term.h:#define auto_right_margin CUR _b2
term.h:#define back_tab CUR _Vr2_Astrs._s1
libPW/bal.c:	int balbrk (str,open,clos,end) char *str,*open,*clos,*end; { int ret; return ret; }
libcurses/baudrate.c:	int baudrate () { int ret; return ret; }
term.h:#define beehive_glitch no_esc_ctlc
curses.h:libcurses/beep.c:	int beep () { int ret; return ret; }
term.h:#define bell CUR _Vr2_Astrs._s2
curses.h:#define bkgd(c) wbkgd(stdscr,c)
curses.h:#define bkgdset(c) wbkgdset(stdscr,c)
curses.h:#define border(lc,rc,tc,bc) wborder(stdscr,lc,rc,tc,bc)
curses.h, libplot/box.c:int box (win, vert, hor) WINDOW *win; chtype vert, hor; { int ret; return ret; }, int box (x0, y0, x1, y1) { int ret; return ret; }
libc BRK(2):	int brk (e) char *e; { return (0); }
libc BSEARCH(3C):	char * bsearch (k, b, n, w, c) char *k, *b; unsigned n, w; int (*c)(); { return (k); }
libc MALLOC(3C):	char * calloc (n, e) unsigned n, e; { return (""); }
term.h:#define carriage_return CUR _Vr2_Astrs._s3
libPW/cat.c:	/* VARARGS1 */ char * cat (dest) char *dest; { char *ret; return ret; }
libcurses/cbreak.c:	int cbreak () { int ret; return ret; }
libm FLOOR(3M):	double ceil (x) double x; { return (x); }
term.h:#define ceol_standout_glitch CUR _b4
term.h:#define change_scroll_region CUR _Vr2_Astrs._s4
term.h:#define char_padding CURS strs2._char_padding
libc CHDIR(2):	int chdir (s) char *s; { return (0); }
libc CHMOD(2):	int chmod (s, m) char *s; { return (m); }
libc CHOWN(2):	int chown (s, o, g) char *s; { return (o); }
libc CHROOT(2):	int chroot (p) char *p; { return (0); }
libplot/circle.c:	int circle (x,y,r) { int ret; return ret; }
libPW/clean.c:	int clean_up () { int ret; return ret; }
curses.h:#define clear() wclear(stdscr)
term.h:#define clear_all_tabs CUR _Vr2_Astrs._s5
term.h:#define clear_margins CURS strs3._clear_margins
term.h:#define clear_screen CUR _Vr2_Astrs._s6
stdio.h:libc FERROR(3S):	void clearerr (f) FILE *f; {}
curses.h:libcurses/clearok.c:	int clearok (win,bf) WINDOW *win; int bf; { int ret; return ret; }
libc CLOCK(3C):	long clock () { return (0L); }
libc CLOSE(2):	int close (f) { return (f); }
libplot/close.c:	int closepl () { int ret; return ret; }
libplot/close.c:	int closevt () { int ret; return ret; }
term.h:#define clr_bol CURS strs3._clr_bol
term.h:#define clr_eol CUR _Vr2_Astrs._s7
term.h:#define clr_eos CUR _Vr2_Astrs._s8
curses.h:#define clrtobot() wclrtobot(stdscr)
curses.h:#define clrtoeol() wclrtoeol(stdscr)
term.h:#define column_address CUR _Vr2_Astrs._s9
term.h:#define columns CUR _c1
term.h:#define command_character CUR _Vr2_Astrs._s10
macros.h:#define compare(str1,str2) strcmp(str1,str2)
libplot/cont.c:	int cont (xi,yi) { int ret; return ret; }
macros.h:#define copy(srce,dest) cat(dest,srce,0)
libm TRIG(3M):	double cos (x) double x; { return (x); }
libm SINH(3M):	double cosh (x) double x; { return (x); }
libc CREAT(2):	int creat (s, m) char *s; { return (m); }
term.h:#define create_window CURS strs3._create_window
curses.h:libcurses/crmode.c:	int crmode () { int ret; return ret; }
libc CRYPT(3C):	char * crypt (k, s) char *k, *s; { return (k); }
libc CTERMID(3S):	char * ctermid (s) char *s; { return (s); }
libc CTIME(3C):	char * ctime (t) long *t; { return (""); }
libPW/curdir.c:	int curdir (name) char name[]; { int ret; return ret; }
term.h:#define cursor_address CUR _Vr2_Astrs._s11
term.h:#define cursor_down CUR _Vr2_Astrs._s12
term.h:#define cursor_home CUR _Vr2_Astrs._s13
term.h:#define cursor_invisible CUR _Vr2_Astrs._s14
term.h:#define cursor_left CUR _Vr2_Astrs._s15
term.h:#define cursor_mem_address CUR _Vr2_Astrs._s16
term.h:#define cursor_normal CUR _Vr2_Astrs._s17
term.h:#define cursor_right CUR _Vr2_Astrs._s18
term.h:#define cursor_to_ll CUR _Vr2_Astrs._s19
term.h:#define cursor_up CUR _Vr2_Astrs._s20
term.h:#define cursor_visible CUR _Vr2_Astrs._s21
libc CUSERID(3S):	char * cuserid (s) char *s; { return (s); }
libc CTIME(3C):	extern int daylight;
libcurses/def_prog.c:	int def_prog_mode () { int ret; return ret; }
libcurses/def_shell.c:	int def_shell_mode () { int ret; return ret; }
term.h:#define del_curterm delterm
libcurses/naps.c:	int delay_output (ms) int ms; { int ret; return ret; }
curses.h:#define delch() wdelch(stdscr)
term.h:#define delete_character CUR _Vr2_Astrs._s22
term.h:#define delete_line CUR _Vr2_Astrs._s23
curses.h:#define deleteln() wdeleteln(stdscr)
libcurses/delwin.c:	int delwin (win) WINDOW *win; { int ret; return ret; }
term.h:#define dest_tabs_magic_smso CUR _b18
libc DIAL(3C):	int dial (c) CALL c; { return (0); }
term.h:#define dial_phone CURS strs3._dial_phone
term.h:#define dis_status_line CUR _Vr2_Astrs._s24
libc MAUS(2) PDP-11 IPC:	int dismaus (s) char *s; { return (0); }
term.h:#define display_clock CURS strs3._display_clock
libPW/dname.c:	char * dname (p) char *p; { char *ret; return ret; }
libplot/dot.c:	int dot (xi,yi,dx,n,pat) int pat[]; { int ret; return ret; }
term.h:#define down_half_line CUR _Vr2_Astrs._s25
libcurses/draino.c:	int draino (ms) int ms; { int ret; return ret; }
libc DRAND48(3C):	double drand48 () { return (0.0); }
libc DUP(2):	int dup (f) { return (f); }
term.h:#define eat_newline_glitch CUR _b5
curses.h:libcurses/echo.c:	int echo () { int ret; return ret; }
curses.h:#define echochar(ch) wechochar(stdscr, ch)
regexp.h:#define ecmp(s1, s2, n) (!strncmp(s1, s2, n))
libc ECVT(3C):	char * ecvt (v, n, d, s) double v; int *d, *s; { return (""); }
libc END(3C):	extern int edata;
term.h:#define ena_acs CURS strs2._ena_acs
libc MAUS(2) PDP-11 IPC:	char * enabmaus (m) { return (""); }
libc CRYPT(3C):	void encrypt (b, e) char *b; {}
libc END(3C):	extern int end;
libc GETGRENT(3C):	void endgrent () {}
libc GETPWENT(3C):	void endpwent () {}
libcurses/endwin.c:	int endwin () { int ret; return ret; }
term.h:#define enter_alt_charset_mode CUR _Vr2_Astrs._s26
term.h:#define enter_am_mode CURS strs2._entr_am_mode
term.h:#define enter_blink_mode CUR _Vr2_Astrs._s27
term.h:#define enter_bold_mode CUR _Vr2_Astrs._s28
term.h:#define enter_ca_mode CUR _Vr2_Astrs._s29
term.h:#define enter_delete_mode CUR _Vr2_Astrs._s30
term.h:#define enter_dim_mode CUR _Vr2_Astrs._s31
term.h:#define enter_insert_mode CUR _Vr2_Astrs._s32
term.h:#define enter_protected_mode CUR _Vr2_Astrs._s34
term.h:#define enter_reverse_mode CUR _Vr2_Astrs._s35
term.h:#define enter_secure_mode CUR _Vr2_Astrs._s33
term.h:#define enter_standout_mode CUR _Vr2_Astrs._s36
term.h:#define enter_underline_mode CUR _Vr2_Astrs._s37
term.h:#define enter_xon_mode CURS strs2._entr_xon_mode
libc EXEC(2):	extern char **environ;
macros.h:#define equal(str1,str2) !strcmp(str1,str2)
libc DRAND48(3C):	double erand48 (x) unsigned short x[3]; { return (0.0); }
curses.h, libplot/erase.c:	int erase () { int ret; return ret; }
term.h:#define erase_chars CUR _Vr2_Astrs._s38
term.h:#define erase_overstrike CUR _b6
libcurses/erasechar.c:	char erasechar () { char ret; return ret; }
libm ERF(3M):	double erf (x) double x; { return (x); }
libm ERF(3M):	double erfc (x) double x; { return (x); }
libc PERROR(3C):	extern int errno;
libc END(3C):	extern int etext;
libc EXEC(2):	/*VARARGS1*/ int execl (f, a) char *f, *a; { return (0); }
libc EXEC(2):	/*VARARGS1*/ int execle (f, a, e) char *f, *a, *e[]; { return (0); }
libc EXEC(2):	/*VARARGS1*/ int execlp (f, a) char *f, *a; { return (0); }
libc EXEC(2):	int execv (s, v) char *s, *v[]; { return (0); }
libc EXEC(2):	int execve (f, a, e) char *f, *a[], *e[]; { return (0); }
libc EXEC(2):	int execvp (s, v) char *s, *v[]; { return (0); }
macros.h:#define exists(file) (stat(file,&Statbuf)<0 ? 0:Statbuf.st_mode)
libc EXIT(2):	void exit (s) {}
term.h:#define exit_alt_charset_mode CUR _Vr2_Astrs._s39
term.h:#define exit_am_mode CURS strs2._exit_am_mode
term.h:#define exit_attribute_mode CUR _Vr2_Astrs._s40
term.h:#define exit_ca_mode CUR _Vr2_Astrs._s41
term.h:#define exit_delete_mode CUR _Vr2_Astrs._s42
term.h:#define exit_insert_mode CUR _Vr2_Astrs._s43
term.h:#define exit_standout_mode CUR _Vr2_Astrs._s44
term.h:#define exit_underline_mode CUR _Vr2_Astrs._s45
term.h:#define exit_xon_mode CURS strs2._exit_xon_mode
libm EXP(3M):	double exp (x) double x; { return (x); }
libm FLOOR(3M):	double fabs (x) double x; { return (x); }
libPW/fatal.c:	int fatal (msg) char *msg; { int ret; return ret; }
libc FCLOSE(3S):	int fclose (f) FILE *f; { return (0); }
libc FCNTL(2):	int fcntl (f, c, a) { return (f); }
libc ECVT(3C):	char * fcvt (v, n, d, s) double v; int *d, *s; { return (""); }
libPW/fdfopen.c:	FILE * fdfopen (fd, mode) int fd, mode; { FILE *ret; return ret; }
libc FOPEN(3S):	FILE * fdopen (f, t) char *t; { return (stdin); }
stdio.h:libc FERROR(3S):	int feof (f) FILE *f; { return (0); }
stdio.h:libc FERROR(3S):	int ferror (f) FILE *f; { return (0); }
libc FCLOSE(3S):	int fflush (f) FILE *f; { return (0); }
libc GETC(3S):	int fgetc (f) FILE *f; { return (0); }
libc GETGRENT(3C):	struct group * fgetgrent (f) FILE *f; { struct group x; return (&x); }
libc GETPWENT(3C):	struct passwd * fgetpwent (f) FILE *f; { struct passwd x; return (&x); }
libc GETS(3S):	char * fgets (s, n, f) char *s; FILE *f; { return (s); }
stdio.h:libc FERROR(3S):	int fileno (f) FILE *f; { return (0); }
term.h:libcurses/fixterm.c:	int fixterm () { int ret; return ret; }
curses.h:libcurses/flash.c:	int flash () { int ret; return ret; }
term.h:#define flash_hook CURS strs3._flash_hook
term.h:#define flash_screen CUR _Vr2_Astrs._s46
libm FLOOR(3M):	double floor (x) double x; { return (x); }
libcurses/flushinp.c:	int flushinp () { int ret; return ret; }
libm FLOOR(3M):	double fmod (x, y) double x, y; { return (x); }
libc FOPEN(3S):	FILE * fopen (f, t) char *f, *t; { return (stdin); }
libc FORK(2):	int fork () { return (0); }
term.h:#define form_feed CUR _Vr2_Astrs._s47
ieeefp.h:#define fp_except int
libc PRINTF(3S):	/*VARARGS2 PRINTFLIKE2*/ int fprintf (f, s) FILE *f; char *s; { return (0); }
libc PUTC(3S):	int fputc (c, f) FILE *f; { return (c); }
libc PUTS(3S):	int fputs (s, f) char *s; FILE *f; { return (0); }
libc FREAD(3S):	int fread (b, s, n, f) char *b; FILE *f; { return (n); }
libc MALLOC(3C):	void free (s) char *s; {}
libld/freeldptr.c:	int freeldptr (ldptr) LDFILE *ldptr; { int ret; return ret; }
libc MAUS(2) PDP-11 IPC:	int freemaus (m) { return (m); }
libc FOPEN(3S):	FILE * freopen (f, t, s) char *f, *t; FILE *s; { return (s); }
libc FREXP(3C):	double frexp (x, e) double x; int *e; { return (x); }
term.h:#define from_status_line CUR _Vr2_Astrs._s48
libc SCANF(3S):	/*VARARGS2 SCANFLIKE2*/ int fscanf (f, s) FILE *f; char *s; { return (0); }
libc FSEEK(3S):	int fseek (f, o, p) FILE *f; long o; { return (p); }
libc STAT(2):	int fstat (f, b) struct stat *b; { return (f); }
libc FSEEK(3S):	long ftell (f) FILE *f; { return (0L); }
libc STDIPC(3C):	key_t ftok (s, i) char *s; { return ((key_t)0); }
libc FTW(3C):	int ftw (p, f, d) char *p; int (*f)(); { return (d); }
libc FREAD(3S):	int fwrite (b, s, n, f) char *b; FILE *f; { return (n); }
libm GAMMA(3M):	double gamma (x) double x; { return (x); }
curses.h:#define garbagedlines wredrawln
curses.h:#define garbagedwin redrawwin
libc ECVT(3C):	char * gcvt (v, n, b) double v; char *b; { return (b); }
term.h:#define generic_type CUR _b7
curses.h:#define getattrs(win) ((win)->_attrs)
curses.h:#define getbegx(win) ((win)->_begx)
curses.h:#define getbegy(win) ((win)->_begy)
curses.h:#define getbegyx(win,y,x) ((y) = getbegy(win), (x) = getbegx(win))
curses.h:#define getbkgd(win) ((win)->_bkgd)
stdio.h:libc GETC(3S):	int getc (f) FILE *f; { return (0); }
curses.h:#define getch() wgetch(stdscr)
stdio.h:libc GETC(3S):	int getchar () { return (0); }
curses.h:#define getcurx(win) ((win)->_curx)
curses.h:#define getcury(win) ((win)->_cury)
libc GETCWD(3C):	char * getcwd (b, s) char *b; { return (b); }
libc GETUID(2):	int getegid () { return (0); }
libc GETENV(3C):	char * getenv (n) char *n; { return (n); }
libc GETUID(2):	int geteuid () { return (0); }
libc GETUID(2):	int getgid () { return (0); }
libc GETGRENT(3C):	struct group * getgrent () { static struct group x; return (&x); }
libc GETGRENT(3C):	struct group * getgrgid (g) { static struct group x; return (&x); }
libc GETGRENT(3C):	struct group * getgrnam (n) char *n; { static struct group x; return (&x); }
libc GETLOGIN(3C):	char * getlogin () { return (""); }
libc MAUS(2) PDP-11 IPC:	int getmaus (p, o) char *p; { return (o); }
curses.h:#define getmaxx(win) ((win)->_maxx)
curses.h:#define getmaxy(win) ((win)->_maxy)
curses.h:#define getmaxyx(win,y,x) ((y) = getmaxy(win), (x) = getmaxx(win))
libc GETOPT(3C):	int getopt (c, v, o) char **v, *o; { return (c); }
curses.h:#define getparx(win) ((win)->_parx)
curses.h:#define getpary(win) ((win)->_pary)
curses.h:#define getparyx(win,y,x) ((y) = getpary(win), (x) = getparx(win))
libc GETPASS(3C):	char * getpass (s) char *s; { return (s); }
libc GETPID(2):	int getpgrp () { return (0); }
libc GETPID(2):	int getpid () { return (0); }
libc GETPID(2):	int getppid () { return (0); }
libc GETPW(3C):	int getpw (u, b) char *b; { return (u); }
libc GETPWENT(3C):	struct passwd * getpwent () { static struct passwd x; return (&x); }
libc GETPWENT(3C):	struct passwd * getpwnam (n) char *n; { static struct passwd x; return (&x); }
libc GETPWENT(3C):	struct passwd * getpwuid (u) { static struct passwd x; return (&x); }
libc GETS(3S):	char * gets (s) char *s; { return (s); }
libcurses/setupterm.c:	int getsh (p) char *p; { int ret; return ret; }
curses.h:#define getstr(str) wgetstr(stdscr, str)
curses.h:#define getsyx(y,x) _getsyx(&(y),&(x))
curses.h:libcurses/gettmode.c:	int gettmode () { int ret; return ret; }
libc GETUID(2):	int getuid () { return (0); }
libc GETC(3S):	int getw (f) FILE *f; { return (0); }
curses.h:#define getyx(win,y,x) ((y) = getcury(win), (x) = getcurx(win))
libPW/giveup.c:	int giveup (dump) { int ret; return ret; }
libc CTIME(3C):	struct tm * gmtime (c) long *c; { static struct tm x; return (&x); }
term.h:#define goto_window CURS strs3._goto_window
libc SSIGNAL(3C):	int gsignal (s) { return (s); }
curses.h:#define halfdelay(tens) ttimeout((tens)*100)
term.h:#define hangup CURS strs3._hangup
term.h:#define hard_copy CUR _b8
term.h:#define hard_cursor CURB _hard_cursor
libcurses/has_ic.c:	int has_ic () { int ret; return ret; }
libcurses/has_il.c:	int has_il () { int ret; return ret; }
term.h:#define has_meta_key CUR _b9
term.h:#define has_status_line CUR _b10
libc HSEARCH(3C):	int hcreate (n) unsigned n; { return (0); }
libc HSEARCH(3C):	void hdestroy () {}
curses.h:#define hline(c,num) whline(stdscr,c,num)
libc HSEARCH(3C):	ENTRY * hsearch (i, a) ENTRY i; ACTION a; { return (&i); }
libm HYPOT(3M):	double hypot (x, y) double x, y; { return (x); }
curses.h:#define idcok(win,bf) ((win)->_use_idc = ((bf) ? TRUE : FALSE))
libcurses/idlok.c:	int idlok (win,bf) WINDOW *win; int bf; { int ret; return ret; }
libPW/imatch.c:	int imatch (prefix,string) char *prefix, *string; { int ret; return ret; }
curses.h:#define inch() winch(stdscr)
curses.h:#define inchnstr(str,n) winchnstr(stdscr,str,n)
curses.h:#define inchstr(str) winchstr(stdscr,str)
libPW/index.c:	int index (as1,as2) char *as1,*as2; { int ret; return ret; }
term.h:#define init_1string CUR _Vr2_Astrs._s49
term.h:#define init_2string CUR _Vr2_Astrs._s50
term.h:#define init_3string CUR _Vr2_Astrs._s51
term.h:#define init_file CUR _Vr2_Astrs._s52
term.h:#define init_prog CUR _Vr2_Bstrs._s139
term.h:#define init_tabs CUR _c2
libcurses/initscr.c:	WINDOW * initscr () { WINDOW * ret; return ret; }
curses.h:#define innstr(str,n) winnstr(stdscr,(str),(n))
curses.h:#define insch(c) winsch(stdscr,c)
curses.h:#define insdelln(id) winsdelln(stdscr,id)
term.h:#define insert_character CUR _Vr2_Astrs._s53
term.h:#define insert_line CUR _Vr2_Astrs._s54
term.h:#define insert_null_glitch CUR _b11
term.h:#define insert_padding CUR _Vr2_Astrs._s55
curses.h:#define insertln() winsertln(stdscr)
curses.h:#define insnstr(s,n) winsnstr(stdscr,s,n)
curses.h:#define insstr(s) winsstr(stdscr,s)
curses.h:#define instr(str) winstr(stdscr,(str))
curses.h:libcurses/intrflush.c:	int intrflush (win,bf) WINDOW *win; int bf; { int ret; return ret; }
libc IOCTL(2):	/*VARARGS2*/ int ioctl (f, r, a) { return (f); }
curses.h:#define is_linetouched(win,line) ((((line) >= (win)->_maxy) || ((line) < 0)) ? ERR : (((win)->_firstch[(line)] == _INFINITY) ? FALSE : TRUE))
curses.h:#define is_wintouched(win) ((win)->_flags & _WINCHANGED)
libc CTYPE(3C):ctype.h:#define isalnum(c) ((_ctype + 1)[c] & (_U | _L | _N))
libc CTYPE(3C):ctype.h:#define isalpha(c) ((_ctype + 1)[c] & (_U | _L))
libc CTYPE(3C):ctype.h:#define isascii(c) (!((c) & ~0177))
libc TTYNAME(3C):	int isatty (f) { return (f); }
libc CTYPE(3C):ctype.h:#define iscntrl(c) ((_ctype + 1)[c] & _C)
libc CTYPE(3C):ctype.h:#define isdigit(c) ((_ctype + 1)[c] & _N)
libc CTYPE(3C):ctype.h:#define isgraph(c) ((_ctype + 1)[c] & (_P | _U | _L | _N))
libc CTYPE(3C):ctype.h:#define islower(c) ((_ctype + 1)[c] & _L)
ieeefp.h:#define isnanf(x) (((*(int *)&(x) & 0x7f800000L)==0x7f800000L)&& 
isprint	libc CTYPE(3C):ctype.h:#define isprint(c) ((_ctype + 1)[c] & (_P | _U | _L | _N | _B))
libc CTYPE(3C):ctype.h:#define ispunct(c) ((_ctype + 1)[c] & _P)
libc CTYPE(3C):ctype.h:#define isspace(c) ((_ctype + 1)[c] & _S)
libc CTYPE(3C):ctype.h:#define isupper(c) ((_ctype + 1)[c] & _U)
libc CTYPE(3C):ctype.h:#define isxdigit(c) ((_ctype + 1)[c] & _X)
libm BESSEL(3M):	double j0 (x) double x; { return (x); }
libm BESSEL(3M):	double j1 (x) double x; { return (x); }
libm BESSEL(3M):	double jn (n, x) double x; { return (x); }
libc DRAND48(3C):	long jrand48 (x) unsigned short x[3]; { return (0L); }
term.h:#define key_a1 CUR _Vr2_Bstrs._s140
term.h:#define key_a3 CUR _Vr2_Bstrs._s141
term.h:#define key_b2 CUR _Vr2_Bstrs._s142
term.h:#define key_backspace CUR _Vr2_Astrs._s56
term.h:#define key_beg CURS strs2._ky_beg
term.h:#define key_btab CURS strs2._ky_btab
term.h:#define key_c1 CUR _Vr2_Bstrs._s143
term.h:#define key_c3 CUR _Vr2_Bstrs._s144
term.h:#define key_cancel CURS strs2._ky_cancel
term.h:#define key_catab CUR _Vr2_Astrs._s57
term.h:#define key_clear CUR _Vr2_Astrs._s58
term.h:#define key_close CURS strs2._ky_close
term.h:#define key_command CURS strs2._ky_command
term.h:#define key_copy CURS strs2._ky_copy
term.h:#define key_create CURS strs2._ky_create
term.h:#define key_ctab CUR _Vr2_Astrs._s59
term.h:#define key_dc CUR _Vr2_Astrs._s60
term.h:#define key_dl CUR _Vr2_Astrs._s61
term.h:#define key_down CUR _Vr2_Astrs._s62
term.h:#define key_eic CUR _Vr2_Astrs._s63
term.h:#define key_end CURS strs2._ky_end
term.h:#define key_enter CURS strs2._ky_enter
term.h:#define key_eol CUR _Vr2_Astrs._s64
term.h:#define key_eos CUR _Vr2_Astrs._s65
term.h:#define key_exit CURS strs2._ky_exit
term.h:#define key_f0 CUR _Vr2_Astrs._s66
term.h:#define key_f1 CUR _Vr2_Astrs._s67
term.h:#define key_f10 CUR _Vr2_Astrs._s68
term.h:#define key_f11 CURS strs3._ky_f11
term.h:#define key_f12 CURS strs3._ky_f12
term.h:#define key_f13 CURS strs3._ky_f13
term.h:#define key_f14 CURS strs3._ky_f14
term.h:#define key_f15 CURS strs3._ky_f15
term.h:#define key_f16 CURS strs3._ky_f16
term.h:#define key_f17 CURS strs3._ky_f17
term.h:#define key_f18 CURS strs3._ky_f18
term.h:#define key_f19 CURS strs3._ky_f19
term.h:#define key_f2 CUR _Vr2_Astrs._s69
term.h:#define key_f20 CURS strs3._ky_f20
term.h:#define key_f21 CURS strs3._ky_f21
term.h:#define key_f22 CURS strs3._ky_f22
term.h:#define key_f23 CURS strs3._ky_f23
term.h:#define key_f24 CURS strs3._ky_f24
term.h:#define key_f25 CURS strs3._ky_f25
term.h:#define key_f26 CURS strs3._ky_f26
term.h:#define key_f27 CURS strs3._ky_f27
term.h:#define key_f28 CURS strs3._ky_f28
term.h:#define key_f29 CURS strs3._ky_f29
term.h:#define key_f3 CUR _Vr2_Astrs._s70
term.h:#define key_f30 CURS strs3._ky_f30
term.h:#define key_f31 CURS strs3._ky_f31
term.h:#define key_f32 CURS strs3._ky_f32
term.h:#define key_f33 CURS strs3._ky_f33
term.h:#define key_f34 CURS strs3._ky_f34
term.h:#define key_f35 CURS strs3._ky_f35
term.h:#define key_f36 CURS strs3._ky_f36
term.h:#define key_f37 CURS strs3._ky_f37
term.h:#define key_f38 CURS strs3._ky_f38
term.h:#define key_f39 CURS strs3._ky_f39
term.h:#define key_f4 CUR _Vr2_Astrs._s71
term.h:#define key_f40 CURS strs3._ky_f40
term.h:#define key_f41 CURS strs3._ky_f41
term.h:#define key_f42 CURS strs3._ky_f42
term.h:#define key_f43 CURS strs3._ky_f43
term.h:#define key_f44 CURS strs3._ky_f44
term.h:#define key_f45 CURS strs3._ky_f45
term.h:#define key_f46 CURS strs3._ky_f46
term.h:#define key_f47 CURS strs3._ky_f47
term.h:#define key_f48 CURS strs3._ky_f48
term.h:#define key_f49 CURS strs3._ky_f49
term.h:#define key_f5 CUR _Vr2_Astrs._s72
term.h:#define key_f50 CURS strs3._ky_f50
term.h:#define key_f51 CURS strs3._ky_f51
term.h:#define key_f52 CURS strs3._ky_f52
term.h:#define key_f53 CURS strs3._ky_f53
term.h:#define key_f54 CURS strs3._ky_f54
term.h:#define key_f55 CURS strs3._ky_f55
term.h:#define key_f56 CURS strs3._ky_f56
term.h:#define key_f57 CURS strs3._ky_f57
term.h:#define key_f58 CURS strs3._ky_f58
term.h:#define key_f59 CURS strs3._ky_f59
term.h:#define key_f6 CUR _Vr2_Astrs._s73
term.h:#define key_f60 CURS strs3._ky_f60
term.h:#define key_f61 CURS strs3._ky_f61
term.h:#define key_f62 CURS strs3._ky_f62
term.h:#define key_f63 CURS strs3._ky_f63
term.h:#define key_f7 CUR _Vr2_Astrs._s74
term.h:#define key_f8 CUR _Vr2_Astrs._s75
term.h:#define key_f9 CUR _Vr2_Astrs._s76
term.h:#define key_find CURS strs2._ky_find
term.h:#define key_help CURS strs2._ky_help
term.h:#define key_home CUR _Vr2_Astrs._s77
term.h:#define key_ic CUR _Vr2_Astrs._s78
term.h:#define key_il CUR _Vr2_Astrs._s79
term.h:#define key_left CUR _Vr2_Astrs._s80
term.h:#define key_ll CUR _Vr2_Astrs._s81
term.h:#define key_mark CURS strs2._ky_mark
term.h:#define key_message CURS strs2._ky_message
term.h:#define key_move CURS strs2._ky_move
term.h:#define key_next CURS strs2._ky_next
term.h:#define key_npage CUR _Vr2_Astrs._s82
term.h:#define key_open CURS strs2._ky_open
term.h:#define key_options CURS strs2._ky_options
term.h:#define key_ppage CUR _Vr2_Astrs._s83
term.h:#define key_previous CURS strs2._ky_previous
term.h:#define key_print CURS strs2._ky_print
term.h:#define key_redo CURS strs2._ky_redo
term.h:#define key_reference CURS strs2._ky_reference
term.h:#define key_refresh CURS strs2._ky_refresh
term.h:#define key_replace CURS strs2._ky_replace
term.h:#define key_restart CURS strs2._ky_restart
term.h:#define key_resume CURS strs2._ky_resume
term.h:#define key_right CUR _Vr2_Astrs._s84
term.h:#define key_save CURS strs2._ky_save
term.h:#define key_sbeg CURS strs2._ky_sbeg
term.h:#define key_scancel CURS strs2._ky_scancel
term.h:#define key_scommand CURS strs2._ky_scommand
term.h:#define key_scopy CURS strs2._ky_scopy
term.h:#define key_screate CURS strs2._ky_screate
term.h:#define key_sdc CURS strs2._ky_sdc
term.h:#define key_sdl CURS strs2._ky_sdl
term.h:#define key_select CURS strs2._ky_select
term.h:#define key_send CURS strs2._ky_send
term.h:#define key_seol CURS strs2._ky_seol
term.h:#define key_sexit CURS strs2._ky_sexit
term.h:#define key_sf CUR _Vr2_Astrs._s85
term.h:#define key_sfind CURS strs2._ky_sfind
term.h:#define key_shelp CURS strs2._ky_shelp
term.h:#define key_shome CURS strs2._ky_shome
term.h:#define key_sic CURS strs3._ky_sic
term.h:#define key_sleft CURS strs3._ky_sleft
term.h:#define key_smessage CURS strs3._ky_smessage
term.h:#define key_smove CURS strs3._ky_smove
term.h:#define key_snext CURS strs3._ky_snext
term.h:#define key_soptions CURS strs3._ky_soptions
term.h:#define key_sprevious CURS strs3._ky_sprevious
term.h:#define key_sprint CURS strs3._ky_sprint
term.h:#define key_sr CUR _Vr2_Astrs._s86
term.h:#define key_sredo CURS strs3._ky_sredo
term.h:#define key_sreplace CURS strs3._ky_sreplace
term.h:#define key_sright CURS strs3._ky_sright
term.h:#define key_srsume CURS strs3._ky_srsume
term.h:#define key_ssave CURS strs3._ky_ssave
term.h:#define key_ssuspend CURS strs3._ky_ssuspend
term.h:#define key_stab CUR _Vr2_Astrs._s87
term.h:#define key_sundo CURS strs3._ky_sundo
term.h:#define key_suspend CURS strs2._ky_suspend
term.h:#define key_undo CURS strs2._ky_undo
term.h:#define key_up CUR _Vr2_Astrs._s88
libcurses/keypad.c:	int keypad (win,bf) WINDOW *win; int bf; { int ret; return ret; }
term.h:#define keypad_local CUR _Vr2_Astrs._s89
term.h:#define keypad_xmit CUR _Vr2_Astrs._s90
libc KILL(2):	int kill (i, s) { return (i); }
libcurses/killchar.c:	char killchar () { char ret; return ret; }
libc L3TOL(3C):	void l3tol (l, c, n) long *l; char *c; {}
libc A64L(3C):	char * l64a (l) long l; { return (""); }
term.h:#define lab_f0 CUR _Vr2_Astrs._s91
term.h:#define lab_f1 CUR _Vr2_Astrs._s92
term.h:#define lab_f10 CUR _Vr2_Astrs._s93
term.h:#define lab_f2 CUR _Vr2_Astrs._s94
term.h:#define lab_f3 CUR _Vr2_Astrs._s95
term.h:#define lab_f4 CUR _Vr2_Astrs._s96
term.h:#define lab_f5 CUR _Vr2_Astrs._s97
term.h:#define lab_f6 CUR _Vr2_Astrs._s98
term.h:#define lab_f7 CUR _Vr2_Astrs._s99
term.h:#define lab_f8 CUR _Vr2_Astrs._s100
term.h:#define lab_f9 CUR _Vr2_Bstrs._s101
libplot/label.c:	int label (s) char *s; { int ret; return ret; }
term.h:#define label_format CURS strs3._labl_format
term.h:#define label_height CURN _labl_height
term.h:#define label_off CURS strs2._labl_off
term.h:#define label_on CURS strs2._labl_on
term.h:#define label_width CURN _labl_width
libc DRAND48(3C):	void lcong48 (p) unsigned short p[7]; {}
libld/ldaclose.c:	int ldaclose (ldptr) LDFILE *ldptr; { int ret; return ret; }
libld/ldahread.c:	int ldahread (ldptr, arhead) LDFILE *ldptr; ARCHDR *arhead; { int ret; return ret; }
libld/ldaopen.c:	LDFILE * ldaopen (filename, oldptr) char *filename; LDFILE *oldptr; { LDFILE *ret; return ret; }
libld/ldclose.c:	int ldclose (ldptr) LDFILE *ldptr; { int ret; return ret; }
libc FREXP(3C):	double ldexp (v, e) double v; { return (v); }
libld/ldfhread.c:	int ldfhread (ldptr, filehead) LDFILE *ldptr; FILHDR *filehead; { int ret; return ret; }
libld/ldgetname.c:	char * ldgetname (ldptr, symentry) register LDFILE *ldptr; register SYMENT *symentry; { char *ret; return ret; }
libld/ldlread.c:	int ldlinit (ldptr, fcnindx) LDFILE *ldptr; long fcnindx; { int ret; return ret; }
libld/ldlread.c:	int ldlitem (ldptr, linenum, linent) LDFILE *ldptr; unsigned short linenum; LINENO *linent; { int ret; return ret; }
libld/ldlread.c:	int ldlread (ldptr, fcnindx, linenum, linent) LDFILE *ldptr; long fcnindx; unsigned short linenum; LINENO *linent; { int ret; return ret; }
libld/ldlseek.c:	int ldlseek (ldptr, sectnum) LDFILE *ldptr; unsigned short sectnum; { int ret; return ret; }
libld/ldnlseek.c:	int ldnlseek (ldptr, sectname) LDFILE *ldptr; char *sectname; { int ret; return ret; }
libld/ldnrseek.c:	int ldnrseek (ldptr, sectname) LDFILE *ldptr; char *sectname; { int ret; return ret; }
libld/ldnshread.c:	int ldnshread (ldptr, sectname, secthdr) LDFILE *ldptr; char *sectname; SCNHDR *secthdr; { int ret; return ret; }
libld/ldnsseek.c:	int ldnsseek (ldptr, sectname) LDFILE *ldptr; char *sectname; { int ret; return ret; }
libld/ldohseek.c:	int ldohseek (ldptr) LDFILE *ldptr; { int ret; return ret; }
libld/ldopen.c:	LDFILE * ldopen (filename, ldptr) char *filename; LDFILE *ldptr; { LDFILE *ret; return ret; }
libld/ldrseek.c:	int ldrseek (ldptr, sectnum) LDFILE *ldptr; unsigned short sectnum; { int ret; return ret; }
libld/ldshread.c:	int ldshread (ldptr, sectnum, secthdr) LDFILE *ldptr; unsigned short sectnum; SCNHDR *secthdr; { int ret; return ret; }
libld/ldsseek.c:	int ldsseek (ldptr, sectnum) LDFILE *ldptr; unsigned short sectnum; { int ret; return ret; }
libld/ldtbindex.c:	long ldtbindex (ldptr) LDFILE *ldptr; { long ret; return ret; }
libld/ldtbread.c:	int ldtbread (ldptr, symnum, symentry) LDFILE *ldptr; long symnum; SYMENT *symentry; { int ret; return ret; }
libld/ldtbseek.c:	int ldtbseek (ldptr) LDFILE *ldptr; { int ret; return ret; }
curses.h:libcurses/leaveok.c:	int leaveok (win,bf) WINDOW *win; int bf; { int ret; return ret; }
macros.h:#define length(str) strlen(str)
libc LSEARCH(3C):	char * lfind (k, b, n, w, c) char *k, *b; unsigned *n, w; int (*c)(); { return (k); }
libplot/line.c:	int line (x0,y0,x1,y1) { int ret; return ret; }
libplot/linmod.c:	int linemod (s) char *s; { int ret; return ret; }
term.h:#define lines CUR _c3
term.h:#define lines_of_memory CUR _c4
libc LINK(2):	int link (a, b) char *a, *b; { return (0); }
libc CTIME(3C):	struct tm * localtime (c) long *c; { static struct tm x; return (&x); }
libPW/lockit.c:	int lockit (lockfile,count,pid) char *lockfile; unsigned count; unsigned pid; { int ret; return ret; }
libm EXP(3M):	double log (x) double x; { return (x); }
libm EXP(3M):	double log10 (x) double x; { return (x); }
libPW/logname.c:	char * logname () { char *ret; return ret; }
libc SETJMP(3C):	void longjmp (e, v) jmp_buf e; {}
libcurses/longname.c:	char * longname () { char * ret; return ret; }
libc DRAND48(3C):	long lrand48 () { return (0L); }
libc LSEARCH(3C):	char * lsearch (k, b, n, w, c) char *k, *b; unsigned *n, w; int (*c)(); { return (k); }
libc LSEEK(2):	long lseek (f, o, w) long o; { return (o); }
libc L3TOL(3C):	void ltol3 (c, l, n) char *c; long *l; {}
libcurses/m_addch.c:	int m_addch (c) chtype c; { int ret; return ret; }
libcurses/m_addstr.c:	int m_addstr (str) char *str; { int ret; return ret; }
libcurses/m_clear.c:	int m_clear () { int ret; return ret; }
libcurses/m_erase.c:	int m_erase () { int ret; return ret; }
libcurses/miniinit.c:	WINDOW * m_initscr () { WINDOW * ret; return ret; }
libcurses/m_move.c:	int m_move (row, col) int row, col; { int ret; return ret; }
libcurses/m_refresh.c:	int m_refresh () { int ret; return ret; }
libcurses/m_tstp.c:	int m_tstp () { int ret; return ret; }
term.h:#define magic_cookie_glitch CUR _c5
libcurses/makenew.c:	WINDOW * makenew (num_lines, num_cols, begy, begx) int num_lines, num_cols, begy, begx; { WINDOW * ret; return ret; }
libmalloc MALLOC(3X):	struct mallinfo mallinfo () { struct mallinfo s; return (s); }
libc MALLOC(3C):	char * malloc (s) unsigned s; { return (""); }
libmalloc MALLOC(3X):	int mallopt (cmd, value) int cmd, value; { return cmd+value; }
libm MATHERR(3M):	int matherr (p) struct exception *p; { return (0); }
macros.h:#define max(a,b) (a<b ? b : a)
term.h:#define max_attributes CURN _max_attributes
term.h:#define maximum_windows CURN _maximum_windows
libc MEMORY(3C):	char * memccpy (a, b, c, n) char *a, *b; { return (a); }
libc MEMORY(3C):	char * memchr (s, c, n) char *s; { return (s); }
libc MEMORY(3C):	int memcmp (a, b, n) char *a, *b; { return (n); }
libc MEMORY(3C):	char * memcpy (a, b, n) char *a, *b; { return (a); }
term.h:#define memory_above CUR _b12
term.h:#define memory_below CUR _b13
libc MEMORY(3C):	char * memset (s, c, n) char *s; { return (s); }
curses.h:libcurses/meta.c:	int meta (win,bf) WINDOW *win; int bf; { int ret; return ret; }
term.h:#define meta_off CUR _Vr2_Bstrs._s102
term.h:#define meta_on CUR _Vr2_Bstrs._s103
macros.h:#define min(a,b) (a>b ? b : a)
libc MKNOD(2):	int mknod (n, m, d) char *n; { return (m); }
libc MKTEMP(3C):	char * mktemp (t) char *t; { return (t); }
libc FREXP(3C):	double modf (v, i) double v, *i; { return (v); }
libc MONITOR(3C):	void monitor (l, h, b, s, n) int (*l)(), (*h)(); WORD *b; {}
libc MOUNT(2):	int mount (s, d, r) char *s, *d; { return (r); }
curses.h, libPW/move.c, libplot/move.c:curses.h:#define move(y, x) wmove(stdscr, y, x), char * move (a,b,n) char *a, *b; int n; { char *ret; return ret; }, int move (xi,yi) { int ret; return ret; }
term.h:#define move_insert_mode CUR _b14
term.h:#define move_standout_mode CUR _b15
libc DRAND48(3C):	long mrand48 () { return (0L); }
libc MSGCTL(2):	int msgctl (m, c, b) struct msqid_ds *b; { return (m); }
libc MSGGET(2):	int msgget (k, m) key_t k; { return (m); }
libc MSGOP(2):	int msgrcv (q, p, s, t, f) struct msgbuf *p; long t; { return (q); }
libc MSGOP(2):	int msgsnd (q, p, s, f) struct msgbuf *p; { return (q); }
curses.h:#define mvaddch(y,x,ch) mvwaddch(stdscr,y,x,ch)
curses.h:#define mvaddchnstr(y,x,str,n) mvwaddchnstr(stdscr,y,x,str,n)
curses.h:#define mvaddchstr(y,x,str) mvwaddchstr(stdscr,y,x,str)
curses.h:#define mvaddnstr(y,x,s,n) mvwaddnstr(stdscr,y,x,s,n)
curses.h:#define mvaddstr(y,x,str) mvwaddstr(stdscr,y,x,str)
curses.h:#define mvdelch(y,x) mvwdelch(stdscr,y,x)
curses.h:#define mvgetch(y,x) mvwgetch(stdscr,y,x)
curses.h:#define mvgetstr(y,x,str) mvwgetstr(stdscr,y,x,str)
curses.h:#define mvhline(y,x,c,num) mvwhline(stdscr,y,x,c,num)
curses.h:#define mvinch(y,x) mvwinch(stdscr,y,x)
curses.h:#define mvinchnstr(y,x,str,n) mvwinchnstr(stdscr,y,x,str,n)
curses.h:#define mvinchstr(y,x,str) mvwinchstr(stdscr,y,x,str)
curses.h:#define mvinnstr(y,x,str,n) mvwinnstr(stdscr,y,x,(str),(n))
curses.h:#define mvinsch(y,x,c) mvwinsch(stdscr,y,x,c)
curses.h:#define mvinsnstr(y,x,s,n) mvwinsnstr(stdscr,y,x,s,n)
curses.h:#define mvinsstr(y,x,s) mvwinsstr(stdscr,y,x,s)
curses.h:#define mvinstr(y,x,str) mvwinstr(stdscr,y,x,(str))
libcurses/mvprintw.c:	/* VARARGS3 */ int mvprintw (y, x, fmt) int y, x; char *fmt; { int ret; return ret; }
libcurses/mvscanw.c:	/* VARARGS3 */ int mvscanw (y, x, fmt) int y, x; char *fmt; { int ret; return ret; }
curses.h:#define mvvline(y,x,c,num) mvwvline(stdscr,y,x,c,num)
curses.h:#define mvwaddch(win,y,x,ch) (wmove(win,y,x)==ERR?ERR:waddch(win,ch))
curses.h:#define mvwaddchnstr(win,y,x,str,n) (wmove(win,y,x)==ERR?ERR:waddchnstr(win,str,n))
curses.h:#define mvwaddchstr(win,y,x,str) (wmove(win,y,x)==ERR?ERR:waddchstr(win,str))
curses.h:#define mvwaddnstr(win,y,x,s,n) (wmove(win,y,x)==ERR?ERR:waddnstr(win,s,n))
curses.h:#define mvwaddstr(win,y,x,str) (wmove(win,y,x)==ERR?ERR:waddstr(win,str))
curses.h:#define mvwdelch(win,y,x) (wmove(win,y,x)==ERR?ERR:wdelch(win))
curses.h:#define mvwgetch(win,y,x) (wmove(win,y,x)==ERR?ERR:wgetch(win))
curses.h:#define mvwgetstr(win,y,x,str) (wmove(win,y,x)==ERR?ERR:wgetstr(win,str))
curses.h:#define mvwhline(win,y,x,c,num) (wmove(win,y,x)==ERR?ERR:whline(win,c,num))
libcurses/mvwin.c:	int mvwin (win, by, bx) WINDOW *win; int by, bx; { int ret; return ret; }
curses.h:#define mvwinch(win,y,x) (wmove(win,y,x)==ERR?(chtype) ERR:winch(win))
curses.h:#define mvwinchnstr(win,y,x,str,n) (wmove(win,y,x)==ERR?ERR:winchnstr(win,str,n))
curses.h:#define mvwinchstr(win,y,x,str) (wmove(win,y,x)==ERR?ERR:winchstr(win,str))
curses.h:#define mvwinnstr(win,y,x,str,n) (wmove(win,y,x)==ERR?ERR:winnstr(win,str,n))
curses.h:#define mvwinsch(win,y,x,c) (wmove(win,y,x)==ERR?ERR:winsch(win,c))
curses.h:#define mvwinsnstr(win,y,x,s,n) (wmove(win,y,x)==ERR?ERR:winsnstr(win,s,n))
curses.h:#define mvwinsstr(win,y,x,s) (wmove(win,y,x)==ERR?ERR:winsstr(win,s))
curses.h:#define mvwinstr(win,y,x,str) (wmove(win,y,x)==ERR?ERR:winstr(win,str))
libcurses/mvwprintw.c:	/* VARARGS4 */ int mvwprintw (win, y, x, fmt) WINDOW *win; int y, x; char *fmt; { int ret; return ret; }
libcurses/mvwscanw.c:	/* VARARGS4 */ int mvwscanw (win, y, x, fmt) WINDOW *win; int y, x; char *fmt; { int ret; return ret; }
curses.h:#define mvwvline(win,y,x,c,num) (wmove(win,y,x)==ERR?ERR:wvline(win,c,num))
libPW/lockit.c:	int mylock (lockfile,pid) char *lockfile; unsigned pid; { int ret; return ret; }
libcurses/naps.c:	int napms (ms) int ms; { int ret; return ret; }
term.h:#define needs_xon_xoff CURB _needs_xon_xoff
term.h:#define newline CUR _Vr2_Bstrs._s104
libcurses/newpad.c:	WINDOW * newpad (nlines, ncols) int nlines; { WINDOW * ret; return ret; }
curses.h:libcurses/newterm.c:	SCREEN * newterm (type, outfd, infd) char *type; FILE *outfd, *infd; { SCREEN * ret; return ret; }
libcurses/newwin.c:	WINDOW * newwin (nlines, ncols, by, bx) int nlines, ncols, by, bx; { WINDOW * ret; return ret; }
libc NICE(2):	int nice (i) { return (i); }
curses.h:libcurses/nl.c:	int nl () { int ret; return ret; }
libc NLIST(3C):	int nlist (f, n) char *f; struct nlist *n; { return (0); }
term.h:#define no_esc_ctlc CUR _b3
term.h:#define no_pad_char CURB _no_pad_char
libcurses/nocbreak.c:	int nocbreak () { int ret; return ret; }
libcurses/nocrmode.c:curses.h:#define nocrmode nocbreak
curses.h:libcurses/nodelay.c:	int nodelay (win,bf) WINDOW *win; int bf; { int ret; return ret; }
curses.h:libcurses/noecho.c:	int noecho () { int ret; return ret; }
term.h:#define non_dest_scroll_region CURB _non_dest_scroll_region
term.h:#define non_rev_rmcup CURB _non_rev_rmcup
curses.h:libcurses/nonl.c:	int nonl () { int ret; return ret; }
curses.h:#define noqiflush() _setqiflush(FALSE)
libcurses/noraw.c:	int noraw () { int ret; return ret; }
curses.h:#define notimeout(win,bf) ((win)->_notimeout = ((bf) ? TRUE : FALSE))
libc DRAND48(3C):	long nrand48 (x) unsigned short x[3]; { return (0L); }
term.h:#define num_labels CURN _num_labels
macros.h:#define numeric(c) (c >= '0' && c <= '9')
libPW/lockit.c:	int onelock (pid,tempfile,lockfile) unsigned pid; char *tempfile; char *lockfile; { int ret; return ret; }
libc OPEN(2):	/*VARARGS2*/ int open (f, o, m) char *f; { return (o); }
libplot/open.c:	int openpl () { int ret; return ret; }
libplot/open.c:	int openvt () { int ret; return ret; }
libc GETOPT(3C):	extern char *optarg;
libc GETOPT(3C):	extern int opterr;
libc GETOPT(3C):	extern int optind;
libc GETOPT(3C):	extern int optopt; /*undocumented */
term.h:#define over_strike CUR _b16
curses.h:libcurses/overlay.c:	int overlay (win1, win2) WINDOW *win1, *win2; { int ret; return ret; }
curses.h:libcurses/overwrite.c:	int overwrite (win1, win2) WINDOW *win1, *win2; { int ret; return ret; }
term.h:#define pad_char CUR _Vr2_Bstrs._s105
term.h:#define padding_baud_rate CUR _c6
term.h:#define parm_dch CUR _Vr2_Bstrs._s106
term.h:#define parm_delete_line CUR _Vr2_Bstrs._s107
term.h:#define parm_down_cursor CUR _Vr2_Bstrs._s108
term.h:#define parm_ich CUR _Vr2_Bstrs._s109
term.h:#define parm_index CUR _Vr2_Bstrs._s110
term.h:#define parm_insert_line CUR _Vr2_Bstrs._s111
term.h:#define parm_left_cursor CUR _Vr2_Bstrs._s112
term.h:#define parm_right_cursor CUR _Vr2_Bstrs._s113
term.h:#define parm_rindex CUR _Vr2_Bstrs._s114
term.h:#define parm_up_cursor CUR _Vr2_Bstrs._s115
libPW/patoi.c:	int patoi (s) char *s; { int ret; return ret; }
libPW/patol.c:	long patol (s) char *s; { long ret; return ret; }
libc PAUSE(2):	int pause () { return (0); }
libc POPEN(3S):	int pclose (f) FILE *f; { return (0); }
libc PERROR(3C):	void perror (s) char *s; {}
libc PIPE(2):	int pipe (f) int f[2]; { return (0); }
term.h:#define pkey_key CUR _Vr2_Bstrs._s116
term.h:#define pkey_local CUR _Vr2_Bstrs._s117
term.h:#define pkey_xmit CUR _Vr2_Bstrs._s118
term.h:#define plab_norm CURS strs2._plab_norm
libc PLOCK(2):	int plock (o) { return (o); }
libcurses/pnoutrfrsh.c:	int pnoutrefresh (pad, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol) WINDOW *pad; int pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol; { int ret; return ret; }
libplot/point.c:	int point (xi,yi) { int ret; return ret; }
libPW/abspath.c:	char pop (stktop) char **stktop; { char ret; return ret; }
libc POPEN(3S):	FILE * popen (c, t) char *c, *t; { return (stdin); }
libm EXP(3M):	double pow (x, y) double x, y; { return (x); }
libcurses/prefresh.c:	int prefresh (pad, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol) WINDOW *pad; int pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol; { int ret; return ret; }
term.h:#define print_screen CUR _Vr2_Bstrs._s119
libl/allprint.c:	int printable (c) int c; { int ret; return ret; }
libc PRINTF(3S):	/*VARARGS1 PRINTFLIKE1*/ int printf (s) char *s; { return (0); }
libcurses/printw.c:	/* VARARGS1 */ int printw (fmt) char *fmt; { int ret; return ret; }
libc PROFIL(2):	void profil (b, s, o, i) char *b; {}
term.h:#define prtr_non CUR _Vr2_Bstrs._s145
term.h:#define prtr_off CUR _Vr2_Bstrs._s120
term.h:#define prtr_on CUR _Vr2_Bstrs._s121
term.h:#define prtr_silent CURB _prtr_silent
libc PTRACE(2):	int ptrace (r, i, a, d) { return (r); }
term.h:#define pulse CURS strs3._pulse
libPW/abspath.c:	int push (chrptr,stktop) char **chrptr; char **stktop; { int ret; return ret; }
libc PUTC(3S):stdio.h:#define putc(x, p) (--(p)->_cnt < 0 ? _flsbuf((unsigned char) (x), (p)) : (int) (*(p)->_ptr++ = (unsigned char) (x)))
libc PUTC(3S):stdio.h:#define putchar(x) putc((x), stdout)
libc PUTENV(3C):	int putenv (s) char *s; { return (0); }
libcurses/putp.c:	int putp (str) char *str; { int ret; return ret; }
libc PUTPWENT(3C):	int putpwent (s, f) struct passwd *s; FILE *f; { return (0); }
libc PUTS(3S):	int puts (s) char *s; { return (0); }
libplot/putsi.c:	int putsi (a) { int ret; return ret; }
libc PUTC(3S):	int putw (w, f) FILE *f; { return (w); }
curses.h:#define qiflush() _setqiflush(TRUE)
libc QSORT(3C):	void qsort (b, n, w, c) char *b; unsigned n, w; int (*c)(); {}
term.h:#define quick_dial CURS strs3._quick_dial
libc RAND(3C):	int rand () { return (0); }
libcurses/raw.c:	int raw () { int ret; return ret; }
libc READ(2):	int read (f, b, n) char *b; unsigned n; { return (f); }
libc MALLOC(3C):	char * realloc (s, n) char *s; unsigned n; { return (s); }
curses.h:#define redrawwin(win) wredrawln((win),0,(win)->_maxy)
curses.h:#define refresh() wrefresh(stdscr)
libPW/regcmp.c:	/* VARARGS */ char * regcmp (string1) char *string1; { char *ret; return ret; }
libPW/regex.c:	/* VARARGS2 */ char * regex (re, subject) char *re, *subject; { char *ret; return ret; }
macros.h:#define remove(file) xunlink(file)
term.h:#define remove_clock CURS strs3._remove_clock
libPW/rename.c:	int rename (oldname,newname) char *oldname, *newname; { int ret; return ret; }
libPW/repeat.c:	char * repeat (result,str,repfac) char *result, *str; unsigned repfac; { char *ret; return ret; }
term.h:#define repeat_char CUR _Vr2_Bstrs._s122
libPW/repl.c:	char * repl (str,old,new) char *str; char old,new; { char *ret; return ret; }
term.h:#define req_for_input CURS strs3._req_for_input
term.h:#define reset_1string CUR _Vr2_Bstrs._s123
term.h:#define reset_2string CUR _Vr2_Bstrs._s124
term.h:#define reset_3string CUR _Vr2_Bstrs._s125
term.h:#define reset_file CUR _Vr2_Bstrs._s126
libcurses/reset_prog.c:	int reset_prog_mode () { int ret; return ret; }
libcurses/resetshell.c:	int reset_shell_mode () { int ret; return ret; }
libcurses/resetterm.c:curses.h:#define resetterm reset_shell_mode
libcurses/resetty.c:	int resetty () { int ret; return ret; }
libcurses/restarttrm.c:	int restartterm (term, filenum, errret) char *term; int filenum; int *errret; { int ret; return ret; }
term.h:#define restore_cursor CUR _Vr2_Bstrs._s127
libc FSEEK(3S):	void rewind (f) FILE *f; {}
dirent.h:#define rewinddir( dirp ) seekdir( dirp, 0L )
term.h:#define row_address CUR _Vr2_Bstrs._s128
libPW/satoi.c:	char * satoi (p,ip) char *p; int *ip; { char *ret; return ret; }
term.h:#define save_cursor CUR _Vr2_Bstrs._s129
libcurses/saveterm.c:curses.h:#define saveterm def_prog_mode
libcurses/savetty.c:	int savetty () { int ret; return ret; }
libc BRK(2):	char * sbrk (i) { return (""); }
libc SCANF(3S):	/*VARARGS1 SCANFLIKE1*/ int scanf (s) char *s; { return (0); }
libcurses/scanw.c:	/* VARARGS1 */ int scanw (fmt) char *fmt; { int ret; return ret; }
curses.h:#define scr_init(file) _scr_all(file,0)
curses.h:#define scr_restore(file) _scr_all(file,1)
curses.h:#define scr_set(file) _scr_all(file,2)
libcurses/miniinit.c:	SCREEN * m_newterm (type, outfd, infd) char *type; FILE *outfd, *infd; { SCREEN * ret; return ret; }
curses.h:#define scrl(n) wscrl(stdscr,n)
curses.h:libcurses/scroll.c:	int scroll (win) WINDOW *win; { int ret; return ret; }
term.h:#define scroll_forward CUR _Vr2_Bstrs._s130
term.h:#define scroll_reverse CUR _Vr2_Bstrs._s131
curses.h:libcurses/scrollok.c:	int scrollok (win,bf) WINDOW *win; int bf; { int ret; return ret; }
libcurses/select.c:	int select (nfds, prfds, pwfds, pefds, timeout) int nfds; int *prfds, *pwfds, *pefds; struct _timeval *timeout; { int ret; return ret; }
libc SEMCTL(2):	/*VARARGS3*/ int semctl (i, n, c, a) union semun a; { return (i); }
libc SEMGET(2):	int semget (k, n, s) key_t k; { return (n); }
libc SEMOP(2):	int semop (i, o, n) struct sembuf *o; { return (i); }
libc SEMCTL(2):	union semun { int val; struct semid_ds *buf; ushort *array; };
term.h:#define set_attributes CUR _Vr2_Bstrs._s132
term.h:#define set_clock CURS strs3._set_clock
term.h:#define set_curterm setcurterm
term.h:#define set_left_margin CURS strs3._set_left_margin
term.h:#define set_right_margin CURS strs3._set_right_margin
term.h:#define set_tab CUR _Vr2_Bstrs._s133
curses.h:libcurses/set_term.c:	SCREEN * set_term (new) SCREEN *new; { SCREEN * ret; return ret; }
term.h:#define set_window CUR _Vr2_Bstrs._s134
libc SETBUF(3S):	void setbuf (f, b) FILE *f; char *b; {}
libc SETUID(2):	int setgid (g) { return (g); }
libc GETGRENT(3C):	void setgrent () {}
libc SETJMP(3C):	int setjmp (e) jmp_buf e; { return (0); }
libc CRYPT(3C):	void setkey (k) char *k; {}
libc SETPGRP(2):	int setpgrp () { return (0); }
libc GETPWENT(3C):	void setpwent () {}
curses.h:#define setscrreg(t,b) wsetscrreg(stdscr, t, b)
libPW/setsig.c:	int setsig () { int ret; return ret; }
libPW/setsig.c:	int setsig1 (sig) int sig; { int ret; return ret; }
libcurses/setterm.c:curses.h:#define setterm(name) setupterm((name),1,(char*)NULL)
libc SETUID(2):	int setuid (u) { return (u); }
libcurses/setupterm.c:	int setupterm (term, filenum, errret) char *term; int filenum; int *errret; { int ret; return ret; }
libc SETBUF(3S):	int setvbuf (f, t, b, s) FILE *f; char *b; { return (t); }
libld/sgetl.c:	long sgetl (buffer) register char *buffer; { long ret; return ret; }
libc SHMOP(2):	char * shmat (i, a, f) char *a; { return (a); }
libc SHMCTL(2):	int shmctl (s, c, b) struct shmid_ds *b; { return (s); }
libc SHMOP(2):	int shmdt (a) char *a; { return (0); }
libc SHMGET(2):	int shmget (k, s, f) key_t k; { return (s); }
libc DRAND48(3C):	unsigned short * seed48 (s) unsigned short s[3]; { return (s); }
libc SIGNAL(2): void (* signal (s, a))() void (*a)(); { return (a); }
libm GAMMA(3M):	extern int signgam;
libm TRIG(3M):	double sin (x) double x; { return (x); }
libm SINH(3M):	double sinh (x) double x; { return (x); }
macros.h:#define size(str) (strlen(str) + 1)
libc SLEEP(3C):	unsigned sleep (n) unsigned n; { return (n); }
curses.h:#define slk_init(f) slk_start(((f == 0) ? 3 : 2),NULL)
libPW/sname.c:	char * sname (s) char *s; { char *ret; return ret; }
libplot/space.c:	int space (x0,y0,x1,y1) { int ret; return ret; }
libl/allprint.c:	int sprint (s) char *s; { int ret; return ret; }
libc PRINTF(3S):	/*VARARGS2 PRINTFLIKE2*/ int sprintf (p, s) char *p, *s; { return (0); }
libld/sputl.c:	int sputl (w, buffer) register long w; register char *buffer; { int ret; return ret; }
libm EXP(3M):	double sqrt (x) double x; { return (x); }
libc RAND(3C):	void srand (s) unsigned s; {}
libc DRAND48(3C):	void srand48 (s) long s; {}
libc SCANF(3S):	/*VARARGS2 SCANFLIKE2*/ int sscanf (p, s) char *p, *s; { return (0); }
libc SSIGNAL(3C):	int (* ssignal (s, a))() int (*a)(); { return (a); }
curses.h:#define standend() wstandend(stdscr)
curses.h:#define standout() wstandout(stdscr)
libc STAT(2):	int stat (s, b) char *s; struct stat *b; { return (0); }
term.h:#define status_line_esc_ok CUR _b17
stdio.h:#define stderr (&_iob[2])
stdio.h:#define stdin (&_iob[0])
stdio.h:#define stdout (&_iob[1])
libc STIME(2):	int stime (t) long *t; { return (0); }
libc STRING(3C):	char * strcat (a, b) char *a, *b; { return (a); }
libc STRING(3C):	char * strchr (a, b) char *a, b; { return (a); }
libc STRING(3C):	int strcmp (a, b) char *a, *b; { return (0); }
libc STRING(3C):	char * strcpy (a, b) char *a, *b; { return (a); }
libc STRING(3C):	int strcspn (a, b) char *a, *b; { return (0); }
libPW/strend.c:	char * strend (p) char *p; { char *ret; return ret; }
libc STRING(3C):	int strlen (s) char *s; { return (0); }
libc STRING(3C):	char * strncat (a, b, n) char *a, *b; { return (a); }
libc STRING(3C):	int strncmp (a, b, n) char *a, *b; { return (n); }
libc STRING(3C):	char * strncpy (a, b, n) char *a, *b; { return (a); }
libc STRING(3C):	char * strpbrk (a, b) char *a, *b; { return (a); }
libc STRING(3C):	char * strrchr (a, b) char *a, b; { return (a); }
libc STRING(3C):	int strspn (a, b) char *a, *b; { return (0); }
libc STRTOD(3C):	double strtod (s, t) char *s, **t; { return (0.0); }
libc STRING(3C):	char * strtok (a, b) char *a, *b; { return (a); }
libc STRTOL(3C):	long strtol (s, t, b) char *s, **t; { return (0L); }
curses.h:#define subpad(win,nl,nc,by,bx) derwin((win),(nl),(nc),(by),(bx))
libPW/substr.c:	char * substr (as, aresult, origin, len) char *as, *aresult; int origin; unsigned len; { char *ret; return ret; }
curses.h:libcurses/subwin.c:	WINDOW * subwin (orig, num_lines, num_cols, begy, begx) WINDOW *orig; int num_lines, num_cols, begy, begx; { WINDOW * ret; return ret; }
libc SWAB(3C):	void swab (f, t, n) char *f, *t; {}
libc MAUS(2) PDP-11 IPC:	char * switmaus (m, s) char *s; { return (s); }
libc SYNC(2):	void sync () {}
curses.h:#define syncok(win,bf) ((win)->_parent?(win)->_sync=(bf):ERR)
libc SYS3B(2) (3B20 and 3B5 only):	/*VARARGS2*/ void sys3b (c, a, b) {}
libc PERROR(3C):	extern char * sys_errlist [1];
libc PERROR(3C):	extern int sys_nerr;
libc SYSCALL(3S):	/* UNDOCUMENTED (not for general use) */ /*VARARGS3*/ int syscall (n, r, s, a) { return (n); }
libc SYSTEM(3S):	int system (s) char *s; { return (0); }
term.h:#define tab CUR _Vr2_Bstrs._s135
libm TRIG(3M):	double tan (x) double x; { return (x); }
libm SINH(3M):	double tanh (x) double x; { return (x); }
libc TSEARCH(3C):	char * tdelete (k, r, c) char *k, **r; int (*c)(); { return (k); }
term.h:#define teleray_glitch dest_tabs_magic_smso
libc VPRINTF(3S):	long tell (f) { return (0L); }
libc TMPNAM(3S):	char * tempnam (d, s) char *d, *s; { return (d); }
libc TSEARCH(3C):	char * tfind (k, r, c) char *k, **r; int (*c)(); { return (k); }
libcurses/tgetent.c:	int tgetent (bp, name) char *bp, *name; { int ret; return ret; }
libcurses/tgetflag.c:	int tgetflag (id) char *id; { int ret; return ret; }
libcurses/tgetnum.c:	int tgetnum (id) char *id; { int ret; return ret; }
libcurses/tgetstr.c:	char * tgetstr (id, area) char *id, *area; { char * ret; return ret; }
libcurses/tgoto.c:	char * tgoto (cap, col, row) char *cap; int col, row; { char * ret; return ret; }
term.h:#define tilde_glitch CUR _b19
libc TIME:	long time (t) long *t; { return (0L);}
curses.h:#define timeout(tm) wtimeout(stdscr,tm)
libc TIMES(2):	long times (b) struct tms *b; { return (0L); }
libc CTIME(3C):	extern long timezone;
libc TMPFILE(3S):	FILE * tmpfile () { return (stdin); }
libc TMPNAM(3S):	char * tmpnam (s) char *s; { return (s); }
term.h:#define to_status_line CUR _Vr2_Bstrs._s136
libc CONV(3C):ctype.h:#define toascii(c) ((c) & 0177)
libc CONV(3C):	int tolower (i) { return (i); }
term.h:#define tone CURS strs3._tone
curses.h:#define touchline(win,y,n) wtouchln((win),(y),(n),TRUE)
curses.h:libcurses/touchwin.c:	int touchwin (win) WINDOW *win; { int ret; return ret; }
libc CONV(3C):	int toupper (i) { return (i); }
libcurses/tparm.c:	/* VARARGS1 */ char * tparm (instring) char *instring; { char * ret; return ret; }
libcurses/tputs.c:	int tputs (cp, affcnt, outc) char *cp; int affcnt; int (*outc)(); { int ret; return ret; }
libcurses/traceonoff.c:	int traceoff () { int ret; return ret; }
libcurses/traceonoff.c:	int traceon () { int ret; return ret; }
term.h:#define transparent_underline CUR _b20
libPW/trnslat.c:	char * trnslat (str,old,new,result) char *str; char *old, *new, *result; { char *ret; return ret; }
libc TSEARCH(3C):	char * tsearch (k, r, c) char *k, **r; int (*c)(); { return (k); }
libc TTYNAME(3C):	char * ttyname (f) { return (""); }
libc VPRINTF(3S):	int ttyslot () { return (0); }
libc TSEARCH(3C):	void twalk (r, f) char *r; void (*f)(); {}
libcurses/typeahead.c:	int typeahead (fd) int fd; { int ret; return ret; }
libc CTIME(3C):	extern char *tzname[2];
libc CTIME(3C):	void tzset () {}
libc ULIMIT(2):	daddr_t ulimit (c, n) daddr_t n; { return (n); }
libc UMASK(2):	int umask (c) { return (c); }
libc UMOUNT(2):	int umount (s) char *s; { return (0); }
libc UNAME(2):	int uname (n) struct utsname *n; { return (0); }
unctrl.h:#define unctrl(ch) (_unctrl[(unsigned) ch])
term.h:#define underline_char CUR _Vr2_Bstrs._s137
libc DIAL(3C):	void undial (f) {}
libc UNGETC(3S):	int ungetc (c, f) FILE *f; { return (c); }
libc UNLINK(2):	int unlink (s) char *s; { return (0); }
libPW/lockit.c:	int unlockit (lockfile,pid) char *lockfile; unsigned pid; { int ret; return ret; }
curses.h:#define untouchwin(win) wtouchln((win),0,((win)->_maxy),FALSE)
term.h:#define up_half_line CUR _Vr2_Bstrs._s138
term.h:#define user0 CURS strs3._user0
term.h:#define user1 CURS strs3._user1
term.h:#define user2 CURS strs3._user2
term.h:#define user3 CURS strs3._user3
term.h:#define user4 CURS strs3._user4
term.h:#define user5 CURS strs3._user5
term.h:#define user6 CURS strs3._user6
term.h:#define user7 CURS strs3._user7
term.h:#define user8 CURS strs3._user8
term.h:#define user9 CURS strs3._user9
libPW/userdir.c:	char * userdir (uid) int uid; { char *ret; return ret; }
libPW/userexit.c:	int userexit (code) { int ret; return ret; }
libPW/username.c:	char * username (uid) int uid; { char *ret; return ret; }
libc USTAT(2):	int ustat (d, b) struct ustat *b; { return (d); }
libc UTIME(2):	int utime (f, t) char *f; struct { time_t x, y; } *t; { return (0); }
varargs.h:#define va_arg(list, mode) ((mode *)(list += sizeof(mode)))[-1]
varargs.h:#define va_dcl int va_alist;
varargs.h:#define va_end(list)
varargs.h:#define va_start(list) list = (char *) &va_alist
libPW/verify.c:	int verify (astr1,str2) char *astr1; char *str2; { int ret; return ret; }
libc VPRINTF(3S):	int vfprintf (f, s, v) FILE *f; char *s; va_list v; { return (0); }
libcurses/vidattr.c:	int vidattr (newmode) int newmode; { int ret; return ret; }
libcurses/vidputs.c:	int vidputs (newmode, outc) int newmode; int (*outc)(); { int ret; return ret; }
term.h:#define virtual_terminal CUR _c7
libld/vldldptr.c:	int vldldptr (ldptr) LDFILE *ldptr; { int ret; return ret; }
curses.h:#define vline(c,num) wvline(stdscr,c,num)
libc VPRINTF(3S):	int vprintf (s, v) char *s; va_list v; { return (0); }
libc VPRINTF(3S):	int vsprintf (p, s, v) char *p, *s; va_list v; { return (0); }
libcurses/addch.c:	int waddch (win, c) WINDOW *win; chtype c; { int ret; return ret; }
curses.h:#define waddchstr(win,str) waddchnstr((win),(str),-1)
curses.h:libcurses/addstr.c:	int waddstr (win,str) WINDOW *win; char *str; { int ret; return ret; }
libc WAIT(2):	int wait (s) int *s; { return (0); }
term.h:#define wait_tone CURS strs3._wait_tone
curses.h:libcurses/wattroff.c:	int wattroff (win, attrs) WINDOW *win; int attrs; { int ret; return ret; }
curses.h:libcurses/wattron.c:	int wattron (win, attrs) WINDOW *win; int attrs; { int ret; return ret; }
curses.h:libcurses/wattrset.c:	int wattrset (win, attrs) WINDOW *win; int attrs; { int ret; return ret; }
curses.h:#define wbkgdset(win,c) (((win)->_attrs = (((win)->_attrs & ~((win)->_bkgd & A_ATTRIBUTES)) | (c & A_ATTRIBUTES))), ((win)->_bkgd = (c)))
curses.h:libcurses/clear.c:	int wclear (win) WINDOW *win; { int ret; return ret; }
libcurses/clrtobot.c:	int wclrtobot (win) WINDOW *win; { int ret; return ret; }
libcurses/clrtoeol.c:	int wclrtoeol (win) WINDOW *win; { int ret; return ret; }
libcurses/delch.c:	int wdelch (win) WINDOW *win; { int ret; return ret; }
curses.h:libcurses/deleteln.c:	int wdeleteln (win) WINDOW *win; { int ret; return ret; }
curses.h:libcurses/erase.c:	int werase (win) WINDOW *win; { int ret; return ret; }
libcurses/getch.c:	int wgetch (win) WINDOW *win; { int ret; return ret; }
libcurses/getstr.c:	int wgetstr (win,str) WINDOW *win; char *str; { int ret; return ret; }
term.h:#define width_status_line CUR _c8
curses.h:#define winch(win) ((win)->_y[(win)->_cury][(win)->_curx])
curses.h:#define winchstr(win,str) winchnstr((win),str,((win)->_maxx - (win)->_curx))
libcurses/insch.c:	int winsch (win, c) WINDOW *win; chtype c; { int ret; return ret; }
curses.h:libcurses/insertln.c:	int winsertln (win) WINDOW *win; { int ret; return ret; }
curses.h:#define winsstr(win,str) winsnstr((win),(str),-1)
curses.h:#define winstr(win,str) winnstr((win),str,((win)->_maxx - (win)->_curx))
libcurses/move.c:	int wmove (win, y, x) WINDOW *win; int y, x; { int ret; return ret; }
libcurses/wnoutrfrsh.c:	int wnoutrefresh (win) WINDOW *win; { int ret; return ret; }
libcurses/wprintw.c:	/* VARARGS2 */ int wprintw (win, fmt) WINDOW *win; char *fmt; { int ret; return ret; }
libcurses/wrefresh.c:	int wrefresh (win) WINDOW *win; { int ret; return ret; }
libc WRITE(2):	int write (f, b, n) char *b; unsigned n; { return (f); }
libcurses/wscanw.c:	/* VARARGS2 */ int wscanw (win, fmt) WINDOW *win; char *fmt; { int ret; return ret; }
curses.h:libcurses/wstandend.c:	int wstandend (win) WINDOW *win; { int ret; return ret; }
curses.h:libcurses/wstandout.c:	int wstandout (win) WINDOW *win; { int ret; return ret; }
curses.h:#define wtimeout(win,tm) ((win)->_delay = (tm))
libPW/xalloc.c:	int xalloc (asize) unsigned asize; { int ret; return ret; }
libPW/xcreat.c:	int xcreat (name,mode) char *name; int mode; { int ret; return ret; }
macros.h:#define xfcreat(file,mode) fdfopen(xcreat(file,mode),1)
macros.h:#define xfopen(file,mode) fdfopen(xopen(file,mode),mode)
libPW/xalloc.c:	int xfree (aptr) char *aptr; { int ret; return ret; }
libPW/xalloc.c:	int xfreeall () { int ret; return ret; }
libPW/xlink.c:	int xlink (f1,f2) char *f1, *f2; { int ret; return ret; }
libPW/xmsg.c:	int xmsg (file,func) char *file, *func; { int ret; return ret; }
term.h:#define xoff_character CURS strs2._xoff_character
term.h:#define xon_character CURS strs2._xon_character
term.h:#define xon_xoff CUR _b21
libPW/xopen.c:	int xopen (name,mode) char name[]; int mode; { int ret; return ret; }
libPW/xpipe.c:	int xpipe (t) int *t; { int ret; return ret; }
libPW/xunlink.c:	int xunlink (f) char *f; { int ret; return ret; }
libPW/xwrite.c:	int xwrite (fildes,buffer,nbytes) char *buffer; { int ret; return ret; }
libm BESSEL(3M):	double y0 (x) double x; { return (x); }
libm BESSEL(3M):	double y1 (x) double x; { return (x); }
libm BESSEL(3M):	double yn (n, x) double x; { return (x); }
liby/libzer.c:	int yyerror ( s ) char *s; { int ret; return ret; }
libl/yyless.c:	int yyless (x) { int ret; return ret; }
libl/reject.c:	int yyracc (m) { int ret; return ret; }
libl/reject.c:	int yyreject () { int ret; return ret; }
libl/yywrap.c:	int yywrap () { int ret; return ret; }
libPW/zero.c:	char * zero (p,n) char *p; int n; { char *ret; return ret; }
libPW/zeropad.c:	char * zeropad (str) char *str; { char *ret; return ret; }
